diff --git a/src/.DS_Store b/src/.DS_Store
new file mode 100644
index 0000000..2eb91c9
Binary files /dev/null and b/src/.DS_Store differ
diff --git a/hdc/src/CMakeLists.txt b/hdc/src/CMakeLists.txt
deleted file mode 100644
index a73695e..0000000
--- a/hdc/src/CMakeLists.txt
+++ /dev/null
@@ -1,14 +0,0 @@
-cmake_minimum_required (VERSION 3.4)
-
-project (hdc)
-
-get_filename_component(ohos_top "${CMAKE_CURRENT_LIST_DIR}/../../.." REALPATH)
-
-set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++17 -ggdb -Wall -pg")
-
-include_directories(include common
-    ${ohos_top}/third_party/bounds_checking_function/include
-    ${ohos_top}/utils/native/base/include)
-
-add_subdirectory(daemon)
-add_subdirectory(host)
diff --git a/hdc/src/common/common.h b/src/common/common.h
index f6bbb36..ec9ef8a 100644
--- a/hdc/src/common/common.h
+++ b/src/common/common.h
@@ -47,21 +47,21 @@ using std::vector;
 
 // clang-format off
 #include <uv.h>  // libuv 1.35
-#ifdef HDC_HOST
+// #ifdef HDC_HOST
 
-#ifdef HARMONY_PROJECT
-#include <libusb/libusb.h>
-#else  // NOT HARMONY_PROJECT
-#include <libusb-1.0/libusb.h>
-#endif // END HARMONY_PROJECT
+// #ifdef HARMONY_PROJECT
+// #include <libusb.h>
+// #else  // NOT HARMONY_PROJECT
+// #include <libusb-1.0/libusb.h>
+// #endif // END HARMONY_PROJECT
 
-#else // NOT HDC_HOST
-#endif // HDC_HOST
+// #else // NOT HDC_HOST
+// #endif // HDC_HOST
 
-#ifndef _WIN32
-#include <sys/socket.h>
-#include <sys/un.h>
-#endif
+// #ifndef _WIN32
+// #include <sys/socket.h>
+// #include <sys/un.h>
+// #endif
 
 #include <securec.h>
 #include <limits.h>
@@ -76,7 +76,7 @@ using std::vector;
 #include "auth.h"
 
 #include "tcp.h"
-#include "usb.h"
+// #include "usb.h"
 #ifdef HDC_SUPPORT_UART
 #include "uart.h"
 #endif
diff --git a/hdc/src/common/define.h b/src/common/define.h
index 669f419..5d219d3 100644
--- a/hdc/src/common/define.h
+++ b/src/common/define.h
@@ -150,14 +150,14 @@ const string CMDSTR_TMODE_USB = "usb";
 const string HILOG_NAME = "hilog.exe";
 const string SPLIT = "\\";
 #endif
-#ifdef HDC_SUPPORT_UART
-const string CMDSTR_TMODE_UART = "uart";
-const string UART_HDC_NODE = "/dev/ttyS4";
-const string CONSOLE_ACTIVE_NODE = "/sys/class/tty/console/active";
-constexpr int UART_IO_WAIT_TIME_100 = 100;
-constexpr int UART_IO_WAIT_TIME = 1000;
-constexpr uint16_t MAX_UART_SIZE_IOBUF = 4096; // MAX_SIZE_IOBUF;
-#endif
+// #ifdef HDC_SUPPORT_UART
+// const string CMDSTR_TMODE_UART = "uart";
+// const string UART_HDC_NODE = "/dev/ttyS4";
+// const string CONSOLE_ACTIVE_NODE = "/sys/class/tty/console/active";
+// constexpr int UART_IO_WAIT_TIME_100 = 100;
+// constexpr int UART_IO_WAIT_TIME = 1000;
+// constexpr uint16_t MAX_UART_SIZE_IOBUF = 4096; // MAX_SIZE_IOBUF;
+// #endif
 const string CMDSTR_TMODE_TCP = "tcp";
 #ifdef HDC_EMULATOR
 const string CMDSTR_TMODE_BRIDGE = "bridge";
@@ -169,7 +169,7 @@ const string CMDSTR_FORWARD_FPORT = "fport";
 const string CMDSTR_FORWARD_RPORT = "rport";
 const string CMDSTR_APP_INSTALL = "install";
 const string CMDSTR_APP_UNINSTALL = "uninstall";
-const string CMDSTR_APP_SIDELOAD = "sideload";
+// const string CMDSTR_APP_SIDELOAD = "sideload";
 const string CMDSTR_LIST_JDWP = "jpid";
 const string CMDSTR_TRACK_JDWP = "track-jpid";
 const string CMDSTR_INNER_ENABLE_KEEPALIVE = "alive";
diff --git a/hdc/src/common/define_enum.h b/src/common/define_enum.h
index d6ddcb6..b12c52b 100644
--- a/hdc/src/common/define_enum.h
+++ b/src/common/define_enum.h
@@ -36,31 +36,31 @@ enum MessageLevel {
 enum ConnType { CONN_USB = 0, CONN_TCP, CONN_SERIAL, CONN_BT, CONN_UNKNOWN };
 const string conTypeDetail[] = { "USB", "TCP", "UART", "BT", "UNKNOWN" };
 
-#ifdef HDC_SUPPORT_UART
-enum UartTimeConst {
-    UV_TIMEOUT = 10,
-    UV_REPEAT = 100,
-    TIMEOUTS_R_INTERALTIMEOUT = 1000,
-    TIMEOUTS_R_TOALTIMEOUTMULTIPLIER = 500,
-    TIMEOUTS_R_TIMEOUTCONSTANT = 5000
-};
-enum UartSetSerialNBits {
-    UART_BIT1 = 7,
-    UART_BIT2 = 8
-};
-enum UartSetSerialNSpeed {
-    UART_SPEED2400 = 2400,
-    UART_SPEED4800 = 4800,
-    UART_SPEED9600 = 9600,
-    UART_SPEED115200 = 115200,
-    UART_SPEED921600 = 921600,
-    UART_SPEED1500000 = 1500000
-};
-enum UartSetSerialNStop {
-    UART_STOP1 = 1,
-    UART_STOP2 = 2
-};
-#endif
+// #ifdef HDC_SUPPORT_UART
+// enum UartTimeConst {
+//     UV_TIMEOUT = 10,
+//     UV_REPEAT = 100,
+//     TIMEOUTS_R_INTERALTIMEOUT = 1000,
+//     TIMEOUTS_R_TOALTIMEOUTMULTIPLIER = 500,
+//     TIMEOUTS_R_TIMEOUTCONSTANT = 5000
+// };
+// enum UartSetSerialNBits {
+//     UART_BIT1 = 7,
+//     UART_BIT2 = 8
+// };
+// enum UartSetSerialNSpeed {
+//     UART_SPEED2400 = 2400,
+//     UART_SPEED4800 = 4800,
+//     UART_SPEED9600 = 9600,
+//     UART_SPEED115200 = 115200,
+//     UART_SPEED921600 = 921600,
+//     UART_SPEED1500000 = 1500000
+// };
+// enum UartSetSerialNStop {
+//     UART_STOP1 = 1,
+//     UART_STOP2 = 2
+// };
+// #endif
 enum ConnStatus { STATUS_UNKNOW = 0, STATUS_READY, STATUS_CONNECTED, STATUS_OFFLINE, STATUS_UNAUTH };
 const string conStatusDetail[] = { "Unknown", "Ready", "Connected", "Offline", "Unauthorized" };
 
@@ -203,24 +203,24 @@ enum HdcCommand {
     // deprecated, remove later
     CMD_UNITY_JPID = CMD_JDWP_LIST,
 
-    // Flashd commands
-    CMD_FLASHD_UPDATE_INIT = 4000,
-    CMD_FLASHD_FLASH_INIT,
-    CMD_FLASHD_CHECK,
-    CMD_FLASHD_BEGIN,
-    CMD_FLASHD_DATA,
-    CMD_FLASHD_FINISH,
-    CMD_FLASHD_ERASE,
-    CMD_FLASHD_FORMAT,
-    CMD_FLASHD_PROGRESS,
+    // // Flashd commands
+    // CMD_FLASHD_UPDATE_INIT = 4000,
+    // CMD_FLASHD_FLASH_INIT,
+    // CMD_FLASHD_CHECK,
+    // CMD_FLASHD_BEGIN,
+    // CMD_FLASHD_DATA,
+    // CMD_FLASHD_FINISH,
+    // CMD_FLASHD_ERASE,
+    // CMD_FLASHD_FORMAT,
+    // CMD_FLASHD_PROGRESS,
 };
 
-enum UsbProtocolOption {
-    USB_OPTION_HEADER = 1,
-    USB_OPTION_RESET = 2,
-    USB_OPTION_RESERVE4 = 4,
-    USB_OPTION_RESERVE8 = 8,
-    USB_OPTION_RESERVE16 = 16,
-};
+// enum UsbProtocolOption {
+//     USB_OPTION_HEADER = 1,
+//     USB_OPTION_RESET = 2,
+//     USB_OPTION_RESERVE4 = 4,
+//     USB_OPTION_RESERVE8 = 8,
+//     USB_OPTION_RESERVE16 = 16,
+// };
 }
 #endif
\ No newline at end of file
diff --git a/hdc/src/common/define_plus.h b/src/common/define_plus.h
index cfe8b86..bfb11e8 100644
--- a/hdc/src/common/define_plus.h
+++ b/src/common/define_plus.h
@@ -102,93 +102,93 @@ using HTaskInfo = TaskInformation *;
 #pragma pack(pop)
 
 #ifdef HDC_HOST
-struct HostUSBEndpoint {
-    HostUSBEndpoint(uint32_t epBufSize)
-    {
-        endpoint = 0;
-        sizeEpBuf = epBufSize;  // MAX_USBFFS_BULK
-        transfer = libusb_alloc_transfer(0);
-        isShutdown = true;
-        isComplete = true;
-        bulkInOut = false;
-        buf = new (std::nothrow) uint8_t[sizeEpBuf];
-        (void)memset_s(buf, sizeEpBuf, 0, sizeEpBuf);
-    }
-    ~HostUSBEndpoint()
-    {
-        libusb_free_transfer(transfer);
-        delete[] buf;
-    }
-    uint8_t endpoint;
-    uint8_t *buf;  // MAX_USBFFS_BULK
-    bool isComplete;
-    bool isShutdown;
-    bool bulkInOut;  // true is bulkIn
-    uint32_t sizeEpBuf;
-    std::mutex mutexIo;
-    std::mutex mutexCb;
-    condition_variable cv;
-    libusb_transfer *transfer;
-};
+// struct HostUSBEndpoint {
+//     HostUSBEndpoint(uint32_t epBufSize)
+//     {
+//         endpoint = 0;
+//         sizeEpBuf = epBufSize;  // MAX_USBFFS_BULK
+//         transfer = libusb_alloc_transfer(0);
+//         isShutdown = true;
+//         isComplete = true;
+//         bulkInOut = false;
+//         buf = new (std::nothrow) uint8_t[sizeEpBuf];
+//         (void)memset_s(buf, sizeEpBuf, 0, sizeEpBuf);
+//     }
+//     ~HostUSBEndpoint()
+//     {
+//         libusb_free_transfer(transfer);
+//         delete[] buf;
+//     }
+//     uint8_t endpoint;
+//     uint8_t *buf;  // MAX_USBFFS_BULK
+//     bool isComplete;
+//     bool isShutdown;
+//     bool bulkInOut;  // true is bulkIn
+//     uint32_t sizeEpBuf;
+//     std::mutex mutexIo;
+//     std::mutex mutexCb;
+//     condition_variable cv;
+//     libusb_transfer *transfer;
+// };
 #endif
 
-struct HdcUSB {
-#ifdef HDC_HOST
-    libusb_context *ctxUSB = nullptr;  // child-use, main null
-    libusb_device *device;
-    libusb_device_handle *devHandle;
-    uint16_t retryCount;
-    uint8_t devId;
-    uint8_t busId;
-    uint8_t interfaceNumber;
-    std::string serialNumber;
-    std::string usbMountPoint;
-    HostUSBEndpoint hostBulkIn;
-    HostUSBEndpoint hostBulkOut;
-    HdcUSB() : hostBulkIn(513 * 1024), hostBulkOut(512 * 1024) {} // 513: 512 + 1, 1024: 1KB
-    // 512 * 1024 + 1024 = 513 * 1024, MAX_USBFFS_BULK: 512 * 1024
+// struct HdcUSB {
+// #ifdef HDC_HOST
+//     libusb_context *ctxUSB = nullptr;  // child-use, main null
+//     libusb_device *device;
+//     libusb_device_handle *devHandle;
+//     uint16_t retryCount;
+//     uint8_t devId;
+//     uint8_t busId;
+//     uint8_t interfaceNumber;
+//     std::string serialNumber;
+//     std::string usbMountPoint;
+//     HostUSBEndpoint hostBulkIn;
+//     HostUSBEndpoint hostBulkOut;
+//     HdcUSB() : hostBulkIn(513 * 1024), hostBulkOut(512 * 1024) {} // 513: 512 + 1, 1024: 1KB
+//     // 512 * 1024 + 1024 = 513 * 1024, MAX_USBFFS_BULK: 512 * 1024
 
-#else
-    // usb accessory FunctionFS
-    // USB main thread use, sub-thread disable, sub-thread uses the main thread USB handle
-    int bulkOut;  // EP1 device recv
-    int bulkIn;   // EP2 device send
-#endif
-    uint32_t payloadSize;
-    uint16_t wMaxPacketSizeSend;
-    bool resetIO;  // if true, must break write and read,default false
-    std::mutex lockDeviceHandle;
-    std::mutex lockSendUsbBlock;
-};
-using HUSB = struct HdcUSB *;
+// #else
+//     // usb accessory FunctionFS
+//     // USB main thread use, sub-thread disable, sub-thread uses the main thread USB handle
+//     int bulkOut;  // EP1 device recv
+//     int bulkIn;   // EP2 device send
+// #endif
+//     uint32_t payloadSize;
+//     uint16_t wMaxPacketSizeSend;
+//     bool resetIO;  // if true, must break write and read,default false
+//     std::mutex lockDeviceHandle;
+//     std::mutex lockSendUsbBlock;
+// };
+// using HUSB = struct HdcUSB *;
 
-#ifdef HDC_SUPPORT_UART
-struct HdcUART {
-#ifdef HDC_HOST
-    std::string serialPort;
-    std::thread readThread;
-    uint16_t retryCount = 0;
-#endif // HDC_HOST
+// #ifdef HDC_SUPPORT_UART
+// struct HdcUART {
+// #ifdef HDC_HOST
+//     std::string serialPort;
+//     std::thread readThread;
+//     uint16_t retryCount = 0;
+// #endif // HDC_HOST
 
-#ifdef _WIN32
-    OVERLAPPED ovWrite;
-    OVERLAPPED ovRead;
-    HANDLE devUartHandle = INVALID_HANDLE_VALUE;
-#else
-    // we also make this for daemon side
-    int devUartHandle = -1;
-#endif
-    // if we want to cancel io (read thread exit)
-    bool ioCancel = false;
-    uint32_t dispatchedPackageIndex = 0;
-    bool resetIO = false; // if true, must break write and read,default false
-    uint64_t packageIndex = 0;
-    std::atomic_size_t streamSize = 0; // for debug only
-    HdcUART();
-    ~HdcUART();
-};
-using HUART = struct HdcUART *;
-#endif
+// #ifdef _WIN32
+//     OVERLAPPED ovWrite;
+//     OVERLAPPED ovRead;
+//     HANDLE devUartHandle = INVALID_HANDLE_VALUE;
+// #else
+//     // we also make this for daemon side
+//     int devUartHandle = -1;
+// #endif
+//     // if we want to cancel io (read thread exit)
+//     bool ioCancel = false;
+//     uint32_t dispatchedPackageIndex = 0;
+//     bool resetIO = false; // if true, must break write and read,default false
+//     uint64_t packageIndex = 0;
+//     std::atomic_size_t streamSize = 0; // for debug only
+//     HdcUART();
+//     ~HdcUART();
+// };
+// using HUART = struct HdcUART *;
+// #endif
 struct HdcSessionStat {
     // bytes successed send to hSession->dataFd[STREAM_MAIN]
     std::atomic<uint64_t> dataSendBytes;
@@ -232,9 +232,9 @@ struct HdcSession {
     uv_tcp_t hChildWorkTCP;  // work channel，separate thread for server/daemon
     uv_os_sock_t fdChildWorkTCP;
     // usb handle
-    HUSB hUSB;
+    // HUSB hUSB;
 #ifdef HDC_SUPPORT_UART
-    HUART hUART = nullptr;
+    // HUART hUART = nullptr;
 #endif
     // tcp handle
     uv_tcp_t hWorkTCP;
@@ -278,7 +278,7 @@ struct HdcSession {
         listKey = nullptr;
         authKeyIndex = 0;
         tokenRSA = "";
-        hUSB = nullptr;
+        // hUSB = nullptr;
         (void)memset_s(pollHandle, sizeof(pollHandle), 0, sizeof(pollHandle));
         (void)memset_s(ctrlFd, sizeof(ctrlFd), 0, sizeof(ctrlFd));
         (void)memset_s(dataFd, sizeof(dataFd), 0, sizeof(dataFd));
@@ -287,9 +287,9 @@ struct HdcSession {
         (void)memset_s(&hChildWorkTCP, sizeof(hChildWorkTCP), 0, sizeof(hChildWorkTCP));
         (void)memset_s(&fdChildWorkTCP, sizeof(fdChildWorkTCP), 0, sizeof(fdChildWorkTCP));
         (void)memset_s(&stat, sizeof(stat), 0, sizeof(stat));
-#ifdef HDC_SUPPORT_UART
-        hUART = nullptr;
-#endif
+// #ifdef HDC_SUPPORT_UART
+//         // hUART = nullptr;
+// #endif
         verifyType = AuthVerifyType::RSA_3072_SHA512;
         isNeedDropData = true;
         isSoftReset = false;
diff --git a/hdc/src/common/session.cpp b/src/common/session.cpp
index b4304ef..4e2259c 100644
--- a/hdc/src/common/session.cpp
+++ b/src/common/session.cpp
@@ -49,15 +49,14 @@ HdcSessionBase::HdcSessionBase(bool serverOrDaemonIn, size_t uvThreadSize)
     ctxUSB = nullptr;
     wantRestart = false;
     threadSessionMain = uv_thread_self();
-
-#ifdef HDC_HOST
-    if (serverOrDaemon) {
-        if (libusb_init((libusb_context **)&ctxUSB) != 0) {
-            ctxUSB = nullptr;
-            WRITE_LOG(LOG_FATAL, "libusb_init failed ctxUSB is nullptr");
-        }
-    }
-#endif
+// #ifdef HDC_HOST
+//     if (serverOrDaemon) {
+//         if (libusb_init((libusb_context **)&ctxUSB) != 0) {
+//             ctxUSB = nullptr;
+//             WRITE_LOG(LOG_FATAL, "libusb_init failed ctxUSB is nullptr");
+//         }
+//     }
+// #endif
 }
 
 HdcSessionBase::~HdcSessionBase()
@@ -67,11 +66,11 @@ HdcSessionBase::~HdcSessionBase()
     // clear base
     uv_rwlock_destroy(&mainAsync);
     uv_rwlock_destroy(&lockMapSession);
-#ifdef HDC_HOST
-    if (serverOrDaemon and ctxUSB != nullptr) {
-        libusb_exit((libusb_context *)ctxUSB);
-    }
-#endif
+// #ifdef HDC_HOST
+//     if (serverOrDaemon and ctxUSB != nullptr) {
+//         libusb_exit((libusb_context *)ctxUSB);
+//     }
+// #endif
     WRITE_LOG(LOG_WARN, "~HdcSessionBase free sessionRef:%u instance:%s", uint32_t(sessionRef),
               serverOrDaemon ? "server" : "daemon");
 }
@@ -197,87 +196,87 @@ void HdcSessionBase::ReMainLoopForInstanceClear()
     uv_run(&loopMain, UV_RUN_DEFAULT);
 };
 
-#ifdef HDC_SUPPORT_UART
-void HdcSessionBase::EnumUARTDeviceRegister(UartKickoutZombie kickOut)
-{
-    uv_rwlock_rdlock(&lockMapSession);
-    map<uint32_t, HSession>::iterator i;
-    for (i = mapSession.begin(); i != mapSession.end(); ++i) {
-        HSession hs = i->second;
-        if ((hs->connType != CONN_SERIAL) or (hs->hUART == nullptr)) {
-            continue;
-        }
-        kickOut(hs);
-        break;
-    }
-    uv_rwlock_rdunlock(&lockMapSession);
-}
-#endif
+// #ifdef HDC_SUPPORT_UART
+// void HdcSessionBase::EnumUARTDeviceRegister(UartKickoutZombie kickOut)
+// {
+//     uv_rwlock_rdlock(&lockMapSession);
+//     map<uint32_t, HSession>::iterator i;
+//     for (i = mapSession.begin(); i != mapSession.end(); ++i) {
+//         HSession hs = i->second;
+//         if ((hs->connType != CONN_SERIAL) or (hs->hUART == nullptr)) {
+//             continue;
+//         }
+//         kickOut(hs);
+//         break;
+//     }
+//     uv_rwlock_rdunlock(&lockMapSession);
+// }
+// #endif
 
-void HdcSessionBase::EnumUSBDeviceRegister(void (*pCallBack)(HSession hSession))
-{
-    if (!pCallBack) {
-        return;
-    }
-    uv_rwlock_rdlock(&lockMapSession);
-    map<uint32_t, HSession>::iterator i;
-    for (i = mapSession.begin(); i != mapSession.end(); ++i) {
-        HSession hs = i->second;
-        if (hs->connType != CONN_USB) {
-            continue;
-        }
-        if (hs->hUSB == nullptr) {
-            continue;
-        }
-        if (pCallBack) {
-            pCallBack(hs);
-        }
-        break;
-    }
-    uv_rwlock_rdunlock(&lockMapSession);
-}
+// void HdcSessionBase::EnumUSBDeviceRegister(void (*pCallBack)(HSession hSession))
+// {
+//     // if (!pCallBack) {
+//     //     return;
+//     // }
+//     // uv_rwlock_rdlock(&lockMapSession);
+//     // map<uint32_t, HSession>::iterator i;
+//     // for (i = mapSession.begin(); i != mapSession.end(); ++i) {
+//     //     HSession hs = i->second;
+//     //     if (hs->connType != CONN_USB) {
+//     //         continue;
+//     //     }
+//     //     if (hs->hUSB == nullptr) {
+//     //         continue;
+//     //     }
+//     //     if (pCallBack) {
+//     //         pCallBack(hs);
+//     //     }
+//     //     break;
+//     // }
+//     // uv_rwlock_rdunlock(&lockMapSession);
+// }
 
 // The PC side gives the device information, determines if the USB device is registered
 // PDEV and Busid Devid two choices
-HSession HdcSessionBase::QueryUSBDeviceRegister(void *pDev, uint8_t busIDIn, uint8_t devIDIn)
-{
-#ifdef HDC_HOST
-    libusb_device *dev = (libusb_device *)pDev;
-    HSession hResult = nullptr;
-    if (!mapSession.size()) {
-        return nullptr;
-    }
-    uint8_t busId = 0;
-    uint8_t devId = 0;
-    if (pDev) {
-        busId = libusb_get_bus_number(dev);
-        devId = libusb_get_device_address(dev);
-    } else {
-        busId = busIDIn;
-        devId = devIDIn;
-    }
-    uv_rwlock_rdlock(&lockMapSession);
-    map<uint32_t, HSession>::iterator i;
-    for (i = mapSession.begin(); i != mapSession.end(); ++i) {
-        HSession hs = i->second;
-        if (hs->connType == CONN_USB) {
-            continue;
-        }
-        if (hs->hUSB == nullptr) {
-            continue;
-        }
-        if (hs->hUSB->devId != devId || hs->hUSB->busId != busId) {
-            continue;
-        }
-        hResult = hs;
-        break;
-    }
-    uv_rwlock_rdunlock(&lockMapSession);
-    return hResult;
-#else
-    return nullptr;
-#endif
-}
+// HSession HdcSessionBase::QueryUSBDeviceRegister(void *pDev, uint8_t busIDIn, uint8_t devIDIn)
+// {
+// // #ifdef HDC_HOST
+// //     libusb_device *dev = (libusb_device *)pDev;
+// //     HSession hResult = nullptr;
+// //     if (!mapSession.size()) {
+// //         return nullptr;
+// //     }
+// //     uint8_t busId = 0;
+// //     uint8_t devId = 0;
+// //     if (pDev) {
+// //         busId = libusb_get_bus_number(dev);
+// //         devId = libusb_get_device_address(dev);
+// //     } else {
+// //         busId = busIDIn;
+// //         devId = devIDIn;
+// //     }
+// //     uv_rwlock_rdlock(&lockMapSession);
+// //     map<uint32_t, HSession>::iterator i;
+// //     for (i = mapSession.begin(); i != mapSession.end(); ++i) {
+// //         HSession hs = i->second;
+// //         if (hs->connType == CONN_USB) {
+// //             continue;
+// //         }
+// //         if (hs->hUSB == nullptr) {
+// //             continue;
+// //         }
+// //         if (hs->hUSB->devId != devId || hs->hUSB->busId != busId) {
+// //             continue;
+// //         }
+// //         hResult = hs;
+// //         break;
+// //     }
+// //     uv_rwlock_rdunlock(&lockMapSession);
+// //     return hResult;
+// // #else
+//     return nullptr;
+// // #endif
+// }
 
 void HdcSessionBase::AsyncMainLoopTask(uv_idle_t *handle)
 {
@@ -356,39 +355,44 @@ void HdcSessionBase::WorkerPendding()
 int HdcSessionBase::MallocSessionByConnectType(HSession hSession)
 {
     int ret = 0;
-    switch (hSession->connType) {
-        case CONN_TCP: {
-            uv_tcp_init(&loopMain, &hSession->hWorkTCP);
-            ++hSession->uvHandleRef;
-            hSession->hWorkTCP.data = hSession;
-            break;
-        }
-        case CONN_USB: {
-            // Some members need to be placed at the primary thread
-            HUSB hUSB = new HdcUSB();
-            if (!hUSB) {
-                ret = -1;
-                break;
-            }
-            hSession->hUSB = hUSB;
-            hSession->hUSB->wMaxPacketSizeSend = MAX_PACKET_SIZE_HISPEED;
-            break;
-        }
-#ifdef HDC_SUPPORT_UART
-        case CONN_SERIAL: {
-            HUART hUART = new HdcUART();
-            if (!hUART) {
-                ret = -1;
-                break;
-            }
-            hSession->hUART = hUART;
-            break;
-        }
-#endif // HDC_SUPPORT_UART
-        default:
-            ret = -1;
-            break;
-    }
+//     switch (hSession->connType) {
+//         case CONN_TCP: {
+    uv_tcp_init(&loopMain, &hSession->hWorkTCP);
+    ++hSession->uvHandleRef;
+    hSession->hWorkTCP.data = hSession;
+//             break;
+//         }
+//         // case CONN_USB: {
+//         //     // Some members need to be placed at the primary thread
+//         //     HUSB hUSB = new HdcUSB();
+//         //     if (!hUSB) {
+//         //         ret = -1;
+//         //         break;
+//         //     }
+//         //     hSession->hUSB = hUSB;
+//         //     hSession->hUSB->wMaxPacketSizeSend = MAX_PACKET_SIZE_HISPEED;
+//         //     break;
+//         // }
+// // #ifdef HDC_SUPPORT_UART
+// //         case CONN_SERIAL: {
+// //             HUART hUART = new HdcUART();
+// //             if (!hUART) {
+// //                 ret = -1;
+// //                 break;
+// //             }
+// //             hSession->hUART = hUART;
+// //             break;
+// //         }
+// // #endif // HDC_SUPPORT_UART
+//         default:
+//             if(hSession->connType == CONN_USB) {
+//                 WRITE_LOG(LOG_WARN, "CONN_USB is disabled.");
+//                 ret = -1;
+//             }
+//         // default:
+//         //     ret = -1;
+//         //     break;
+//     }
     return ret;
 }
 
@@ -486,55 +490,54 @@ HSession HdcSessionBase::MallocSession(bool serverOrDaemon, const ConnType connT
 void HdcSessionBase::FreeSessionByConnectType(HSession hSession)
 {
     WRITE_LOG(LOG_DEBUG, "FreeSessionByConnectType %s", hSession->ToDebugString().c_str());
-
-    if (hSession->connType == CONN_USB) {
-        // ibusb All context is applied for sub-threaded, so it needs to be destroyed in the subline
-        if (!hSession->hUSB) {
-            return;
-        }
-        HUSB hUSB = hSession->hUSB;
-        if (!hUSB) {
-            return;
-        }
-#ifdef HDC_HOST
-        if (hUSB->devHandle) {
-            libusb_release_interface(hUSB->devHandle, hUSB->interfaceNumber);
-            libusb_close(hUSB->devHandle);
-            hUSB->devHandle = nullptr;
-        }
-#else
-        Base::CloseFd(hUSB->bulkIn);
-        Base::CloseFd(hUSB->bulkOut);
-#endif
-        delete hSession->hUSB;
-        hSession->hUSB = nullptr;
-    }
-#ifdef HDC_SUPPORT_UART
-    if (CONN_SERIAL == hSession->connType) {
-        if (!hSession->hUART) {
-            return;
-        }
-        HUART hUART = hSession->hUART;
-        if (!hUART) {
-            return;
-        }
-        HdcUARTBase *uartBase = (HdcUARTBase *)hSession->classModule;
-        // tell uart session will be free
-        uartBase->StopSession(hSession);
-#ifdef HDC_HOST
-#ifdef HOST_MINGW
-        if (hUART->devUartHandle != INVALID_HANDLE_VALUE) {
-            CloseHandle(hUART->devUartHandle);
-            hUART->devUartHandle = INVALID_HANDLE_VALUE;
-        }
-#elif defined(HOST_LINUX)
-        Base::CloseFd(hUART->devUartHandle);
-#endif // _WIN32
-#endif
-        delete hSession->hUART;
-        hSession->hUART = nullptr;
-    }
-#endif
+//     if (hSession->connType == CONN_USB) {
+//         // ibusb All context is applied for sub-threaded, so it needs to be destroyed in the subline
+//         if (!hSession->hUSB) {
+//             return;
+//         }
+//         HUSB hUSB = hSession->hUSB;
+//         if (!hUSB) {
+//             return;
+//         }
+// #ifdef HDC_HOST
+//         if (hUSB->devHandle) {
+//             libusb_release_interface(hUSB->devHandle, hUSB->interfaceNumber);
+//             libusb_close(hUSB->devHandle);
+//             hUSB->devHandle = nullptr;
+//         }
+// #else
+//         Base::CloseFd(hUSB->bulkIn);
+//         Base::CloseFd(hUSB->bulkOut);
+// #endif
+//         delete hSession->hUSB;
+//         hSession->hUSB = nullptr;
+//     }
+// #ifdef HDC_SUPPORT_UART
+//     if (CONN_SERIAL == hSession->connType) {
+//         if (!hSession->hUART) {
+//             return;
+//         }
+//         HUART hUART = hSession->hUART;
+//         if (!hUART) {
+//             return;
+//         }
+//         HdcUARTBase *uartBase = (HdcUARTBase *)hSession->classModule;
+//         // tell uart session will be free
+//         uartBase->StopSession(hSession);
+// #ifdef HDC_HOST
+// #ifdef HOST_MINGW
+//         if (hUART->devUartHandle != INVALID_HANDLE_VALUE) {
+//             CloseHandle(hUART->devUartHandle);
+//             hUART->devUartHandle = INVALID_HANDLE_VALUE;
+//         }
+// #elif defined(HOST_LINUX)
+//         Base::CloseFd(hUART->devUartHandle);
+// #endif // _WIN32
+// #endif
+//         delete hSession->hUART;
+//         hSession->hUART = nullptr;
+//     }
+// #endif
 }
 
 // work when libuv-handle at struct of HdcSession has all callback finished
@@ -599,14 +602,14 @@ void HdcSessionBase::FreeSessionOpeate(uv_timer_t *handle)
         return;
     }
     WRITE_LOG(LOG_INFO, "FreeSessionOpeate sid:%u ref:%u", hSession->sessionId, uint32_t(hSession->ref));
-#ifdef HDC_HOST
-    if (hSession->hUSB != nullptr
-        && (!hSession->hUSB->hostBulkIn.isShutdown || !hSession->hUSB->hostBulkOut.isShutdown)) {
-        HdcUSBBase *pUSB = ((HdcUSBBase *)hSession->classModule);
-        pUSB->CancelUsbIo(hSession);
-        return;
-    }
-#endif
+// #ifdef HDC_HOST
+//     if (hSession->hUSB != nullptr
+//         && (!hSession->hUSB->hostBulkIn.isShutdown || !hSession->hUSB->hostBulkOut.isShutdown)) {
+//         HdcUSBBase *pUSB = ((HdcUSBBase *)hSession->classModule);
+//         pUSB->CancelUsbIo(hSession);
+//         return;
+//     }
+// #endif
     // wait workthread to free
     if (hSession->pollHandle[STREAM_WORK]->loop) {
         auto ctrl = BuildCtrlString(SP_STOP_SESSION, 0, nullptr, 0);
@@ -813,37 +816,37 @@ int HdcSessionBase::SendByProtocol(HSession hSession, uint8_t *bufPtr, const int
         return ERR_SESSION_NOFOUND;
     }
     int ret = 0;
-    switch (hSession->connType) {
-        case CONN_TCP: {
-            HdcTCPBase *pTCP = ((HdcTCPBase *)hSession->classModule);
-            if (echo && !hSession->serverOrDaemon) {
-                ret = pTCP->WriteUvTcpFd(&hSession->hChildWorkTCP, bufPtr, bufLen);
-            } else {
-                if (hSession->hWorkThread == uv_thread_self()) {
-                    ret = pTCP->WriteUvTcpFd(&hSession->hWorkTCP, bufPtr, bufLen);
-                } else {
-                    ret = pTCP->WriteUvTcpFd(&hSession->hChildWorkTCP, bufPtr, bufLen);
-                }
-            }
-            break;
-        }
-        case CONN_USB: {
-            HdcUSBBase *pUSB = ((HdcUSBBase *)hSession->classModule);
-            ret = pUSB->SendUSBBlock(hSession, bufPtr, bufLen);
-            delete[] bufPtr;
-            break;
-        }
-#ifdef HDC_SUPPORT_UART
-        case CONN_SERIAL: {
-            HdcUARTBase *pUART = ((HdcUARTBase *)hSession->classModule);
-            ret = pUART->SendUARTData(hSession, bufPtr, bufLen);
-            delete[] bufPtr;
-            break;
+    // switch (hSession->connType) {
+    //     case CONN_TCP: {
+    HdcTCPBase *pTCP = ((HdcTCPBase *)hSession->classModule);
+    if (echo && !hSession->serverOrDaemon) {
+        ret = pTCP->WriteUvTcpFd(&hSession->hChildWorkTCP, bufPtr, bufLen);
+    } else {
+        if (hSession->hWorkThread == uv_thread_self()) {
+            ret = pTCP->WriteUvTcpFd(&hSession->hWorkTCP, bufPtr, bufLen);
+        } else {
+            ret = pTCP->WriteUvTcpFd(&hSession->hChildWorkTCP, bufPtr, bufLen);
         }
-#endif
-        default:
-            break;
     }
+    //         break;
+    //     }
+        // case CONN_USB: {
+        //     HdcUSBBase *pUSB = ((HdcUSBBase *)hSession->classModule);
+        //     ret = pUSB->SendUSBBlock(hSession, bufPtr, bufLen);
+        //     delete[] bufPtr;
+        //     break;
+        // }
+// #ifdef HDC_SUPPORT_UART
+//         case CONN_SERIAL: {
+//             HdcUARTBase *pUART = ((HdcUARTBase *)hSession->classModule);
+//             ret = pUART->SendUARTData(hSession, bufPtr, bufLen);
+//             delete[] bufPtr;
+//             break;
+//         }
+// #endif
+//         default:
+//             break;
+//     }
     return ret;
 }
 
@@ -1097,44 +1100,45 @@ bool HdcSessionBase::WorkThreadStartSession(HSession hSession)
 {
     bool regOK = false;
     int childRet = 0;
-    if (hSession->connType == CONN_TCP) {
-        HdcTCPBase *pTCPBase = (HdcTCPBase *)hSession->classModule;
-        hSession->hChildWorkTCP.data = hSession;
-        if (uv_tcp_init(&hSession->childLoop, &hSession->hChildWorkTCP) < 0) {
-            WRITE_LOG(LOG_WARN, "HdcSessionBase SessionCtrl failed 1");
-            return false;
-        }
-        if ((childRet = uv_tcp_open(&hSession->hChildWorkTCP, hSession->fdChildWorkTCP)) < 0) {
-            constexpr int bufSize = 1024;
-            char buf[bufSize] = { 0 };
-            uv_strerror_r(childRet, buf, bufSize);
-            WRITE_LOG(LOG_WARN, "SessionCtrl failed 2,fd:%d,str:%s", hSession->fdChildWorkTCP, buf);
-            return false;
-        }
-        Base::SetTcpOptions((uv_tcp_t *)&hSession->hChildWorkTCP);
-        uv_read_start((uv_stream_t *)&hSession->hChildWorkTCP, AllocCallback, pTCPBase->ReadStream);
-        regOK = true;
-#ifdef HDC_SUPPORT_UART
-    } else if (hSession->connType == CONN_SERIAL) { // UART
-        HdcUARTBase *pUARTBase = (HdcUARTBase *)hSession->classModule;
-        WRITE_LOG(LOG_DEBUG, "UART ReadyForWorkThread");
-        regOK = pUARTBase->ReadyForWorkThread(hSession);
-#endif
-    } else {  // USB
-        HdcUSBBase *pUSBBase = (HdcUSBBase *)hSession->classModule;
-        WRITE_LOG(LOG_DEBUG, "USB ReadyForWorkThread");
-        regOK = pUSBBase->ReadyForWorkThread(hSession);
-    }
+    // if (hSession->connType == CONN_TCP) {
+    HdcTCPBase *pTCPBase = (HdcTCPBase *)hSession->classModule;
+    hSession->hChildWorkTCP.data = hSession;
+    if (uv_tcp_init(&hSession->childLoop, &hSession->hChildWorkTCP) < 0) {
+        WRITE_LOG(LOG_WARN, "HdcSessionBase SessionCtrl failed 1");
+        return false;
+    }
+    if ((childRet = uv_tcp_open(&hSession->hChildWorkTCP, hSession->fdChildWorkTCP)) < 0) {
+        constexpr int bufSize = 1024;
+        char buf[bufSize] = { 0 };
+        uv_strerror_r(childRet, buf, bufSize);
+        WRITE_LOG(LOG_WARN, "SessionCtrl failed 2,fd:%d,str:%s", hSession->fdChildWorkTCP, buf);
+        return false;
+    }
+    Base::SetTcpOptions((uv_tcp_t *)&hSession->hChildWorkTCP);
+    uv_read_start((uv_stream_t *)&hSession->hChildWorkTCP, AllocCallback, pTCPBase->ReadStream);
+    regOK = true;
+    // }
+// #ifdef HDC_SUPPORT_UART
+//     } else if (hSession->connType == CONN_SERIAL) { // UART
+//         HdcUARTBase *pUARTBase = (HdcUARTBase *)hSession->classModule;
+//         WRITE_LOG(LOG_DEBUG, "UART ReadyForWorkThread");
+//         regOK = pUARTBase->ReadyForWorkThread(hSession);
+// #endif
+//     } else {  // USB
+//         HdcUSBBase *pUSBBase = (HdcUSBBase *)hSession->classModule;
+//         WRITE_LOG(LOG_DEBUG, "USB ReadyForWorkThread");
+//         regOK = pUSBBase->ReadyForWorkThread(hSession);
+//     }
 
     if (regOK && hSession->serverOrDaemon) {
         // session handshake step1
         SessionHandShake handshake = {};
         WorkThreadInitSession(hSession, handshake);
         string hs = SerialStruct::SerializeToString(handshake);
-#ifdef HDC_SUPPORT_UART
-        WRITE_LOG(LOG_DEBUG, "WorkThreadStartSession session %u auth %u send handshake hs: %s",
-                  hSession->sessionId, handshake.authType, hs.c_str());
-#endif
+// #ifdef HDC_SUPPORT_UART
+//         WRITE_LOG(LOG_DEBUG, "WorkThreadStartSession session %u auth %u send handshake hs: %s",
+//                   hSession->sessionId, handshake.authType, hs.c_str());
+// #endif
         Send(hSession->sessionId, 0, CMD_KERNEL_HANDSHAKE,
              reinterpret_cast<uint8_t *>(const_cast<char *>(hs.c_str())), hs.size());
     }
@@ -1336,10 +1340,10 @@ bool HdcSessionBase::NeedNewTaskInfo(const uint16_t command, bool &masterTask)
     masterTask = false;
     switch (command) {
         case CMD_FILE_INIT:
-        case CMD_FLASHD_FLASH_INIT:
-        case CMD_FLASHD_UPDATE_INIT:
-        case CMD_FLASHD_ERASE:
-        case CMD_FLASHD_FORMAT:
+        // case CMD_FLASHD_FLASH_INIT:
+        // case CMD_FLASHD_UPDATE_INIT:
+        // case CMD_FLASHD_ERASE:
+        // case CMD_FLASHD_FORMAT:
         case CMD_FORWARD_INIT:
         case CMD_APP_INIT:
         case CMD_APP_UNINSTALL:
diff --git a/hdc/src/common/uart.cpp b/hdc/src/common/uart.cpp
deleted file mode 100644
index 3e2d873..0000000
--- a/hdc/src/common/uart.cpp
+++ /dev/null
@@ -1,1057 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifdef HDC_SUPPORT_UART
-
-#include "uart.h"
-#ifdef HOST_MAC
-#include <fcntl.h>
-#include <sys/ioctl.h>
-#include <IOKit/serial/ioss.h>
-#define B1500000 1500000
-#define B921600 921600
-#endif
-
-using namespace std::chrono;
-namespace Hdc {
-ExternInterface HdcUARTBase::defaultInterface;
-
-void ExternInterface::SetTcpOptions(uv_tcp_t *tcpHandle)
-{
-    return Base::SetTcpOptions(tcpHandle);
-}
-
-int ExternInterface::SendToStream(uv_stream_t *handleStream, const uint8_t *buf, const int len)
-{
-    return Base::SendToStream(handleStream, buf, len);
-}
-
-int ExternInterface::SendToPollFd(int fd, const uint8_t *buf, const int len)
-{
-    return Base::SendToPollFd(fd, buf, len);
-}
-
-int ExternInterface::UvTcpInit(uv_loop_t *loop, uv_tcp_t *tcp, int socketFd)
-{
-    if (uv_tcp_init(loop, tcp) == 0) {
-        return uv_tcp_open(tcp, socketFd);
-    } else {
-        return -1;
-    }
-}
-
-int ExternInterface::UvRead(uv_stream_t *stream, uv_alloc_cb allocCallBack, uv_read_cb readCallBack)
-{
-    return uv_read_start(stream, allocCallBack, readCallBack);
-}
-
-int ExternInterface::StartWorkThread(uv_loop_t *loop, uv_work_cb pFuncWorkThread,
-                                     uv_after_work_cb pFuncAfterThread, void *pThreadData)
-{
-    return Base::StartWorkThread(loop, pFuncWorkThread, pFuncAfterThread, pThreadData);
-}
-
-void ExternInterface::TryCloseHandle(const uv_handle_t *handle, uv_close_cb closeCallBack)
-{
-    return Base::TryCloseHandle(handle, closeCallBack);
-}
-
-bool ExternInterface::TimerUvTask(uv_loop_t *loop, void *data, uv_timer_cb cb)
-{
-    return Base::TimerUvTask(loop, data, cb);
-}
-bool ExternInterface::UvTimerStart(uv_timer_t *handle, uv_timer_cb cb, uint64_t timeout,
-                                   uint64_t repeat)
-{
-    return uv_timer_start(handle, cb, timeout, repeat);
-}
-
-bool ExternInterface::DelayDo(uv_loop_t *loop, const int delayMs, const uint8_t flag, string msg,
-                              void *data, DelayCB cb)
-{
-    return Base::DelayDo(loop, delayMs, flag, msg, data, cb);
-}
-
-HdcUARTBase::HdcUARTBase(HdcSessionBase &sessionBaseIn, ExternInterface &interfaceIn)
-    : externInterface(interfaceIn), sessionBase(sessionBaseIn)
-{
-    uartOpened = false;
-}
-
-HdcUARTBase::~HdcUARTBase(void) {}
-
-#ifndef _WIN32
-int HdcUARTBase::GetUartSpeed(int speed)
-{
-    switch (speed) {
-        case UART_SPEED2400:
-            return (B2400);
-            break;
-        case UART_SPEED4800:
-            return (B4800);
-            break;
-        case UART_SPEED9600:
-            return (B9600);
-            break;
-        case UART_SPEED115200:
-            return (B115200);
-            break;
-        case UART_SPEED921600:
-            return (B921600);
-            break;
-        case UART_SPEED1500000:
-            return (B1500000);
-        default:
-            return (B921600);
-            break;
-    }
-}
-int HdcUARTBase::GetUartBits(int bits)
-{
-    switch (bits) {
-        case UART_BIT1:
-            return (CS7);
-            break;
-        case UART_BIT2:
-            return (CS8);
-            break;
-        default:
-            return (CS8);
-            break;
-    }
-}
-#if defined(HOST_MAC)
-int HdcUARTBase::SetSerial(int fd, int nSpeed, int nBits, char nEvent, int nStop)
-{
-    WRITE_LOG(LOG_DEBUG, "mac SetSerial rate = %d", nSpeed);
-    struct termios options;
-    struct termios oldttys1;
-    if (tcgetattr(fd, &oldttys1) != 0) {
-        constexpr int bufSize = 1024;
-        char buf[bufSize] = { 0 };
-        strerror_r(errno, buf, bufSize);
-        WRITE_LOG(LOG_DEBUG, "tcgetattr failed with %s\n", buf);
-        return ERR_GENERIC;
-    }
-
-    if (memcpy_s(&options, sizeof(options), &oldttys1, sizeof(options)) != EOK) {
-        return ERR_GENERIC;
-    }
-    cfmakeraw(&options);
-    options.c_cc[VMIN] = 0;
-    options.c_cc[VTIME] = 10; // 10 * 1/10 sec : 1 sec
-
-    cfsetspeed(&options, B19200);
-    options.c_cflag |= GetUartBits(nBits); // Use 8 bit words
-    options.c_cflag &= ~PARENB;
-
-    speed_t speed = nSpeed;
-    if (ioctl(fd, IOSSIOSPEED, &speed) == -1) {
-        WRITE_LOG(LOG_DEBUG, "set speed errno %d", errno);
-    }
-    if ((tcsetattr(fd, TCSANOW, &options)) != 0) {
-        WRITE_LOG(LOG_DEBUG, "com set error errno = %d", errno);
-        return ERR_GENERIC;
-    }
-    if (ioctl(fd, IOSSIOSPEED, &speed) == -1) {
-        WRITE_LOG(LOG_DEBUG, "set speed errno %d", errno);
-    }
-    WRITE_LOG(LOG_DEBUG, " SetSerial OK rate = %d", nSpeed);
-    return RET_SUCCESS;
-}
-#else
-int HdcUARTBase::SetSerial(int fd, int nSpeed, int nBits, char nEvent, int nStop)
-{
-    struct termios newttys1;
-    struct termios oldttys1;
-    if (tcgetattr(fd, &oldttys1) != 0) {
-        constexpr int bufSize = 1024;
-        char buf[bufSize] = { 0 };
-        strerror_r(errno, buf, bufSize);
-        WRITE_LOG(LOG_DEBUG, "tcgetattr failed with %s\n", buf);
-        return ERR_GENERIC;
-    }
-    bzero(&newttys1, sizeof(newttys1));
-    newttys1.c_cflag = GetUartSpeed(nSpeed);
-    newttys1.c_cflag |= (CLOCAL | CREAD);
-    newttys1.c_cflag &= ~CSIZE;
-    newttys1.c_lflag &= ~ICANON;
-    newttys1.c_cflag |= GetUartBits(nBits);
-    switch (nEvent) {
-        case 'O':
-            newttys1.c_cflag |= PARENB;
-            newttys1.c_iflag |= (INPCK | ISTRIP);
-            newttys1.c_cflag |= PARODD;
-            break;
-        case 'E':
-            newttys1.c_cflag |= PARENB;
-            newttys1.c_iflag |= (INPCK | ISTRIP);
-            newttys1.c_cflag &= ~PARODD;
-            break;
-        case 'N':
-            newttys1.c_cflag &= ~PARENB;
-            break;
-        default:
-            break;
-    }
-    if (nStop == UART_STOP1) {
-        newttys1.c_cflag &= ~CSTOPB;
-    } else if (nStop == UART_STOP2) {
-        newttys1.c_cflag |= CSTOPB;
-    }
-    newttys1.c_cc[VTIME] = 0;
-    newttys1.c_cc[VMIN] = 0;
-    if (tcflush(fd, TCIOFLUSH)) {
-        WRITE_LOG(LOG_DEBUG, " tcflush error.");
-        return ERR_GENERIC;
-    }
-    if ((tcsetattr(fd, TCSANOW, &newttys1)) != 0) {
-        WRITE_LOG(LOG_DEBUG, "com set error errno = %d", errno);
-        return ERR_GENERIC;
-    }
-    WRITE_LOG(LOG_DEBUG, " SetSerial OK rate = %d", nSpeed);
-    return RET_SUCCESS;
-}
-#endif
-#endif // _WIN32
-
-ssize_t HdcUARTBase::ReadUartDev(std::vector<uint8_t> &readBuf, size_t expectedSize, HdcUART &uart)
-{
-    ssize_t totalBytesRead = 0;
-    uint8_t uartReadBuffer[MAX_UART_SIZE_IOBUF];
-#ifdef _WIN32
-    DWORD bytesRead = 0;
-#else
-    ssize_t bytesRead = 0;
-#endif
-    do {
-        bytesRead = 0;
-#ifdef _WIN32
-        BOOL bReadStatus = ReadFile(uart.devUartHandle, uartReadBuffer, sizeof(uartReadBuffer),
-                                    &bytesRead, &uart.ovRead);
-        if (!bReadStatus) {
-            if (GetLastError() == ERROR_IO_PENDING) {
-                bytesRead = 0;
-                DWORD dwMilliseconds = READ_GIVE_UP_TIME_OUT_TIME_MS;
-                if (expectedSize == 0) {
-                    dwMilliseconds = INFINITE;
-                }
-                if (!GetOverlappedResultEx(uart.devUartHandle, &uart.ovRead, &bytesRead,
-                                           dwMilliseconds, FALSE)) {
-                    // wait io failed
-                    DWORD error = GetLastError();
-                    if (error == ERROR_OPERATION_ABORTED) {
-                        totalBytesRead += bytesRead;
-                        WRITE_LOG(LOG_DEBUG, "%s error cancel read. %u %zd", __FUNCTION__,
-                                  bytesRead, totalBytesRead);
-                        // Generally speaking, this is the cacnel caused by freesession
-                        // Returning allows the outer read loop to run again. This checks the exit
-                        // condition.
-                        return totalBytesRead;
-                    } else if (error == WAIT_TIMEOUT) {
-                        totalBytesRead += bytesRead;
-                        WRITE_LOG(LOG_DEBUG, "%s error timeout. %u %zd", __FUNCTION__, bytesRead,
-                                  totalBytesRead);
-                        return totalBytesRead;
-                    } else {
-                        WRITE_LOG(LOG_DEBUG, "%s error wait io:%d.", __FUNCTION__, GetLastError());
-                    }
-                    return -1;
-                }
-            } else {
-                // not ERROR_IO_PENDING
-                WRITE_LOG(LOG_DEBUG, "%s  err:%d. ", __FUNCTION__, GetLastError());
-                return -1;
-            }
-        }
-#else
-        int ret = 0;
-        fd_set readFds;
-        FD_ZERO(&readFds);
-        FD_SET(uart.devUartHandle, &readFds);
-        const constexpr int msTous = 1000;
-        const constexpr int sTous = 1000 * msTous;
-        struct timeval tv;
-        tv.tv_sec = 0;
-
-        if (expectedSize == 0) {
-            tv.tv_usec = WAIT_RESPONSE_TIME_OUT_MS * msTous;
-            tv.tv_sec = tv.tv_usec / sTous;
-            tv.tv_usec = tv.tv_usec % sTous;
-            WRITE_LOG(LOG_DEBUG, "time  =  %d %d", tv.tv_sec, tv.tv_sec);
-#ifdef HDC_HOST
-            // only host side need this
-            // in this caes
-            // We need a way to exit from the select for the destruction and recovery of the
-            // serial port read thread.
-            ret = select(uart.devUartHandle + 1, &readFds, nullptr, nullptr, &tv);
-#else
-            ret = select(uart.devUartHandle + 1, &readFds, nullptr, nullptr, nullptr);
-#endif
-        } else {
-            // when we have expect size , we need timeout for link data drop issue
-            tv.tv_usec = READ_GIVE_UP_TIME_OUT_TIME_MS * msTous;
-            tv.tv_sec = tv.tv_usec / sTous;
-            tv.tv_usec = tv.tv_usec % sTous;
-            ret = select(uart.devUartHandle + 1, &readFds, nullptr, nullptr, &tv);
-        }
-        if (ret == 0 and expectedSize == 0) {
-            // no expect but timeout
-            if (uart.ioCancel) {
-                WRITE_LOG(LOG_DEBUG, "%s:uart select time out and io cancel", __FUNCTION__);
-                uart.ioCancel = true;
-                return totalBytesRead;
-            } else {
-                continue;
-            }
-        } else if (ret == 0) {
-            WRITE_LOG(LOG_DEBUG, "%s:uart select time out!", __FUNCTION__);
-            // we expected some byte , but not arrive before timeout
-            return totalBytesRead;
-        } else if (ret < 0) {
-            WRITE_LOG(LOG_DEBUG, "%s:uart select error! %d", __FUNCTION__, errno);
-            return -1; // wait failed.
-        } else {
-            // select > 0
-            bytesRead = read(uart.devUartHandle, uartReadBuffer, sizeof(uartReadBuffer));
-            if (bytesRead <= 0) {
-                // read failed !
-                WRITE_LOG(LOG_WARN, "%s:read failed! %zd:%d", __FUNCTION__, bytesRead, errno);
-                return -1;
-            }
-        }
-#endif
-        if (bytesRead > 0) {
-            readBuf.insert(readBuf.end(), uartReadBuffer, uartReadBuffer + bytesRead);
-            totalBytesRead += bytesRead;
-        }
-    } while (readBuf.size() < expectedSize or
-             bytesRead == 0); // if caller know how many bytes it want
-    return totalBytesRead;
-}
-
-ssize_t HdcUARTBase::WriteUartDev(uint8_t *data, const size_t length, HdcUART &uart)
-{
-    ssize_t totalBytesWrite = 0;
-    WRITE_LOG(LOG_ALL, "%s %d data %x %x", __FUNCTION__, length, *(data + sizeof(UartHead)),
-              *(data + sizeof(UartHead) + 1));
-    do {
-#ifdef _WIN32
-        DWORD bytesWrite = 0;
-        BOOL bWriteStat = WriteFile(uart.devUartHandle, data + totalBytesWrite,
-                                    length - totalBytesWrite, &bytesWrite, &uart.ovWrite);
-        if (!bWriteStat) {
-            if (GetLastError() == ERROR_IO_PENDING) {
-                if (!GetOverlappedResult(uart.devUartHandle, &uart.ovWrite, &bytesWrite, TRUE)) {
-                    WRITE_LOG(LOG_DEBUG, "%s error wait io:%d. bytesWrite %zu", __FUNCTION__,
-                              GetLastError(), bytesWrite);
-                    return -1;
-                }
-            } else {
-                WRITE_LOG(LOG_DEBUG, "%s err:%d. bytesWrite %zu", __FUNCTION__, GetLastError(),
-                          bytesWrite);
-                return -1;
-            }
-        }
-#else // not win32
-        ssize_t bytesWrite = 0;
-        bytesWrite = write(uart.devUartHandle, data + totalBytesWrite, length - totalBytesWrite);
-        if (bytesWrite < 0) {
-            if (errno == EINTR or errno == EAGAIN) {
-                WRITE_LOG(LOG_WARN, "EINTR/EAGAIN, try again");
-                continue;
-            } else {
-                // we don't know how to recory in this function
-                // need reopen device ?
-                constexpr int bufSize = 1024;
-                char buf[bufSize] = { 0 };
-                strerror_r(errno, buf, bufSize);
-                WRITE_LOG(LOG_FATAL, "write fatal errno %d:%s", errno, buf);
-                return -1;
-            }
-        } else {
-            // waits until all output written to the object referred to by fd has been transmitted.
-            tcdrain(uart.devUartHandle);
-        }
-#endif
-        totalBytesWrite += bytesWrite;
-    } while (totalBytesWrite < signed(length));
-
-    return totalBytesWrite;
-}
-
-int HdcUARTBase::UartToHdcProtocol(uv_stream_t *stream, uint8_t *data, int dataSize)
-{
-    HSession hSession = (HSession)stream->data;
-    unsigned int fd = hSession->dataFd[STREAM_MAIN];
-    fd_set fdSet;
-    struct timeval timeout = {3, 0};
-    FD_ZERO(&fdSet);
-    FD_SET(fd, &fdSet);
-    int index = 0;
-    int childRet = 0;
-
-    while (index < dataSize) {
-        childRet = select(fd + 1, NULL, &fdSet, NULL, &timeout);
-        if (childRet <= 0) {
-            constexpr int bufSize = 1024;
-            char buf[bufSize] = { 0 };
-#ifdef _WIN32
-            strerror_s(buf, bufSize, errno);
-#else
-            strerror_r(errno, buf, bufSize);
-#endif
-            WRITE_LOG(LOG_FATAL, "%s select error:%d [%s][%d]", __FUNCTION__, errno,
-                      buf, childRet);
-            break;
-        }
-        childRet = send(fd, (const char *)data + index, dataSize - index, 0);
-        if (childRet < 0) {
-            constexpr int bufSize = 1024;
-            char buf[bufSize] = { 0 };
-#ifdef _WIN32
-            strerror_s(buf, bufSize, errno);
-#else
-            strerror_r(errno, buf, bufSize);
-#endif
-            WRITE_LOG(LOG_FATAL, "%s senddata err:%d [%s]", __FUNCTION__, errno, buf);
-            break;
-        }
-        index += childRet;
-    }
-    if (index != dataSize) {
-        WRITE_LOG(LOG_FATAL, "%s partialsenddata err:%d [%d]", __FUNCTION__, index, dataSize);
-        return ERR_IO_FAIL;
-    }
-    return index;
-}
-
-RetErrCode HdcUARTBase::DispatchToWorkThread(HSession hSession, uint8_t *readBuf, int readBytes)
-{
-    if (hSession == nullptr) {
-        return ERR_SESSION_NOFOUND;
-    }
-    if (!UartSendToHdcStream(hSession, readBuf, readBytes)) {
-        return ERR_IO_FAIL;
-    }
-    return RET_SUCCESS;
-}
-
-size_t HdcUARTBase::PackageProcess(vector<uint8_t> &data, HSession hSession)
-{
-    while (data.size() >= sizeof(UartHead)) {
-        // is size more than one head
-        size_t packetSize = 0;
-        uint32_t sessionId = 0;
-        uint32_t packageIndex = 0;
-        // we erase all buffer. wait next read.
-        if (ValidateUartPacket(data, sessionId, packageIndex, packetSize) != RET_SUCCESS) {
-            WRITE_LOG(LOG_WARN, "%s package error. clean the read buffer.", __FUNCTION__);
-            data.clear();
-        } else if (packetSize == sizeof(UartHead)) {
-            // nothing need to send, this is a head only package
-            // only used in link layer
-            WRITE_LOG(LOG_ALL, "%s headonly Package(%zu). dont send to session, erase it",
-                      __FUNCTION__, packetSize);
-        } else {
-            // at least we got one package
-            // if the size of package have all received ?
-            if (data.size() >= packetSize) {
-                // send the data to logic level (link to logic)
-                if (hSession == nullptr) {
-#ifdef HDC_HOST
-                    hSession = GetSession(sessionId);
-#else
-                    // for daemon side we can make a new session for it
-                    hSession = GetSession(sessionId, true);
-#endif
-                }
-                if (hSession == nullptr) {
-                    WRITE_LOG(LOG_WARN, "%s have not found session (%u). skip it", __FUNCTION__, sessionId);
-                } else {
-                    if (hSession->hUART->dispatchedPackageIndex == packageIndex) {
-                        // we need check if the duplication package we have already send
-                        WRITE_LOG(LOG_WARN, "%s dup package %u, skip send to session logic",
-                                  __FUNCTION__, packageIndex);
-                    } else {
-                        // update the last package we will send to hdc
-                        hSession->hUART->dispatchedPackageIndex = packageIndex;
-                        RetErrCode ret = DispatchToWorkThread(hSession, data.data(), packetSize);
-                        if (ret == RET_SUCCESS) {
-                            WRITE_LOG(LOG_DEBUG, "%s DispatchToWorkThread successful",
-                                      __FUNCTION__);
-                        } else {
-                            // send to logic failed.
-                            // this kind of issue unable handle in link layer
-                            WRITE_LOG(LOG_FATAL,
-                                      "%s DispatchToWorkThread fail %d. request free session in "
-                                      "other side",
-                                      __FUNCTION__, ret);
-                            ResponseUartTrans(hSession->sessionId, ++hSession->hUART->packageIndex,
-                                              PKG_OPTION_FREE);
-                        }
-                    }
-                }
-            } else {
-                WRITE_LOG(LOG_DEBUG, "%s valid package, however size not enough. expect %zu",
-                          __FUNCTION__, packetSize);
-                return packetSize;
-            }
-        }
-
-        if (data.size() >= packetSize) {
-            data.erase(data.begin(), data.begin() + packetSize);
-        } else {
-            // dont clean , should merge with next package
-        }
-        WRITE_LOG(LOG_DEBUG, "PackageProcess data.size():%d left", data.size());
-    }
-    // if we have at least one byte, we think there should be a head
-    return data.size() > 1 ? sizeof(UartHead) : 0;
-}
-
-bool HdcUARTBase::SendUARTRaw(HSession hSession, uint8_t *data, const size_t length)
-{
-    struct UartHead *uartHeader = (struct UartHead *)data;
-#ifndef HDC_HOST
-    // review nobody can plug out the daemon uart , if we still need split write in daemon side?
-    HdcUART deamonUart;
-    deamonUart.devUartHandle = uartHandle;
-    if (uartHeader->IsResponsePackage()) {
-        // for the response package and in daemon side,
-        // we dont need session info
-        ssize_t sendBytes = WriteUartDev(data, length, deamonUart);
-        return sendBytes > 0;
-    }
-#endif
-
-    // for normal package
-    if (hSession == nullptr) {
-        hSession = GetSession(uartHeader->sessionId);
-        if (hSession == nullptr) {
-            // session is not found
-            WRITE_LOG(LOG_WARN, "%s hSession not found:%zu", __FUNCTION__, uartHeader->sessionId);
-            return false;
-        }
-    }
-    hSession->ref++;
-    WRITE_LOG(LOG_DEBUG, "%s length:%d", __FUNCTION__, length);
-#ifdef HDC_HOST
-    ssize_t sendBytes = WriteUartDev(data, length, *hSession->hUART);
-#else
-    ssize_t sendBytes = WriteUartDev(data, length, deamonUart);
-#endif
-    WRITE_LOG(LOG_DEBUG, "%s sendBytes %zu", __FUNCTION__, sendBytes);
-    if (sendBytes < 0) {
-        WRITE_LOG(LOG_DEBUG, "%s send fail. try to freesession", __FUNCTION__);
-        OnTransferError(hSession);
-    }
-    hSession->ref--;
-    return sendBytes > 0;
-}
-
-// this function will not check the data correct again
-// just send the data to hdc session side
-bool HdcUARTBase::UartSendToHdcStream(HSession hSession, uint8_t *data, size_t size)
-{
-    WRITE_LOG(LOG_DEBUG, "%s send to session %s package size %zu", __FUNCTION__,
-              hSession->ToDebugString().c_str(), size);
-
-    int ret = RET_SUCCESS;
-
-    if (size < sizeof(UartHead)) {
-        WRITE_LOG(LOG_FATAL, "%s buf size too small %zu", __FUNCTION__, size);
-        return ERR_BUF_SIZE;
-    }
-
-    UartHead *head = reinterpret_cast<UartHead *>(data);
-    WRITE_LOG(LOG_DEBUG, "%s uartHeader:%s data: %x %x", __FUNCTION__,
-              head->ToDebugString().c_str(), *(data + sizeof(UartHead)),
-              *(data + sizeof(UartHead) + 1));
-
-    // review need check logic again here or err process
-    if (head->sessionId != hSession->sessionId) {
-        if (hSession->serverOrDaemon && !hSession->hUART->resetIO) {
-            WRITE_LOG(LOG_FATAL, "%s sessionId not matched, reset sessionId:%d.", __FUNCTION__,
-                      head->sessionId);
-            SendUartSoftReset(hSession, head->sessionId);
-            hSession->hUART->resetIO = true;
-            ret = ERR_IO_SOFT_RESET;
-            // dont break ,we need rease these data in recv buffer
-        }
-    } else {
-        //  data to session
-        hSession->hUART->streamSize += head->dataSize; // this is only for debug,
-        WRITE_LOG(LOG_ALL, "%s stream wait session read size: %zu", __FUNCTION__,
-                  hSession->hUART->streamSize.load());
-        if (UartToHdcProtocol(reinterpret_cast<uv_stream_t *>(&hSession->dataPipe[STREAM_MAIN]),
-                              data + sizeof(UartHead), head->dataSize) < 0) {
-            ret = ERR_IO_FAIL;
-            WRITE_LOG(LOG_FATAL, "%s Error uart send to stream", __FUNCTION__);
-        }
-    }
-
-    return ret == RET_SUCCESS;
-}
-
-void HdcUARTBase::NotifyTransfer()
-{
-    WRITE_LOG(LOG_DEBUG, "%s", __FUNCTION__);
-    transfer.Request();
-}
-
-/*
-here we have a HandleOutputPkg vector
-It is used to maintain the data reliability of the link layer
-It consists of the following part
-Log data to send (caller thread)                        --> RequestSendPackage
-Send recorded data (loop sending thread)                --> SendPkgInUARTOutMap
-Process the returned reply data (loop reading thread)   --> ProcessResponsePackage
-Send reply packet (loop reading thread)                 --> ResponseUartTrans
-
-The key scenarios are as follows:
-Package is sent from side A to side B
-Here we call the complete data package
-package is divided into head and data
-The response information is in the header.
-data contains binary data.
-
-case 1: Normal Process
-    package
-A   -->   B
-    ACK
-A   <--   B
-
-case 2: packet is incorrect
-At least one header must be received
-For this the B side needs to have an accept timeout.
-There is no new data within a certain period of time as the end of the packet.
-(This mechanism is not handled in HandleOutputPkg retransmission)
-
-    incorrect
-A   -->   B
-B sends NAK and A resends the packet.
-    NAK
-A   <--   B
-    package resend
-A   -->   B
-
-case 3: packet is complete lost()
-    package(complete lost)
-A   -x->   B
-The A side needs to resend the Package after a certain timeout
-A   -->   B
-Until the B side has a data report (ACK or NAK), or the number of retransmissions reaches the upper
-limit.
-*/
-void HdcUARTBase::RequestSendPackage(uint8_t *data, const size_t length, bool queue)
-{
-    UartHead *head = reinterpret_cast<UartHead *>(data);
-    bool response = head->IsResponsePackage();
-
-    if (queue) {
-        slots.Wait(head->sessionId);
-    }
-
-    std::lock_guard<std::recursive_mutex> lock(mapOutPkgsMutex);
-
-    std::string pkgId = head->ToPkgIdentityString(response);
-    auto it = std::find_if(outPkgs.begin(), outPkgs.end(), HandleOutputPkgKeyFinder(pkgId));
-    if (it == outPkgs.end()) {
-        // update che checksum , both head and data
-        head->UpdateCheckSum();
-        outPkgs.emplace_back(pkgId, head->sessionId, data, length, response,
-                             head->option & PKG_OPTION_ACK);
-        WRITE_LOG(LOG_DEBUG, "UartPackageManager: add pkg %s (pkgs size %zu)",
-                  head->ToDebugString().c_str(), outPkgs.size());
-    } else {
-        WRITE_LOG(LOG_FATAL, "UartPackageManager: add pkg %s fail, %s has already been exist.",
-                  head->ToDebugString().c_str(), pkgId.c_str());
-    }
-    NotifyTransfer();
-}
-
-void HdcUARTBase::ProcessResponsePackage(const UartHead &head)
-{
-    std::lock_guard<std::recursive_mutex> lock(mapOutPkgsMutex);
-    bool ack = head.option & PKG_OPTION_ACK;
-    // response package
-    std::string pkgId = head.ToPkgIdentityString();
-    WRITE_LOG(LOG_ALL, "UartPackageManager: got response pkgId:%s ack:%d.", pkgId.c_str(), ack);
-
-    auto it = std::find_if(outPkgs.begin(), outPkgs.end(), HandleOutputPkgKeyFinder(pkgId));
-    if (it != outPkgs.end()) {
-        if (ack) { // response ACK.
-            slots.Free(it->sessionId);
-            outPkgs.erase(it);
-            WRITE_LOG(LOG_DEBUG, "UartPackageManager: erase pkgId:%s.", pkgId.c_str());
-        } else {                           // response NAK
-            it->pkgStatus = PKG_WAIT_SEND; // Re send the pkg
-            WRITE_LOG(LOG_WARN, "UartPackageManager: resend pkgId:%s.", pkgId.c_str());
-        }
-    } else {
-        WRITE_LOG(LOG_FATAL, "UartPackageManager: hasn't found pkg for pkgId:%s.", pkgId.c_str());
-        for (auto pkg : outPkgs) {
-            WRITE_LOG(LOG_ALL, "UartPackageManager:  pkgId:%s.", pkg.key.c_str());
-        }
-    }
-    NotifyTransfer();
-    return;
-}
-
-void HdcUARTBase::SendPkgInUARTOutMap()
-{
-    std::lock_guard<std::recursive_mutex> lock(mapOutPkgsMutex);
-    if (outPkgs.empty()) {
-        WRITE_LOG(LOG_ALL, "UartPackageManager: No pkgs needs to be sent.");
-        return;
-    }
-    WRITE_LOG(LOG_DEBUG, "UartPackageManager: send pkgs, have:%zu pkgs", outPkgs.size());
-    // we have maybe more than one session
-    // each session has it owner serial port
-    std::unordered_set<uint32_t> hasWaitPkg;
-    auto it = outPkgs.begin();
-    while (it != outPkgs.end()) {
-        if (it->pkgStatus == PKG_WAIT_SEND) {
-            // we found a pkg wait for send
-            // if a response package
-            // response package always send nowait noorder
-            if (!it->response and hasWaitPkg.find(it->sessionId) != hasWaitPkg.end()) {
-                // this is not a response package
-                // and this session is wait response
-                // so we can send nothing
-                // process next
-                it++;
-                continue;
-            }
-            // we will ready to send the package
-            WRITE_LOG(LOG_DEBUG, "UartPackageManager: send pkg %s", it->ToDebugString().c_str());
-            if (!SendUARTRaw(nullptr, it->msgSendBuf.data(), it->msgSendBuf.size())) {
-                WRITE_LOG(LOG_WARN, "SendUARTRaw failed!");
-                break;
-            }
-            if (it->response) {
-                // response pkg dont need wait response again.
-                WRITE_LOG(LOG_DEBUG, "UartPackageManager: erase pkg %s",
-                          it->ToDebugString().c_str());
-                it = outPkgs.erase(it);
-                continue;
-            } else {
-                // normal send package
-                it->pkgStatus = PKG_WAIT_RESPONSE;
-                it->sendTimePoint = steady_clock::now();
-                hasWaitPkg.emplace(it->sessionId);
-                transfer.Sent(); // something is sendout, transfer will timeout for next wait.
-            }
-        } else if (it->pkgStatus == PKG_WAIT_RESPONSE) {
-            // we found a pkg wait for response
-            auto elapsedTime = duration_cast<milliseconds>(steady_clock::now() - it->sendTimePoint);
-            WRITE_LOG(LOG_DEBUG, "UartPackageManager: pkg:%s is wait ACK. elapsedTime %lld",
-                      it->ToDebugString().c_str(), (long long)elapsedTime.count());
-            if (elapsedTime.count() >= WAIT_RESPONSE_TIME_OUT_MS) {
-                // check the response timeout
-                if (it->retryChance > 0) {
-                    // if it send timeout, resend it again.
-                    WRITE_LOG(LOG_WARN, "UartPackageManager: pkg:%s try resend it.",
-                              it->ToDebugString().c_str());
-                    it->pkgStatus = PKG_WAIT_SEND;
-                    it->retryChance--;
-                    NotifyTransfer(); // make transfer reschedule
-                    break;            // dont process anything now.
-                } else {
-                    // the response it timeout and retry counx is 0
-                    // the link maybe not stable
-                    // let's free this session
-                    WRITE_LOG(LOG_WARN, "UartPackageManager: reach max retry ,free the session %u",
-                              it->sessionId);
-                    OnTransferError(GetSession(it->sessionId));
-                    // dont reschedule here
-                    // wait next schedule from this path
-                    // OnTransferError -> FreeSession -> ClearUARTOutMap -> NotifyTransfer
-                    break;
-                }
-            }
-            hasWaitPkg.emplace(it->sessionId);
-        }
-        it++; // next package
-    }
-    WRITE_LOG(LOG_DEBUG, "UartPackageManager: send finish, have %zu pkgs", outPkgs.size());
-}
-
-void HdcUARTBase::ClearUARTOutMap(uint32_t sessionId)
-{
-    WRITE_LOG(LOG_DEBUG, "%s UartPackageManager clean for sessionId %u", __FUNCTION__, sessionId);
-    size_t erased = 0;
-    std::lock_guard<std::recursive_mutex> lock(mapOutPkgsMutex);
-    auto it = outPkgs.begin();
-    while (it != outPkgs.end()) {
-        if (it->sessionId == sessionId) {
-            if (!it->response) {
-                slots.Free(it->sessionId);
-            }
-            it = outPkgs.erase(it);
-            erased++;
-        } else {
-            it++;
-        }
-    }
-    WRITE_LOG(LOG_DEBUG, "%s erased %zu", __FUNCTION__, erased);
-
-    NotifyTransfer(); // tell transfer we maybe have some change
-}
-
-void HdcUARTBase::EnsureAllPkgsSent()
-{
-    WRITE_LOG(LOG_DEBUG, "%s", __FUNCTION__);
-    slots.WaitFree();
-    if (!outPkgs.empty()) {
-        std::this_thread::sleep_for(1000ms);
-    }
-    WRITE_LOG(LOG_DEBUG, "%s done.", __FUNCTION__);
-}
-
-RetErrCode HdcUARTBase::ValidateUartPacket(vector<uint8_t> &data, uint32_t &sessionId,
-                                           uint32_t &packageIndex, size_t &packetSize)
-{
-    constexpr auto maxBufFactor = 1;
-    struct UartHead *head = (struct UartHead *)data.data();
-    WRITE_LOG(LOG_DEBUG, "%s %s", __FUNCTION__, head->ToDebugString().c_str());
-
-    if (memcmp(head->flag, PACKET_FLAG.c_str(), PACKET_FLAG.size()) != 0) {
-        WRITE_LOG(LOG_FATAL, "%s,PACKET_FLAG not correct %x %x", __FUNCTION__, head->flag[0],
-                  head->flag[1]);
-        return ERR_BUF_CHECK;
-    }
-
-    if (!head->ValidateHead()) {
-        WRITE_LOG(LOG_FATAL, "%s head checksum not correct", __FUNCTION__);
-        return ERR_BUF_CHECK;
-    }
-    // after validate , id and fullPackageLength is correct
-    sessionId = head->sessionId;
-    packetSize = head->dataSize + sizeof(UartHead);
-    packageIndex = head->packageIndex;
-
-    if ((head->dataSize + sizeof(UartHead)) > MAX_UART_SIZE_IOBUF * maxBufFactor) {
-        WRITE_LOG(LOG_FATAL, "%s dataSize too larger:%d", __FUNCTION__, head->dataSize);
-        return ERR_BUF_OVERFLOW;
-    }
-
-    if ((head->option & PKG_OPTION_RESET)) {
-        // The Host end program is restarted, but the UART cable is still connected
-        WRITE_LOG(LOG_WARN, "%s host side want restart daemon, restart old sessionId:%u",
-                  __FUNCTION__, head->sessionId);
-        ResetOldSession(head->sessionId);
-        return ERR_IO_SOFT_RESET;
-    }
-
-    if ((head->option & PKG_OPTION_FREE)) {
-        // other side tell us the session need reset
-        // we should free it
-        WRITE_LOG(LOG_WARN, "%s other side tell us the session need free:%u", __FUNCTION__,
-                  head->sessionId);
-        Restartession(GetSession(head->sessionId));
-    }
-
-    // check data
-    if (data.size() >= packetSize) {
-        // if we have full package now ?
-        if (!head->ValidateData()) {
-            WRITE_LOG(LOG_FATAL, "%s data checksum not correct", __FUNCTION__);
-            return ERR_BUF_CHECK;
-        }
-        if (head->IsResponsePackage()) {
-            // response package
-            ProcessResponsePackage(*head);
-        } else {
-            // link layer response for no response package
-            ResponseUartTrans(head->sessionId, head->packageIndex, PKG_OPTION_ACK);
-        }
-    }
-
-    return RET_SUCCESS;
-}
-
-void HdcUARTBase::ResponseUartTrans(uint32_t sessionId, uint32_t packageIndex,
-                                    UartProtocolOption option)
-{
-    UartHead uartHeader(sessionId, option, 0, packageIndex);
-    WRITE_LOG(LOG_DEBUG, "%s option:%u", __FUNCTION__, option);
-    RequestSendPackage(reinterpret_cast<uint8_t *>(&uartHeader), sizeof(UartHead), false);
-}
-
-int HdcUARTBase::SendUARTData(HSession hSession, uint8_t *data, const size_t length)
-{
-    constexpr int maxIOSize = MAX_UART_SIZE_IOBUF;
-    WRITE_LOG(LOG_DEBUG, "SendUARTData hSession:%u, total length:%d", hSession->sessionId, length);
-    const int packageDataMaxSize = maxIOSize - sizeof(UartHead);
-    size_t offset = 0;
-    uint8_t sendDataBuf[MAX_UART_SIZE_IOBUF];
-
-    WRITE_LOG(LOG_ALL, "SendUARTData data length :%d", length);
-
-    do {
-        UartHead *head = (UartHead *)sendDataBuf;
-        if (memset_s(head, sizeof(UartHead), 0, sizeof(UartHead)) != EOK) {
-            return ERR_BUF_RESET;
-        }
-        if (memcpy_s(head->flag, sizeof(head->flag), PACKET_FLAG.c_str(), PACKET_FLAG.size()) !=
-            EOK) {
-            return ERR_BUF_COPY;
-        }
-        head->sessionId = hSession->sessionId;
-        head->packageIndex = ++hSession->hUART->packageIndex;
-
-        int RemainingDataSize = length - offset;
-        if (RemainingDataSize > packageDataMaxSize) {
-            // more than one package max data size
-            head->dataSize = static_cast<uint16_t>(packageDataMaxSize);
-        } else {
-            // less then the max size
-            head->dataSize = static_cast<uint16_t>(RemainingDataSize);
-            // this is the last package . all the data will send after this time
-            head->option = head->option | PKG_OPTION_TAIL;
-        }
-#ifdef UART_FULL_LOG
-        WRITE_LOG(LOG_FULL, "offset %d length %d", offset, length);
-#endif
-        uint8_t *payload = sendDataBuf + sizeof(UartHead);
-        if (EOK !=
-            memcpy_s(payload, packageDataMaxSize, (uint8_t *)data + offset, head->dataSize)) {
-            WRITE_LOG(LOG_FATAL, "memcpy_s failed max %zu , need %zu",
-                      packageDataMaxSize, head->dataSize);
-            return ERR_BUF_COPY;
-        }
-        offset += head->dataSize;
-        int packageFullSize = sizeof(UartHead) + head->dataSize;
-        WRITE_LOG(LOG_ALL, "SendUARTData =============> %s", head->ToDebugString().c_str());
-        RequestSendPackage(sendDataBuf, packageFullSize);
-    } while (offset != length);
-
-    return offset;
-}
-
-void HdcUARTBase::ReadDataFromUARTStream(uv_stream_t *stream, ssize_t nread, const uv_buf_t *buf)
-{
-    HSession hSession = (HSession)stream->data;
-    HdcUARTBase *hUARTBase = (HdcUARTBase *)hSession->classModule;
-    std::lock_guard<std::mutex> lock(hUARTBase->workThreadProcessingData);
-
-    constexpr int bufSize = 1024;
-    char buffer[bufSize] = { 0 };
-    if (nread < 0) {
-        uv_err_name_r(nread, buffer, bufSize);
-    }
-    WRITE_LOG(LOG_DEBUG, "%s sessionId:%u, nread:%zd %s streamSize %zu", __FUNCTION__,
-              hSession->sessionId, nread, buffer,
-              hSession->hUART->streamSize.load());
-    HdcSessionBase *hSessionBase = (HdcSessionBase *)hSession->classInstance;
-    if (nread <= 0 or nread > signed(hSession->hUART->streamSize)) {
-        WRITE_LOG(LOG_FATAL, "%s nothing need to do ! because no data here", __FUNCTION__);
-        return;
-    }
-    if (hSessionBase->FetchIOBuf(hSession, hSession->ioBuf, nread) < 0) {
-        WRITE_LOG(LOG_FATAL, "%s FetchIOBuf failed , free the other side session", __FUNCTION__);
-        // session side said the dont understand this session data
-        // so we also need tell other side to free it session.
-        hUARTBase->ResponseUartTrans(hSession->sessionId, ++hSession->hUART->packageIndex,
-                                     PKG_OPTION_FREE);
-
-        WRITE_LOG(LOG_FATAL, "%s FetchIOBuf failed , free the session", __FUNCTION__);
-        hSessionBase->FreeSession(hSession->sessionId);
-    }
-    hSession->hUART->streamSize -= nread;
-    WRITE_LOG(LOG_DEBUG, "%s sessionId:%u, nread:%d", __FUNCTION__, hSession->sessionId, nread);
-}
-
-bool HdcUARTBase::ReadyForWorkThread(HSession hSession)
-{
-    if (externInterface.UvTcpInit(&hSession->childLoop, &hSession->dataPipe[STREAM_WORK],
-                                  hSession->dataFd[STREAM_WORK])) {
-        WRITE_LOG(LOG_FATAL, "%s init child TCP failed", __FUNCTION__);
-        return false;
-    }
-    hSession->dataPipe[STREAM_WORK].data = hSession;
-    HdcSessionBase *pSession = (HdcSessionBase *)hSession->classInstance;
-    externInterface.SetTcpOptions(&hSession->dataPipe[STREAM_WORK]);
-    if (externInterface.UvRead((uv_stream_t *)&hSession->dataPipe[STREAM_WORK],
-                               pSession->AllocCallback, &HdcUARTBase::ReadDataFromUARTStream)) {
-        WRITE_LOG(LOG_FATAL, "%s child TCP read failed", __FUNCTION__);
-        return false;
-    }
-    WRITE_LOG(LOG_DEBUG, "%s finish", __FUNCTION__);
-    return true;
-}
-
-void HdcUARTBase::Restartession(const HSession session)
-{
-    if (session != nullptr) {
-        WRITE_LOG(LOG_FATAL, "%s:%s", __FUNCTION__, session->ToDebugString().c_str());
-        ClearUARTOutMap(session->sessionId);
-        sessionBase.FreeSession(session->sessionId);
-    }
-}
-
-void HdcUARTBase::StopSession(HSession hSession)
-{
-    if (hSession != nullptr) {
-        WRITE_LOG(LOG_WARN, "%s:%s", __FUNCTION__, hSession->ToDebugString().c_str());
-        ClearUARTOutMap(hSession->sessionId);
-    } else {
-        WRITE_LOG(LOG_FATAL, "%s: clean null session", __FUNCTION__);
-    }
-}
-
-void HdcUARTBase::TransferStateMachine::Wait()
-{
-    std::unique_lock<std::mutex> lock(mutex);
-    WRITE_LOG(LOG_ALL, "%s", __FUNCTION__);
-    if (timeout) {
-        auto waitTimeout = std::chrono::duration_cast<std::chrono::milliseconds>(
-            timeoutPoint - std::chrono::steady_clock::now());
-        WRITE_LOG(LOG_ALL, "wait timeout %lld", waitTimeout.count());
-        if (cv.wait_for(lock, waitTimeout, [=] { return requested; }) == false) {
-            // must wait one timeout
-            // because sometime maybe not timeout but we got a request first.
-            timeout = false;
-            WRITE_LOG(LOG_ALL, "timeout");
-        }
-    } else {
-        cv.wait(lock, [=] { return requested; });
-    }
-    requested = false;
-}
-
-HdcUART::HdcUART()
-{
-#ifdef _WIN32
-    Base::ZeroStruct(ovWrite);
-    ovWrite.hEvent = CreateEvent(NULL, false, false, NULL);
-    Base::ZeroStruct(ovRead);
-    ovRead.hEvent = CreateEvent(NULL, false, false, NULL);
-#endif
-}
-
-HdcUART::~HdcUART()
-{
-#ifdef _WIN32
-    CloseHandle(ovWrite.hEvent);
-    ovWrite.hEvent = NULL;
-    CloseHandle(ovRead.hEvent);
-    ovRead.hEvent = NULL;
-#endif
-}
-} // namespace Hdc
-#endif // HDC_SUPPORT_UART
\ No newline at end of file
diff --git a/hdc/src/common/uart.h b/hdc/src/common/uart.h
deleted file mode 100644
index f50c942..0000000
--- a/hdc/src/common/uart.h
+++ /dev/null
@@ -1,365 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_UART_H
-#define HDC_UART_H
-#include "common.h"
-
-#include <chrono>
-#include <numeric>
-#include <sstream>
-#include <unordered_set>
-
-#ifndef _WIN32
-#include <termios.h> // struct termios
-#endif               // _WIN32
-
-namespace Hdc {
-#define USE_UART_CHECKSUM // all the data and head will have a checksum
-#undef HDC_UART_TIMER_LOG // will have a lot of log from timer
-
-enum UartProtocolOption {
-    PKG_OPTION_TAIL = 1,  // makr is the last packget, can be send to session.
-    PKG_OPTION_RESET = 2, // host request reset session in daemon
-    PKG_OPTION_ACK = 4,   // response the pkg is received
-    PKG_OPTION_NAK = 8,   // request resend pkg again
-    PKG_OPTION_FREE = 16, // request free this session, some unable recovery error happened
-};
-
-static_assert(MAX_UART_SIZE_IOBUF != 0);
-
-#pragma pack(push)
-#pragma pack(1)
-struct UartHead {
-    UartHead(const UartHead &) = delete;
-    UartHead &operator=(const UartHead &) = delete;
-    UartHead(UartHead &&) = default;
-
-    uint8_t flag[2];           // magic word
-    uint16_t option;           // UartProtocolOption
-    uint32_t sessionId;        // the package owner (COM dev owner)
-    uint32_t dataSize;         // data size not include head
-    uint32_t packageIndex;     // package index in this session
-    uint32_t dataCheckSum = 0; // data checksum
-    uint32_t headCheckSum = 0; // head checksum
-    std::string ToPkgIdentityString(bool responsePackage = false) const
-    {
-        std::ostringstream oss;
-        if (responsePackage) {
-            oss << "R-";
-        }
-        oss << "Id:" << sessionId;
-        oss << "pkgIdx:" << packageIndex;
-        return oss.str();
-    };
-    std::string ToDebugString() const
-    {
-        std::ostringstream oss;
-        oss << "UartHead [";
-        oss << " flag:" << std::hex << unsigned(flag[0]) << " " << unsigned(flag[1]) << std::dec;
-        oss << " option:" << unsigned(option);
-        oss << " sessionId:" << sessionId;
-        oss << " dataSize:" << dataSize;
-        oss << " packageIndex:" << packageIndex;
-        if (dataSize != 0) {
-            oss << " dataCheckSum:" << std::hex << dataCheckSum;
-        }
-        oss << " headCheckSum:" << std::hex << headCheckSum;
-        oss << std::dec;
-        oss << "]";
-        return oss.str();
-    };
-    UartHead(uint32_t sessionIdIn = 0, uint8_t optionIn = 0, uint32_t dataSizeIn = 0,
-             uint32_t packageIndexIn = 0)
-        : flag {PACKET_FLAG[0], PACKET_FLAG[1]},
-          option(optionIn),
-          sessionId(sessionIdIn),
-          dataSize(dataSizeIn),
-          packageIndex(packageIndexIn)
-    {
-    }
-    bool operator==(const UartHead &r) const
-    {
-        return flag[0] == r.flag[0] and flag[1] == r.flag[1] and option == r.option and
-               dataSize == r.dataSize and packageIndex == r.packageIndex;
-    }
-    bool IsResponsePackage() const
-    {
-        return (option & PKG_OPTION_ACK) or (option & PKG_OPTION_NAK);
-    }
-    void UpdateCheckSum()
-    {
-#ifdef USE_UART_CHECKSUM
-        if (dataSize != 0) {
-            const uint8_t *data = reinterpret_cast<const uint8_t *>(this) + sizeof(UartHead);
-            dataCheckSum = std::accumulate(data, data + dataSize, 0u);
-        }
-        const uint8_t *head = reinterpret_cast<const uint8_t *>(this);
-        size_t headCheckSumLen = sizeof(UartHead) - sizeof(headCheckSum);
-        headCheckSum = std::accumulate(head, head + headCheckSumLen, 0u);
-#endif
-    }
-    bool ValidateHead() const
-    {
-#ifdef USE_UART_CHECKSUM
-        const uint8_t *head = reinterpret_cast<const uint8_t *>(this);
-        size_t headCheckSumLen = sizeof(UartHead) - sizeof(headCheckSum);
-        return (headCheckSum == std::accumulate(head, head + headCheckSumLen, 0u));
-#else
-        return true;
-#endif
-    }
-    bool ValidateData() const
-    {
-#ifdef USE_UART_CHECKSUM
-        const uint8_t *data = reinterpret_cast<const uint8_t *>(this) + sizeof(UartHead);
-        if (dataSize == 0) {
-            return true;
-        } else {
-            return (dataCheckSum == std::accumulate(data, data + dataSize, 0u));
-        }
-#else
-        return true;
-#endif
-    }
-};
-#pragma pack(pop)
-
-// we need virtual interface for UT the free function
-class ExternInterface {
-public:
-    virtual void SetTcpOptions(uv_tcp_t *tcpHandle);
-    virtual int SendToStream(uv_stream_t *handleStream, const uint8_t *buf, const int bufLen);
-    virtual int SendToPollFd(int fd, const uint8_t *buf, const int len);
-    virtual int UvTcpInit(uv_loop_t *, uv_tcp_t *, int);
-    virtual int UvRead(uv_stream_t *, uv_alloc_cb, uv_read_cb);
-    virtual int StartWorkThread(uv_loop_t *loop, uv_work_cb pFuncWorkThread,
-                                uv_after_work_cb pFuncAfterThread, void *pThreadData);
-    virtual void TryCloseHandle(const uv_handle_t *handle, uv_close_cb closeCallBack = nullptr);
-    virtual bool TimerUvTask(uv_loop_t *loop, void *data, uv_timer_cb cb);
-    virtual bool UvTimerStart(uv_timer_t *handle, uv_timer_cb cb, uint64_t timeout,
-                              uint64_t repeat);
-    using DelayCB = std::function<void(const uint8_t, string &, const void *)>;
-    virtual bool DelayDo(uv_loop_t *loop, const int delayMs, const uint8_t flag, string msg,
-                         void *data, DelayCB cb);
-    virtual ~ExternInterface() = default;
-};
-class HdcSessionBase;
-class HdcUARTBase {
-public:
-    static ExternInterface defaultInterface;
-    HdcUARTBase(HdcSessionBase&, ExternInterface& = defaultInterface);
-    virtual ~HdcUARTBase();
-    bool ReadyForWorkThread(HSession hSession);
-    int SendUARTData(HSession hSession, uint8_t *data, const size_t length);
-    // call from session side
-    // we need know when we need clear the pending send data
-    virtual void StopSession(HSession hSession);
-
-protected:
-    static constexpr uint32_t DEFAULT_BAUD_RATE_VALUE = 1500000;
-
-    bool stopped = false; // stop only can be call one times
-
-    // something is processing on working thread
-    // Mainly used to reply a data back before stop.
-    std::mutex workThreadProcessingData;
-
-    // review how about make a HUART in daemon side and put the devhandle in it ?
-    int uartHandle = -1;
-    virtual bool SendUARTRaw(HSession hSession, uint8_t *data, const size_t length);
-    virtual void SendUartSoftReset(HSession hUART, uint32_t sessionId) {};
-    virtual RetErrCode ValidateUartPacket(vector<uint8_t> &data, uint32_t &sessionId,
-                                          uint32_t &packageIndex, size_t &fullPackageLength);
-    virtual void NotifyTransfer();
-    virtual void ResetOldSession(uint32_t sessionId)
-    {
-        return;
-    }
-    virtual void Restartession(const HSession session);
-
-#ifndef _WIN32
-    int SetSerial(int fd, int nSpeed, int nBits, char nEvent, int nStop);
-#endif // _WIN32
-    virtual bool UartSendToHdcStream(HSession hSession, uint8_t *data, size_t size);
-    static void ReadDataFromUARTStream(uv_stream_t *stream, ssize_t nread, const uv_buf_t *buf);
-    bool uartOpened;
-
-    static constexpr size_t MAX_READ_BUFFER = MAX_UART_SIZE_IOBUF * 10;
-    static constexpr int READ_GIVE_UP_TIME_OUT_TIME_MS = 500; // 500ms
-    virtual int UartToHdcProtocol(uv_stream_t *stream, uint8_t *appendData, int dataSize);
-    int GetUartSpeed(int speed);
-    int GetUartBits(int bits);
-    virtual void ResponseUartTrans(uint32_t sessionId, uint32_t packageIndex,
-                                   UartProtocolOption option);
-
-    virtual size_t PackageProcess(vector<uint8_t> &data, HSession hSession = nullptr);
-    virtual RetErrCode DispatchToWorkThread(HSession hSession, uint8_t *readBuf, int readBytes);
-
-    virtual void OnTransferError(const HSession session) = 0;
-    virtual HSession GetSession(const uint32_t sessionId, bool create = false) = 0;
-
-    /*
-        read data from uart devices
-        Args:
-        readBuf         data will append to readBuf
-        expectedSize    function will not return until expected size read
-
-        Return:
-        ssize_t         >   0 how many bytes read after this function called
-                        ==  0 nothing read , timeout happened(expectedSize > 0)
-                        <   0 means devices error
-    */
-
-    // we have some oswait in huart(bind to each session/uart device)
-    virtual ssize_t ReadUartDev(std::vector<uint8_t> &readBuf, size_t expectedSize, HdcUART &uart);
-
-    virtual ssize_t WriteUartDev(uint8_t *data, const size_t length, HdcUART &uart);
-
-    ExternInterface &externInterface;
-
-    virtual void RequestSendPackage(uint8_t *data, const size_t length, bool queue = true);
-    virtual void ProcessResponsePackage(const UartHead &head);
-    virtual void SendPkgInUARTOutMap();
-    virtual void ClearUARTOutMap(uint32_t sessionId);
-    virtual void EnsureAllPkgsSent();
-    static constexpr int WAIT_RESPONSE_TIME_OUT_MS = 1000; // 1000ms
-    static constexpr int OneMoreMs = 1;
-
-    class TransferStateMachine {
-    public:
-        void Request()
-        {
-            std::unique_lock<std::mutex> lock(mutex);
-            requested = true;
-            cv.notify_one();
-        }
-
-        void Sent()
-        {
-            std::unique_lock<std::mutex> lock(mutex);
-            timeout = true;
-            // wait_for will timeout in 999ms in linux platform, so we add one more
-            timeoutPoint = std::chrono::steady_clock::now() +
-                           std::chrono::milliseconds(WAIT_RESPONSE_TIME_OUT_MS + OneMoreMs);
-            cv.notify_one();
-        }
-
-        void Wait();
-
-    private:
-        std::mutex mutex;
-        std::condition_variable cv;
-        bool requested = false; // some one request send something
-        std::chrono::steady_clock::time_point timeoutPoint;
-        bool timeout = false; // some data is sendout and next wait need wait response
-    } transfer;
-
-private:
-    HdcSessionBase &sessionBase;
-
-    enum PkgStatus {
-        PKG_WAIT_SEND,
-        PKG_WAIT_RESPONSE,
-    };
-    struct HandleOutputPkg {
-        std::string key;
-        uint32_t sessionId = 0; // like group , sometimes we will delete by this filter
-        bool response;          // PKG for response
-        bool ack;               // UartResponseCode for this package
-        uint8_t pkgStatus;
-        vector<uint8_t> msgSendBuf;
-        size_t retryChance = 4; // how many time need retry
-        std::chrono::time_point<std::chrono::steady_clock> sendTimePoint;
-        // reivew if we need direct process UartHead ?
-        HandleOutputPkg(std::string keyIn, uint32_t sessionIdIn, uint8_t *data, size_t length,
-                        bool responseIn = false, bool ackIn = false)
-            : key(keyIn),
-              sessionId(sessionIdIn),
-              response(responseIn),
-              ack(ackIn),
-              pkgStatus(PKG_WAIT_SEND),
-              msgSendBuf(data, data + length)
-        {
-        }
-        std::string ToDebugString()
-        {
-            std::string debug;
-            debug.append(key);
-            debug.append(" pkgStatus:");
-            debug.append(std::to_string(pkgStatus));
-            if (pkgStatus == PKG_WAIT_RESPONSE) {
-                debug.append(" sent:");
-                auto elapsedTime = std::chrono::duration_cast<std::chrono::milliseconds>(
-                    std::chrono::steady_clock::now() - sendTimePoint);
-                debug.append(std::to_string(elapsedTime.count()));
-                debug.append(" ms");
-                debug.append(" retry Chance:");
-                debug.append(std::to_string(retryChance));
-            }
-            if (response) {
-                debug.append(" response:");
-                if (ack) {
-                    debug.append(" ACK");
-                } else {
-                    debug.append(" NAK");
-                }
-            }
-            return debug;
-        }
-    };
-
-    class TransferSlot {
-    public:
-        void Wait(uint32_t sessionId)
-        {
-            std::unique_lock<std::mutex> lock(mutex);
-            cv.wait(lock, [=] { return hasWaitPkg.find(sessionId) == hasWaitPkg.end(); });
-            hasWaitPkg.emplace(sessionId);
-        }
-
-        void Free(uint32_t sessionId)
-        {
-            std::unique_lock<std::mutex> lock(mutex);
-            hasWaitPkg.erase(sessionId);
-            cv.notify_one();
-        }
-
-        // call when exit
-        void WaitFree()
-        {
-            std::unique_lock<std::mutex> lock(mutex);
-            cv.wait_for(lock, std::chrono::milliseconds(WAIT_RESPONSE_TIME_OUT_MS),
-                        [=] { return hasWaitPkg.size() == 0; });
-        }
-
-    private:
-        std::mutex mutex;
-        std::condition_variable cv;
-        std::unordered_set<uint32_t> hasWaitPkg;
-    } slots;
-
-    vector<HandleOutputPkg> outPkgs; // Pkg label, HOutPkg
-    std::recursive_mutex mapOutPkgsMutex;
-    struct HandleOutputPkgKeyFinder {
-        const std::string &key;
-        HandleOutputPkgKeyFinder(const std::string &keyIn) : key(keyIn) {}
-        bool operator()(const HandleOutputPkg &other)
-        {
-            return key == other.key;
-        }
-    };
-};
-} // namespace Hdc
-#endif
diff --git a/hdc/src/common/usb.cpp b/hdc/src/common/usb.cpp
deleted file mode 100644
index 7185002..0000000
--- a/hdc/src/common/usb.cpp
+++ /dev/null
@@ -1,203 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "usb.h"
-
-namespace Hdc {
-HdcUSBBase::HdcUSBBase(const bool serverOrDaemonIn, void *ptrMainBase)
-{
-    serverOrDaemon = serverOrDaemonIn;
-    clsMainBase = ptrMainBase;
-    modRunning = true;
-}
-
-HdcUSBBase::~HdcUSBBase()
-{
-}
-
-void HdcUSBBase::ReadUSB(uv_stream_t *stream, ssize_t nread, const uv_buf_t *buf)
-{
-    StartTraceScope("HdcUSBBase::ReadUSB");
-    HSession hSession = (HSession)stream->data;
-    HdcSessionBase *hSessionBase = (HdcSessionBase *)hSession->classInstance;
-    if (hSessionBase->FetchIOBuf(hSession, hSession->ioBuf, nread) < 0) {
-        WRITE_LOG(LOG_FATAL, "ReadUSB FetchIOBuf error sessionId:%u", hSession->sessionId);
-        hSessionBase->FreeSession(hSession->sessionId);
-    }
-}
-
-bool HdcUSBBase::ReadyForWorkThread(HSession hSession)
-{
-    // Server-end USB IO is handed over to each sub-thread, only the daemon is still read by the main IO to distribute
-    // to each sub-thread by DataPipe.
-    if (uv_tcp_init(&hSession->childLoop, &hSession->dataPipe[STREAM_WORK]) ||
-        uv_tcp_open(&hSession->dataPipe[STREAM_WORK], hSession->dataFd[STREAM_WORK])) {
-        WRITE_LOG(LOG_FATAL, "USBBase ReadyForWorkThread init child TCP failed");
-        return false;
-    }
-    hSession->dataPipe[STREAM_WORK].data = hSession;
-    HdcSessionBase *pSession = (HdcSessionBase *)hSession->classInstance;
-#ifdef HDC_HOST
-    Base::SetTcpOptions(&hSession->dataPipe[STREAM_WORK], HOST_SOCKETPAIR_SIZE);
-#else
-    Base::SetTcpOptions(&hSession->dataPipe[STREAM_WORK]);
-#endif
-    if (uv_read_start((uv_stream_t *)&hSession->dataPipe[STREAM_WORK], pSession->AllocCallback, ReadUSB)) {
-        WRITE_LOG(LOG_FATAL, "USBBase ReadyForWorkThread child TCP read failed");
-        return false;
-    }
-    WRITE_LOG(LOG_DEBUG, "USBBase ReadyForWorkThread finish dataFd[STREAM_WORK]:%d",
-        hSession->dataFd[STREAM_WORK]);
-    return true;
-};
-
-vector<uint8_t> HdcUSBBase::BuildPacketHeader(uint32_t sessionId, uint8_t option, uint32_t dataSize)
-{
-    vector<uint8_t> vecData;
-    USBHead head;
-    head.sessionId = htonl(sessionId);
-    for (size_t i = 0; i < sizeof(head.flag); i++) {
-        head.flag[i] = USB_PACKET_FLAG.data()[i];
-    }
-    head.option = option;
-    head.dataSize = htonl(dataSize);
-    vecData.insert(vecData.end(), (uint8_t *)&head, (uint8_t *)&head + sizeof(USBHead));
-    return vecData;
-}
-
-// USB big data stream, block transmission, mainly to prevent accidental data packets from writing through EP port,
-// inserting the send queue causes the program to crash
-int HdcUSBBase::SendUSBBlock(HSession hSession, uint8_t *data, const int length)
-{
-    int childRet = 0;
-    int ret = ERR_IO_FAIL;
-    StartTraceScope("HdcUSBBase::SendUSBBlock");
-    std::lock_guard<std::mutex> lock(hSession->hUSB->lockSendUsbBlock);
-    auto header = BuildPacketHeader(hSession->sessionId, USB_OPTION_HEADER, length);
-    do {
-        if ((SendUSBRaw(hSession, header.data(), header.size())) <= 0) {
-            WRITE_LOG(LOG_FATAL, "SendUSBRaw index failed");
-            break;
-        }
-        if ((childRet = SendUSBRaw(hSession, data, length)) <= 0) {
-            WRITE_LOG(LOG_FATAL, "SendUSBRaw body failed");
-            break;
-        }
-        if (childRet > 0 && (childRet % hSession->hUSB->wMaxPacketSizeSend == 0)) {
-            // win32 send ZLP will block winusb driver and LIBUSB_TRANSFER_ADD_ZERO_PACKET not effect
-            // so, we send dummy packet to prevent zero packet generate
-            auto dummy = BuildPacketHeader(hSession->sessionId, 0, 0);
-            if ((SendUSBRaw(hSession, dummy.data(), dummy.size())) <= 0) {
-                WRITE_LOG(LOG_FATAL, "SendUSBRaw dummy failed");
-                break;
-            }
-        }
-        ret = length;
-    } while (false);
-    return ret;
-}
-
-bool HdcUSBBase::IsUsbPacketHeader(uint8_t *ioBuf, int ioBytes)
-{
-    StartTraceScope("HdcUSBBase::IsUsbPacketHeader");
-    USBHead *usbPayloadHeader = reinterpret_cast<struct USBHead *>(ioBuf);
-    uint32_t maybeSize = ntohl(usbPayloadHeader->dataSize);
-    bool isHeader = false;
-    do {
-        if (memcmp(usbPayloadHeader->flag, USB_PACKET_FLAG.c_str(), USB_PACKET_FLAG.size())) {
-            break;
-        }
-        if (ioBytes != sizeof(USBHead)) {
-            break;
-        }
-        if (maybeSize == 0) {
-            isHeader = true;  // nop packet
-            break;
-        } else {  // maybeSize != 0
-            if (usbPayloadHeader->option & USB_OPTION_HEADER) {
-                isHeader = true;
-                break;
-            }
-        }
-    } while (false);
-    return isHeader;
-}
-
-void HdcUSBBase::PreSendUsbSoftReset(HSession hSession, uint32_t sessionIdOld)
-{
-    StartTraceScope("HdcUSBBase::PreSendUsbSoftReset");
-    HUSB hUSB = hSession->hUSB;
-    if (hSession->serverOrDaemon && !hUSB->resetIO) {
-        hUSB->lockSendUsbBlock.lock();
-        WRITE_LOG(LOG_WARN, "SendToHdcStream check, sessionId not matched");
-        auto header = BuildPacketHeader(sessionIdOld, USB_OPTION_RESET, 0);
-        if (SendUSBRaw(hSession, header.data(), header.size()) <= 0) {
-            WRITE_LOG(LOG_FATAL, "PreSendUsbSoftReset send failed");
-        }
-        hUSB->lockSendUsbBlock.unlock();
-        hUSB->resetIO = true;
-    }
-}
-
-int HdcUSBBase::CheckPacketOption(HSession hSession, uint8_t *appendData, int dataSize)
-{
-    HUSB hUSB = hSession->hUSB;
-    // special short packet
-    USBHead *header = reinterpret_cast<USBHead *>(appendData);
-    header->sessionId = ntohl(header->sessionId);
-    header->dataSize = ntohl(header->dataSize);
-    if (header->sessionId != hSession->sessionId) {
-        // Only server do it here, daemon 'SendUsbSoftReset' no use
-        // hilog + ctrl^C to reproduction scene
-        //
-        // Because the USB-reset API does not work on all platforms, the last session IO data may be
-        // recveived, we need to ignore it.
-        WRITE_LOG(LOG_WARN, "CheckPacketOption softreset header->sessionId:%u sessionId:%u",
-            header->sessionId, hSession->sessionId);
-        PreSendUsbSoftReset(hSession, header->sessionId);
-        return 0;
-    }
-    if (header->option & USB_OPTION_HEADER) {
-        // header packet
-        hUSB->payloadSize = header->dataSize;
-    }
-    // soft ZLP
-    return hUSB->payloadSize;
-}
-
-// return value: <0 error; = 0 all finish; >0 need size
-int HdcUSBBase::SendToHdcStream(HSession hSession, uv_stream_t *stream, uint8_t *appendData, int dataSize)
-{
-    StartTraceScope("HdcUSBBase::SendToHdcStream");
-    int childRet = 0;
-    HUSB hUSB = hSession->hUSB;
-    if (IsUsbPacketHeader(appendData, dataSize)) {
-        return CheckPacketOption(hSession, appendData, dataSize);
-    }
-    if (hUSB->payloadSize <= static_cast<uint32_t>(childRet)) {
-        // last session data
-        WRITE_LOG(LOG_WARN, "SendToHdcStream softreset dataSize:%d payloadSize:%u childRet:%d",
-            dataSize, hUSB->payloadSize, childRet);
-        PreSendUsbSoftReset(hSession, 0);  // 0 == reset current
-        return 0;
-    }
-    if ((childRet = UsbToHdcProtocol(stream, appendData, dataSize)) < 0) {
-        WRITE_LOG(LOG_FATAL, "Error usb send to stream dataSize:%d", dataSize);
-        return ERR_IO_FAIL;
-    }
-    hUSB->payloadSize -= childRet;
-    return hUSB->payloadSize;
-}
-
-}
diff --git a/hdc/src/common/usb.h b/hdc/src/common/usb.h
deleted file mode 100644
index 6967657..0000000
--- a/hdc/src/common/usb.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_USB_H
-#define HDC_USB_H
-#include "common.h"
-
-namespace Hdc {
-class HdcUSBBase {
-public:
-    HdcUSBBase(const bool serverOrDaemonIn, void *ptrMainBase);
-    virtual ~HdcUSBBase();
-    virtual bool ReadyForWorkThread(HSession hSession);
-    virtual void CancelUsbIo(HSession hSession) {};
-    int SendUSBBlock(HSession hSession, uint8_t *data, const int length);
-
-protected:
-    virtual int SendUSBRaw(HSession hSession, uint8_t *data, const int length)
-    {
-        return 0;
-    }
-    virtual int UsbToHdcProtocol(uv_stream_t *stream, uint8_t *appendData, int dataSize)
-    {
-        return 0;
-    };
-    int SendToHdcStream(HSession hSession, uv_stream_t *stream, uint8_t *appendData, int dataSize);
-    int GetSafeUsbBlockSize(uint16_t wMaxPacketSizeSend);
-    bool IsUsbPacketHeader(uint8_t *ioBuf, int ioBytes);
-    vector<uint8_t> BuildPacketHeader(uint32_t sessionId, uint8_t option, uint32_t dataSize);
-
-    void *clsMainBase;
-    bool modRunning;
-    bool serverOrDaemon;
-    const string USB_PACKET_FLAG = "UB";  // must 2bytes
-
-private:
-    static void ReadUSB(uv_stream_t *stream, ssize_t nread, const uv_buf_t *buf);
-    int CheckPacketOption(HSession hSession, uint8_t *appendData, int dataSize);
-    void PreSendUsbSoftReset(HSession hSession, uint32_t sessionIdOld);
-};
-}  // namespace Hdc
-
-#endif
\ No newline at end of file
diff --git a/hdc/src/daemon/CMakeLists.txt b/hdc/src/daemon/CMakeLists.txt
deleted file mode 100644
index f709281..0000000
--- a/hdc/src/daemon/CMakeLists.txt
+++ /dev/null
@@ -1,9 +0,0 @@
-add_definitions(-DUSE_CONFIG_UV_THREADS -DSIZE_THREAD_POOL=16 -DJS_JDWP_CONNECT -DTEST_HASH -DHDC_MSG_HASH="TEST")
-
-AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_LIST_DIR} DAEMON_SRCS)
-AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_LIST_DIR}/../common COMMON_SRCS)
-
-link_libraries(uv crypto
-    ${ohos_top}/out/sdk/clang_x64/obj/third_party/bounds_checking_function/libsec_static.a)
-
-add_executable(hdcd ${COMMON_SRCS} ${DAEMON_SRCS})
diff --git a/hdc/src/daemon/daemon.cpp b/hdc/src/daemon/daemon.cpp
deleted file mode 100644
index 2fb7f9d..0000000
--- a/hdc/src/daemon/daemon.cpp
+++ /dev/null
@@ -1,1131 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "daemon.h"
-#ifndef TEST_HASH
-#include "hdc_hash_gen.h"
-#endif
-#include "serial_struct.h"
-#include <openssl/sha.h>
-#include <openssl/bio.h>
-#include <openssl/evp.h>
-#include <openssl/err.h>
-#include <openssl/pem.h>
-#include <fstream>
-#include <unistd.h>
-#include <sys/wait.h>
-
-namespace Hdc {
-#ifdef USE_CONFIG_UV_THREADS
-HdcDaemon::HdcDaemon(bool serverOrDaemonIn, size_t uvThreadSize)
-    : HdcSessionBase(serverOrDaemonIn, uvThreadSize)
-#else
-HdcDaemon::HdcDaemon(bool serverOrDaemonIn)
-    : HdcSessionBase(serverOrDaemonIn, -1)
-#endif
-{
-    clsTCPServ = nullptr;
-    clsUSBServ = nullptr;
-#ifdef HDC_EMULATOR
-    clsBridgeServ = nullptr;
-#endif
-#ifdef HDC_SUPPORT_UART
-    clsUARTServ = nullptr;
-#endif
-    clsJdwp = nullptr;
-    enableSecure = false;
-}
-
-HdcDaemon::~HdcDaemon()
-{
-    WRITE_LOG(LOG_DEBUG, "~HdcDaemon");
-}
-
-void HdcDaemon::ClearInstanceResource()
-{
-    TryStopInstance();
-    Base::TryCloseLoop(&loopMain, "HdcDaemon::~HdcDaemon");
-    if (clsTCPServ) {
-        delete (HdcDaemonTCP *)clsTCPServ;
-        clsTCPServ = nullptr;
-    }
-    if (clsUSBServ) {
-        delete (HdcDaemonUSB *)clsUSBServ;
-        clsUSBServ = nullptr;
-    }
-#ifdef HDC_EMULATOR
-    if (clsBridgeServ) {
-        delete (HdcDaemonBridge *)clsBridgeServ;
-    }
-#endif
-#ifdef HDC_SUPPORT_UART
-    if (clsUARTServ) {
-        delete (HdcDaemonUART *)clsUARTServ;
-    }
-    clsUARTServ = nullptr;
-#endif
-    if (clsJdwp) {
-        delete (HdcJdwp *)clsJdwp;
-        clsJdwp = nullptr;
-    }
-    WRITE_LOG(LOG_DEBUG, "~HdcDaemon finish");
-}
-
-void HdcDaemon::TryStopInstance()
-{
-    ClearSessions();
-    if (clsTCPServ) {
-        WRITE_LOG(LOG_DEBUG, "Stop TCP");
-        ((HdcDaemonTCP *)clsTCPServ)->Stop();
-    }
-    if (clsUSBServ) {
-        WRITE_LOG(LOG_DEBUG, "Stop USB");
-        ((HdcDaemonUSB *)clsUSBServ)->Stop();
-    }
-#ifdef HDC_EMULATOR
-    if (clsBridgeServ) {
-        WRITE_LOG(LOG_DEBUG, "Stop Bridge");
-        ((HdcDaemonBridge *)clsBridgeServ)->Stop();
-    }
-#endif
-#ifdef HDC_SUPPORT_UART
-    if (clsUARTServ) {
-        WRITE_LOG(LOG_DEBUG, "Stop UART");
-        ((HdcDaemonUART *)clsUARTServ)->Stop();
-    }
-#endif
-    ((HdcJdwp *)clsJdwp)->Stop();
-    // workaround temply remove MainLoop instance clear
-    ReMainLoopForInstanceClear();
-    WRITE_LOG(LOG_DEBUG, "Stop loopmain");
-}
-
-#ifdef HDC_SUPPORT_UART
-void HdcDaemon::InitMod(bool bEnableTCP, bool bEnableUSB, [[maybe_unused]] bool bEnableUART)
-#else
-void HdcDaemon::InitMod(bool bEnableTCP, bool bEnableUSB)
-#endif
-{
-    WRITE_LOG(LOG_DEBUG, "HdcDaemon InitMod");
-#ifdef HDC_SUPPORT_UART
-    WRITE_LOG(LOG_DEBUG, "bEnableTCP:%d,bEnableUSB:%d", bEnableTCP, bEnableUSB);
-#endif
-    if (bEnableTCP) {
-        // tcp
-        clsTCPServ = new(std::nothrow) HdcDaemonTCP(false, this);
-        if (clsTCPServ == nullptr) {
-            WRITE_LOG(LOG_FATAL, "InitMod new clsTCPServ failed");
-            return;
-        }
-        ((HdcDaemonTCP *)clsTCPServ)->Initial();
-    }
-    if (bEnableUSB) {
-        // usb
-        clsUSBServ = new(std::nothrow) HdcDaemonUSB(false, this);
-        if (clsUSBServ == nullptr) {
-            WRITE_LOG(LOG_FATAL, "InitMod new clsUSBServ failed");
-            return;
-        }
-        ((HdcDaemonUSB *)clsUSBServ)->Initial();
-    }
-#ifdef HDC_SUPPORT_UART
-    WRITE_LOG(LOG_DEBUG, "bEnableUART:%d", bEnableUART);
-    if (bEnableUART) {
-        // UART
-        clsUARTServ = new(std::nothrow) HdcDaemonUART(*this);
-        if (clsUARTServ == nullptr) {
-            WRITE_LOG(LOG_FATAL, "InitMod new clsUARTServ failed");
-            return;
-        }
-        ((HdcDaemonUART *)clsUARTServ)->Initial();
-    }
-#endif
-    clsJdwp = new(std::nothrow) HdcJdwp(&loopMain);
-    if (clsJdwp == nullptr) {
-        WRITE_LOG(LOG_FATAL, "InitMod new clsJdwp failed");
-        return;
-    }
-    ((HdcJdwp *)clsJdwp)->Initial();
-    // enable security
-    string secure;
-    SystemDepend::GetDevItem("const.hdc.secure", secure);
-    string authbypass;
-    SystemDepend::GetDevItem("persist.hdc.auth_bypass", authbypass);
-#ifndef HDC_EMULATOR
-    enableSecure = ((Base::Trim(secure) == "1") && (Base::Trim(authbypass) != "1"));
-#endif
-}
-
-#ifdef HDC_EMULATOR
-#ifdef HDC_SUPPORT_UART
-void HdcDaemon::InitMod(bool bEnableTCP, bool bEnableUSB, bool bEnableBridge, [[maybe_unused]] bool bEnableUART)
-{
-    InitMod(bEnableTCP, bEnableUSB, bEnableUART);
-#else
-void HdcDaemon::InitMod(bool bEnableTCP, bool bEnableUSB, bool bEnableBridge)
-{
-    InitMod(bEnableTCP, bEnableUSB);
-#endif
-    if (bEnableBridge) {
-        clsBridgeServ = new(std::nothrow) HdcDaemonBridge(false, this);
-        if (clsBridgeServ == nullptr) {
-            WRITE_LOG(LOG_FATAL, "InitMod new clsBridgeServ failed");
-            return;
-        }
-        ((HdcDaemonBridge *)clsBridgeServ)->Initial();
-    }
-}
-#endif
-
-// clang-format off
-bool HdcDaemon::RedirectToTask(HTaskInfo hTaskInfo, HSession hSession, const uint32_t channelId,
-                               const uint16_t command, uint8_t *payload, const int payloadSize)
-{
-    StartTraceScope("HdcDaemon::RedirectToTask");
-    bool ret = true;
-    hTaskInfo->ownerSessionClass = this;
-    switch (command) {
-        case CMD_UNITY_EXECUTE:
-        case CMD_UNITY_REMOUNT:
-        case CMD_UNITY_REBOOT:
-        case CMD_UNITY_RUNMODE:
-        case CMD_UNITY_HILOG:
-        case CMD_UNITY_ROOTRUN:
-        case CMD_UNITY_BUGREPORT_INIT:
-        case CMD_JDWP_LIST:
-        case CMD_JDWP_TRACK:
-            ret = TaskCommandDispatch<HdcDaemonUnity>(hTaskInfo, TYPE_UNITY, command, payload, payloadSize);
-            break;
-        case CMD_SHELL_INIT:
-        case CMD_SHELL_DATA:
-            ret = TaskCommandDispatch<HdcShell>(hTaskInfo, TYPE_SHELL, command, payload, payloadSize);
-            break;
-        case CMD_FILE_CHECK:
-        case CMD_FILE_DATA:
-        case CMD_FILE_FINISH:
-        case CMD_FILE_INIT:
-        case CMD_FILE_BEGIN:
-        case CMD_FILE_MODE:
-        case CMD_DIR_MODE:
-            ret = TaskCommandDispatch<HdcFile>(hTaskInfo, TASK_FILE, command, payload, payloadSize);
-            break;
-        // One-way function, so fewer options
-        case CMD_APP_CHECK:
-        case CMD_APP_DATA:
-        case CMD_APP_UNINSTALL:
-            ret = TaskCommandDispatch<HdcDaemonApp>(hTaskInfo, TASK_APP, command, payload, payloadSize);
-            break;
-        case CMD_FORWARD_INIT:
-        case CMD_FORWARD_CHECK:
-        case CMD_FORWARD_ACTIVE_MASTER:
-        case CMD_FORWARD_ACTIVE_SLAVE:
-        case CMD_FORWARD_DATA:
-        case CMD_FORWARD_FREE_CONTEXT:
-        case CMD_FORWARD_CHECK_RESULT:
-            ret = TaskCommandDispatch<HdcDaemonForward>(hTaskInfo, TASK_FORWARD, command, payload, payloadSize);
-            break;
-        default:
-        // ignore unknown command
-            break;
-    }
-    return ret;
-}
-// clang-format on
-
-bool HdcDaemon::ShowPermitDialog()
-{
-    pid_t pid;
-    int fds[2];
-    pipe(fds);
-
-    if ((pid = fork()) == -1) {
-        WRITE_LOG(LOG_FATAL, "fork failed %s", strerror(errno));
-        return false;
-    }
-    if (pid == 0) {
-        Base::DeInitProcess();
-        // close the child read channel
-        close(fds[0]);
-        // redirect the child write channel
-        dup2(fds[1], STDOUT_FILENO);
-        dup2(fds[1], STDERR_FILENO);
-
-        setsid();
-        setpgid(pid, pid);
-
-        int ret = execl("/system/bin/hdcd_user_permit", "hdcd_user_permit", NULL);
-        // if execl failed need return false
-        WRITE_LOG(LOG_FATAL, "start user_permit failed %d: %s", ret, strerror(errno));
-        return false;
-    } else {
-            Base::CloseFd(fds[1]);
-            waitpid(pid, nullptr, 0);
-            char buf[1024] = { 0 };
-            int nbytes = read(fds[0], buf, sizeof(buf) - 1);
-            WRITE_LOG(LOG_FATAL, "user_permit put %d bytes: %s", nbytes, buf);
-            close(fds[0]);
-    }
-
-    return true;
-}
-
-UserPermit HdcDaemon::PostUIConfirm(string hostname, string pubkey)
-{
-    // clear result first
-    if (!SystemDepend::SetDevItem("persist.hdc.daemon.auth_result", "auth_result_none")) {
-        WRITE_LOG(LOG_FATAL, "debug auth result failed, so refuse this connect");
-        return REFUSE;
-    }
-
-    // then write para for setting
-    if (!SystemDepend::SetDevItem("persist.hdc.client.hostname", hostname.c_str())) {
-        WRITE_LOG(LOG_FATAL, "set param(%s) failed", hostname.c_str());
-        return REFUSE;
-    }
-
-    uint8_t sha256Result[SHA256_DIGEST_LENGTH] = { 0 };
-    if (SHA256(reinterpret_cast<const uint8_t *>(pubkey.c_str()), pubkey.length(), sha256Result) == nullptr) {
-        WRITE_LOG(LOG_FATAL, "sha256 pubkey failed");
-        return REFUSE;
-    }
-
-    string hex = Base::Convert2HexStr(sha256Result, SHA256_DIGEST_LENGTH);
-    if (!SystemDepend::SetDevItem("persist.hdc.client.pubkey_sha256", hex.c_str())) {
-        WRITE_LOG(LOG_DEBUG, "Failed to set pubkey prop.");
-        return REFUSE;
-    }
-
-    if (!ShowPermitDialog()) {
-        WRITE_LOG(LOG_FATAL, "show dialog failed, so refuse this connect.");
-        return REFUSE;
-    }
-
-    string authResult;
-    if (!SystemDepend::GetDevItem("persist.hdc.daemon.auth_result", authResult)) {
-        WRITE_LOG(LOG_FATAL, "user refuse [%s] this developer [%s]", authResult.c_str(), hostname.c_str());
-        return REFUSE;
-    }
-    WRITE_LOG(LOG_FATAL, "user permit_result [%s] for this developer [%s]", authResult.c_str(), hostname.c_str());
-    string prifix = "auth_result:";
-    string result = authResult.substr(prifix.length());
-    if (result == "1") {
-        return ALLOWONCE;
-    }
-    if (result == "2") {
-        return ALLOWFORVER;
-    }
-    return REFUSE;
-}
-
-bool HdcDaemon::GetHostPubkeyInfo(const string& buf, string& hostname, string& pubkey)
-{
-    // "\f" asicc is 0x0C
-    char separator = '\x0C';
-
-    hostname = buf.substr(0, buf.find(separator));
-    pubkey = buf.substr(buf.find(separator) + 1);
-    WRITE_LOG(LOG_INFO, "hostname is [%s], pubkey is [%s]", hostname.c_str(),
-        pubkey.substr(0, pubkey.size() / 2).c_str());
-
-    return (!hostname.empty() && !pubkey.empty());
-}
-
-void HdcDaemon::ClearKnownHosts()
-{
-    char const *keyfile = "/data/service/el1/public/hdc/hdc_keys";
-
-    if (!enableSecure || HandDaemonAuthBypass()) {
-        WRITE_LOG(LOG_INFO, "not enable secure, noneed clear keyfile");
-        return;
-    }
-
-    string authcancel;
-    if (!SystemDepend::GetDevItem("persist.hdc.daemon.auth_cancel", authcancel)) {
-        WRITE_LOG(LOG_FATAL, "get param auth_cancel failed");
-        return;
-    }
-    if (authcancel != "true") {
-        WRITE_LOG(LOG_FATAL, "param auth_cancel is not true: %s", authcancel.c_str());
-        return;
-    }
-    if (!SystemDepend::SetDevItem("persist.hdc.daemon.auth_cancel", "false")) {
-        WRITE_LOG(LOG_FATAL, "set param auth_cancel failed");
-    }
-
-    std::ofstream keyofs(keyfile, std::ios::out | std::ios::trunc);
-    if (!keyofs.is_open()) {
-        WRITE_LOG(LOG_FATAL, "open keyfile %s error", keyfile);
-        return;
-    }
-
-    keyofs.flush();
-    keyofs.close();
-
-    WRITE_LOG(LOG_FATAL, "clear keyfile %s over", keyfile);
-
-    return;
-}
-
-void HdcDaemon::UpdateKnownHosts(const string& key)
-{
-    char const *keyfile = "/data/service/el1/public/hdc/hdc_keys";
-
-    std::ofstream keyofs(keyfile, std::ios::app);
-    if (!keyofs.is_open()) {
-        WRITE_LOG(LOG_FATAL, "open keyfile %s error", keyfile);
-        return;
-    }
-
-    string keytmp = key + "\n";
-    keyofs.write(keytmp.c_str(), keytmp.length());
-    keyofs.flush();
-    keyofs.close();
-
-    WRITE_LOG(LOG_FATAL, "save new key [%s] into keyfile %s over", key.substr(0, key.size() / 2).c_str(), keyfile);
-
-    return;
-}
-
-bool HdcDaemon::AlreadyInKnownHosts(const string& key)
-{
-    char const *keyfile = "/data/service/el1/public/hdc/hdc_keys";
-
-    std::ifstream keyifs(keyfile);
-    if (!keyifs.is_open()) {
-        WRITE_LOG(LOG_FATAL, "open keyfile %s error", keyfile);
-        return false;
-    }
-
-    std::string keys((std::istreambuf_iterator<char>(keyifs)), std::istreambuf_iterator<char>());
-    if (keys.find(key) != string::npos) {
-        keyifs.close();
-        return true;
-    }
-
-    WRITE_LOG(LOG_FATAL, "key [%s] not in keyfile %s", key.substr(0, key.size() / 2).c_str(), keyfile);
-
-    keyifs.close();
-    return false;
-}
-
-bool HdcDaemon::HandDaemonAuthInit(HSession hSession, const uint32_t channelId, SessionHandShake &handshake)
-{
-    hSession->tokenRSA = Base::GetSecureRandomString(SHA_DIGEST_LENGTH);
-    handshake.authType = AUTH_PUBLICKEY;
-    /*
-     * If we know client support RSA_3072_SHA512 in AUTH_NONE phase
-     * Then told client that the server also support RSA_3072_SHA512 auth
-     * Notice, before here is "handshake.buf = hSession->tokenRSA", but the server not use it
-    */
-    if (hSession->verifyType == AuthVerifyType::RSA_3072_SHA512) {
-        handshake.buf.clear();
-        Base::TlvAppend(handshake.buf, TAG_AUTH_TYPE, std::to_string(AuthVerifyType::RSA_3072_SHA512));
-        WRITE_LOG(LOG_INFO, "client support RSA_3072_SHA512 auth for %u session", hSession->sessionId);
-    }
-    string bufString = SerialStruct::SerializeToString(handshake);
-    Send(hSession->sessionId, channelId, CMD_KERNEL_HANDSHAKE,
-            reinterpret_cast<uint8_t *>(const_cast<char *>(bufString.c_str())),
-            bufString.size());
-
-    InitSessionAuthInfo(hSession->sessionId, hSession->tokenRSA);
-    return true;
-}
-
-bool HdcDaemon::HandDaemonAuthPubkey(HSession hSession, const uint32_t channelId, SessionHandShake &handshake)
-{
-    bool ret = false;
-    string hostname, pubkey;
-
-    do {
-        if (!GetHostPubkeyInfo(handshake.buf, hostname, pubkey)) {
-            WRITE_LOG(LOG_FATAL, "get pubkey failed for %u", hSession->sessionId);
-            break;
-        }
-        if (AlreadyInKnownHosts(pubkey)) {
-            ret = true;
-            break;
-        }
-
-        string confirmmsg = "[E000002]:The device unauthorized.\r\n"\
-                             "This server's public key is not set.\r\n"\
-                             "Please check for a confirmation dialog on your device.\r\n"\
-                             "Otherwise try 'hdc kill' if that seems wrong.";
-        std::thread notifymsg([this, &handshake, channelId, sessionId = hSession->sessionId, &confirmmsg]() {
-            this->EchoHandshakeMsg(handshake, channelId, sessionId, confirmmsg);
-        });
-        notifymsg.detach();
-
-        UserPermit permit = PostUIConfirm(hostname, pubkey);
-        if (permit == ALLOWONCE) {
-            WRITE_LOG(LOG_FATAL, "user allow onece for %u", hSession->sessionId);
-            ret = true;
-        } else if (permit == ALLOWFORVER) {
-            WRITE_LOG(LOG_FATAL, "user allow forever for %u", hSession->sessionId);
-            UpdateKnownHosts(pubkey);
-            ret = true;
-        } else {
-            WRITE_LOG(LOG_FATAL, "user refuse for %u", hSession->sessionId);
-            ret = false;
-        }
-    } while (0);
-
-    if (ret) {
-        SendAuthSignMsg(handshake, channelId, hSession->sessionId, pubkey, hSession->tokenRSA);
-    } else {
-        string notifymsg = "[E000003]:The device unauthorized.\r\n"\
-                            "The user denied the access for the device.\r\n"\
-                             "Please execute 'hdc kill' and redo your command,\r\n"\
-                             "then check for a confirmation dialog on your device.";
-        EchoHandshakeMsg(handshake, channelId, hSession->sessionId, notifymsg);
-    }
-    return true;
-}
-
-/*
- * tokenSignBase64 is Base64 encode of the signing from server
- * token is the source data same of server for signing
- */
-bool HdcDaemon::RsaSignVerify(HSession hSession, EVP_PKEY_CTX *ctx, const string &tokenSignBase64, const string &token)
-{
-    unsigned char tokenSha512[SHA512_DIGEST_LENGTH];
-    try {
-        std::unique_ptr<unsigned char[]> tokenRsaSign = std::make_unique<unsigned char[]>(tokenSignBase64.length());
-        // Get the real token sign
-        int tokenRsaSignLen = EVP_DecodeBlock(tokenRsaSign.get(),
-            reinterpret_cast<const unsigned char *>(tokenSignBase64.c_str()), tokenSignBase64.length());
-        if (tokenRsaSignLen <= 0) {
-            WRITE_LOG(LOG_FATAL, "base64 decode token sign failed for session %u", hSession->sessionId);
-            return false;
-        }
-        SHA512(reinterpret_cast<const unsigned char *>(token.c_str()), token.size(), tokenSha512);
-        if (EVP_PKEY_verify(ctx, tokenRsaSign.get(), tokenRsaSignLen, tokenSha512, sizeof(tokenSha512)) < 0) {
-            WRITE_LOG(LOG_FATAL, "verify failed for session %u", hSession->sessionId);
-            return false;
-        }
-    } catch (std::exception &e) {
-        WRITE_LOG(LOG_FATAL, "sign verify failed for session %u with exception %s", hSession->sessionId, e.what());
-        return false;
-    }
-
-    WRITE_LOG(LOG_FATAL, "sign verify success for session %u", hSession->sessionId);
-    return true;
-}
-
-bool HdcDaemon::AuthVerifyRsaSign(HSession hSession, const string &tokenSign, const string &token, RSA *rsa)
-{
-    EVP_PKEY *signKey = nullptr;
-    EVP_PKEY_CTX *ctx = nullptr;
-    bool signRet = false;
-
-    signKey = EVP_PKEY_new();
-    if (signKey == nullptr) {
-        WRITE_LOG(LOG_FATAL, "EVP_PKEY_new failed");
-        return false;
-    }
-    do {
-        if (EVP_PKEY_set1_RSA(signKey, rsa) <= 0) {
-            WRITE_LOG(LOG_FATAL, "EVP_PKEY_new failed");
-            break;
-        }
-        // the length of vaild sign result for BASE64 can't bigger than  EVP_PKEY_size(signKey) * 2
-        if (tokenSign.size() > ((size_t)EVP_PKEY_size(signKey) * (size_t)2)) {
-            WRITE_LOG(LOG_FATAL, "invalid base64 sign size %zd for session %u", tokenSign.size(), hSession->sessionId);
-            break;
-        }
-        ctx = EVP_PKEY_CTX_new(signKey, nullptr);
-        if (ctx == nullptr) {
-            WRITE_LOG(LOG_FATAL, "EVP_PKEY_CTX_new failed");
-            break;
-        }
-        if (EVP_PKEY_verify_init(ctx) <= 0) {
-            WRITE_LOG(LOG_FATAL, "EVP_PKEY_CTX_new failed");
-            break;
-        }
-        if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_PSS_PADDING) <= 0 ||
-            EVP_PKEY_CTX_set_rsa_pss_saltlen(ctx, RSA_PSS_SALTLEN_AUTO) <= 0) {
-            WRITE_LOG(LOG_FATAL, "set saltlen or padding failed");
-            break;
-        }
-        if (EVP_PKEY_CTX_set_signature_md(ctx, EVP_sha512()) <= 0) {
-            WRITE_LOG(LOG_FATAL, "EVP_PKEY_CTX_set_signature_md failed");
-            break;
-        }
-        signRet = RsaSignVerify(hSession, ctx, tokenSign, token);
-    } while (0);
-
-    if (ctx != nullptr) {
-        EVP_PKEY_CTX_free(ctx);
-    }
-    if (signKey != nullptr) {
-        EVP_PKEY_free(signKey);
-    }
-    return signRet;
-}
-
-bool HdcDaemon::AuthVerify(HSession hSession, const string &encryptToken, const string &token, const string &pubkey)
-{
-    BIO *bio = nullptr;
-    RSA *rsa = nullptr;
-    const unsigned char *pubkeyp = reinterpret_cast<const unsigned char *>(pubkey.c_str());
-    bool verifyResult = false;
-
-    do {
-        bio = BIO_new(BIO_s_mem());
-        if (bio == nullptr) {
-            WRITE_LOG(LOG_FATAL, "bio failed for session %u", hSession->sessionId);
-            break;
-        }
-        int wbytes = BIO_write(bio, pubkeyp, pubkey.length());
-        if (wbytes <= 0) {
-            WRITE_LOG(LOG_FATAL, "bio write failed %d for session %u", wbytes, hSession->sessionId);
-            break;
-        }
-        rsa = PEM_read_bio_RSA_PUBKEY(bio, nullptr, nullptr, nullptr);
-        if (rsa == nullptr) {
-            WRITE_LOG(LOG_FATAL, "rsa failed for session %u", hSession->sessionId);
-            break;
-        }
-        if (hSession->verifyType == AuthVerifyType::RSA_3072_SHA512) {
-            verifyResult = AuthVerifyRsaSign(hSession, encryptToken, token, rsa);
-        } else {
-            verifyResult = AuthVerifyRsa(hSession, encryptToken, token, rsa);
-        }
-    } while (0);
-
-    if (bio) {
-        BIO_free(bio);
-    }
-    if (rsa) {
-        RSA_free(rsa);
-    }
-
-    return verifyResult;
-}
-
-bool HdcDaemon::AuthVerifyRsa(HSession hSession, const string &encryptToken, const string &token, RSA *rsa)
-{
-    const unsigned char *tokenp = reinterpret_cast<const unsigned char *>(encryptToken.c_str());
-    unsigned char tokenDecode[BUF_SIZE_DEFAULT] = { 0 };
-    unsigned char decryptToken[BUF_SIZE_DEFAULT] = { 0 };
-
-    // for rsa encrypt, the length of encryptToken can't bigger than BUF_SIZE_DEFAULT
-    if (encryptToken.length() > BUF_SIZE_DEFAULT2) {
-        WRITE_LOG(LOG_FATAL, "invalid encryptToken, length is %zd", encryptToken.length());
-        return false;
-    }
-    int tbytes = EVP_DecodeBlock(tokenDecode, tokenp, encryptToken.length());
-    if (tbytes <= 0) {
-        WRITE_LOG(LOG_FATAL, "base64 decode pubkey failed");
-        return false;
-    }
-    int bytes = RSA_public_decrypt(tbytes, tokenDecode, decryptToken, rsa, RSA_PKCS1_PADDING);
-    if (bytes < 0) {
-        WRITE_LOG(LOG_FATAL, "decrypt failed(%lu) for session %u", ERR_get_error(), hSession->sessionId);
-        return false;
-    }
-    string sdecryptToken(reinterpret_cast<const char *>(decryptToken), bytes);
-    if (sdecryptToken != token) {
-        WRITE_LOG(LOG_FATAL, "auth failed for session %u)", hSession->sessionId);
-        return false;
-    }
-    return true;
-}
-
-bool HdcDaemon::HandDaemonAuthSignature(HSession hSession, const uint32_t channelId, SessionHandShake &handshake)
-{
-    // When Host is first connected to the device, the signature authentication is inevitable, and the
-    // certificate verification must be triggered.
-    //
-    // When the certificate is verified, the client sends a public key to the device, triggered the system UI
-    // jump out dialog, and click the system, the system will store the Host public key certificate in the
-    // device locally, and the signature authentication will be correct when the subsequent connection is
-    // connected.
-    string token = GetSessionAuthToken(hSession->sessionId);
-    string pubkey = GetSessionAuthPubkey(hSession->sessionId);
-    if (!AuthVerify(hSession, handshake.buf, token, pubkey)) {
-        WRITE_LOG(LOG_FATAL, "auth failed for session %u", hSession->sessionId);
-        // Next auth
-        EchoHandshakeMsg(handshake, channelId, hSession->sessionId, "[E000010]:Auth failed, cannt login the device.");
-        return true;
-    }
-
-    WRITE_LOG(LOG_FATAL, "auth success for session %u", hSession->sessionId);
-
-    UpdateSessionAuthOk(hSession->sessionId);
-    SendAuthOkMsg(handshake, channelId, hSession->sessionId);
-    return true;
-}
-
-bool HdcDaemon::HandDaemonAuthBypass(void)
-{
-    // persist.hdc.auth_bypass 1 is bypass orelse(0 or not set) not bypass
-    string authbypass;
-    SystemDepend::GetDevItem("persist.hdc.auth_bypass", authbypass);
-    return Base::Trim(authbypass) == "1";
-}
-
-bool HdcDaemon::HandDaemonAuth(HSession hSession, const uint32_t channelId, SessionHandShake &handshake)
-{
-    if (!enableSecure) {
-        WRITE_LOG(LOG_INFO, "not enable secure, allow access for %u", hSession->sessionId);
-        UpdateSessionAuthOk(hSession->sessionId);
-        SendAuthOkMsg(handshake, channelId, hSession->sessionId);
-        return true;
-    } else if (HandDaemonAuthBypass()) {
-        WRITE_LOG(LOG_INFO, "auth bypass, allow access for %u", hSession->sessionId);
-        UpdateSessionAuthOk(hSession->sessionId);
-        SendAuthOkMsg(handshake, channelId, hSession->sessionId);
-        return true;
-    } else if (handshake.version < "Ver: 3.0.0b") {
-        WRITE_LOG(LOG_INFO, "session %u client version %s is too low %u authType %d",
-                    hSession->sessionId, handshake.version.c_str(), handshake.authType);
-        AuthRejectLowClient(handshake, channelId, hSession->sessionId);
-        return true;
-    } else if (GetSessionAuthStatus(hSession->sessionId) == AUTH_OK) {
-        WRITE_LOG(LOG_INFO, "session %u already auth ok", hSession->sessionId);
-        return true;
-    }
-
-    if (handshake.authType == AUTH_NONE) {
-        return HandDaemonAuthInit(hSession, channelId, handshake);
-    } else if (handshake.authType == AUTH_PUBLICKEY) {
-        return HandDaemonAuthPubkey(hSession, channelId, handshake);
-    } else if (handshake.authType == AUTH_SIGNATURE) {
-        return HandDaemonAuthSignature(hSession, channelId, handshake);
-    } else {
-        WRITE_LOG(LOG_FATAL, "invalid auth state %d for session %u", handshake.authType, hSession->sessionId);
-        return false;
-    }
-}
-
-/*
- * For daemon, if server add new capability, we can parse it here
- */
-void HdcDaemon::GetServerCapability(HSession &hSession, SessionHandShake &handshake)
-{
-    /*
-     * Check if server support RSA_3072_SHA512 for auth
-     * if the value not contain RSA_3072_SHA512, We treat it not support
-    */
-    std::map<string, string> tlvMap;
-    hSession->verifyType = AuthVerifyType::RSA_ENCRYPT;
-    if (!Base::TlvToStringMap(handshake.buf, tlvMap)) {
-        WRITE_LOG(LOG_INFO, "maybe old version client for %u session", hSession->sessionId);
-        return;
-    }
-    if (tlvMap.find(TAG_AUTH_TYPE) != tlvMap.end() &&
-        tlvMap[TAG_AUTH_TYPE] == std::to_string(AuthVerifyType::RSA_3072_SHA512)) {
-        hSession->verifyType = AuthVerifyType::RSA_3072_SHA512;
-    }
-    WRITE_LOG(LOG_INFO, "client auth type is %u for %u session", hSession->verifyType, hSession->sessionId);
-}
-
-void HdcDaemon::DaemonSessionHandshakeInit(HSession &hSession, SessionHandShake &handshake)
-{
-    // daemon handshake 1st packet
-    uint32_t unOld = hSession->sessionId;
-    hSession->sessionId = handshake.sessionId;
-    hSession->connectKey = handshake.connectKey;
-    hSession->handshakeOK = false;
-    AdminSession(OP_UPDATE, unOld, hSession);
-#ifdef HDC_SUPPORT_UART
-    if (hSession->connType == CONN_SERIAL and clsUARTServ!= nullptr) {
-        WRITE_LOG(LOG_DEBUG, " HdcDaemon::DaemonSessionHandshake %s",
-                    handshake.ToDebugString().c_str());
-        if (clsUARTServ != nullptr) {
-            (static_cast<HdcDaemonUART *>(clsUARTServ))->OnNewHandshakeOK(hSession->sessionId);
-        }
-    } else
-#endif // HDC_SUPPORT_UART
-    if (clsUSBServ != nullptr && hSession->connType == CONN_USB) {
-        (reinterpret_cast<HdcDaemonUSB *>(clsUSBServ))->OnNewHandshakeOK(hSession->sessionId);
-    }
-
-    handshake.sessionId = 0;
-    handshake.connectKey = "";
-    // Get server capability
-    GetServerCapability(hSession, handshake);
-}
-
-bool HdcDaemon::DaemonSessionHandshake(HSession hSession, const uint32_t channelId, uint8_t *payload, int payloadSize)
-{
-    StartTraceScope("HdcDaemon::DaemonSessionHandshake");
-    // session handshake step2
-    string s = string(reinterpret_cast<char *>(payload), payloadSize);
-    SessionHandShake handshake;
-    string err;
-    SerialStruct::ParseFromString(handshake, s);
-#ifdef HDC_DEBUG
-    WRITE_LOG(LOG_DEBUG, "session %s try to handshake", hSession->ToDebugString().c_str());
-#endif
-    // banner to check is parse ok...
-    if (handshake.banner != HANDSHAKE_MESSAGE) {
-        hSession->availTailIndex = 0;
-        WRITE_LOG(LOG_FATAL, "Recv server-hello failed");
-        return false;
-    }
-    if (handshake.authType == AUTH_NONE) {
-        DaemonSessionHandshakeInit(hSession, handshake);
-    }
-    if (!HandDaemonAuth(hSession, channelId, handshake)) {
-        WRITE_LOG(LOG_FATAL, "auth failed");
-        return false;
-    }
-    string version = Base::GetVersion() + HDC_MSG_HASH;
-
-    WRITE_LOG(LOG_DEBUG, "receive hs version = %s", handshake.version.c_str());
-
-    if (!handshake.version.empty() && handshake.version != version) {
-        WRITE_LOG(LOG_FATAL, "DaemonSessionHandshake failed! version not match [%s] vs [%s]",
-            handshake.version.c_str(), version.c_str());
-#ifdef HDC_CHECK_CHECK
-        hSession->availTailIndex = 0;
-        handshake.banner = HANDSHAKE_FAILED;
-        string failedString = SerialStruct::SerializeToString(handshake);
-        Send(hSession->sessionId, channelId, CMD_KERNEL_HANDSHAKE, (uint8_t *)failedString.c_str(),
-             failedString.size());
-        return false;
-#endif
-    }
-    if (handshake.version.empty()) {
-        handshake.version = Base::GetVersion();
-        WRITE_LOG(LOG_FATAL, "set version if check mode = %s", handshake.version.c_str());
-    }
-    // handshake auth OK.Can append the sending device information to HOST
-#ifdef HDC_DEBUG
-    WRITE_LOG(LOG_INFO, "session %u handshakeOK send back CMD_KERNEL_HANDSHAKE", hSession->sessionId);
-#endif
-    hSession->handshakeOK = true;
-    return true;
-}
-
-bool HdcDaemon::IsExpectedParam(const string& param, const string& expect)
-{
-    string out;
-    SystemDepend::GetDevItem(param.c_str(), out);
-    return (out.empty() || out == expect); // default empty
-}
-
-bool HdcDaemon::CheckControl(const uint16_t command)
-{
-    bool ret = false; // default no debug
-    switch (command) { // this switch is match RedirectToTask function
-        case CMD_UNITY_EXECUTE:
-        case CMD_UNITY_REMOUNT:
-        case CMD_UNITY_REBOOT:
-        case CMD_UNITY_RUNMODE:
-        case CMD_UNITY_HILOG:
-        case CMD_UNITY_ROOTRUN:
-        case CMD_UNITY_BUGREPORT_INIT:
-        case CMD_JDWP_LIST:
-        case CMD_JDWP_TRACK:
-        case CMD_SHELL_INIT:
-        case CMD_SHELL_DATA: {
-            ret = IsExpectedParam("persist.hdc.control.shell", "true");
-            break;
-        }
-        case CMD_FILE_CHECK:
-        case CMD_FILE_DATA:
-        case CMD_FILE_FINISH:
-        case CMD_FILE_INIT:
-        case CMD_FILE_BEGIN:
-        case CMD_FILE_MODE:
-        case CMD_DIR_MODE:
-        case CMD_APP_CHECK:
-        case CMD_APP_DATA:
-        case CMD_APP_UNINSTALL: {
-            ret = IsExpectedParam("persist.hdc.control.file", "true");
-            break;
-        }
-        case CMD_FORWARD_INIT:
-        case CMD_FORWARD_CHECK:
-        case CMD_FORWARD_ACTIVE_MASTER:
-        case CMD_FORWARD_ACTIVE_SLAVE:
-        case CMD_FORWARD_DATA:
-        case CMD_FORWARD_FREE_CONTEXT:
-        case CMD_FORWARD_CHECK_RESULT: {
-            ret = IsExpectedParam("persist.hdc.control.fport", "true");
-            break;
-        }
-        default:
-            ret = true; // other ECHO_RAW and so on
-    }
-    return ret;
-}
-
-bool HdcDaemon::FetchCommand(HSession hSession, const uint32_t channelId, const uint16_t command, uint8_t *payload,
-                             const int payloadSize)
-{
-    StartTraceScope("HdcDaemon::FetchCommand");
-    bool ret = true;
-    if (enableSecure && (GetSessionAuthStatus(hSession->sessionId) != AUTH_OK) &&
-        command != CMD_KERNEL_HANDSHAKE && command != CMD_KERNEL_CHANNEL_CLOSE) {
-        string authmsg = GetSessionAuthmsg(hSession->sessionId);
-        WRITE_LOG(LOG_WARN, "session %u auth failed: %s for command %u",
-                  hSession->sessionId, authmsg.c_str(), command);
-        if (!authmsg.empty()) {
-            LogMsg(hSession->sessionId, channelId, MSG_FAIL, authmsg.c_str());
-        }
-        uint8_t count = 1;
-        Send(hSession->sessionId, channelId, CMD_KERNEL_CHANNEL_CLOSE, &count, 1);
-        return true;
-    }
-    if (command != CMD_UNITY_BUGREPORT_DATA &&
-        command != CMD_SHELL_DATA &&
-        command != CMD_FORWARD_DATA &&
-        command != CMD_FILE_DATA &&
-        command != CMD_APP_DATA) {
-        WRITE_LOG(LOG_DEBUG, "FetchCommand channelId:%u command:%u", channelId, command);
-    }
-    switch (command) {
-        case CMD_KERNEL_HANDSHAKE: {
-            // session handshake step2
-            ret = DaemonSessionHandshake(hSession, channelId, payload, payloadSize);
-            break;
-        }
-        case CMD_KERNEL_CHANNEL_CLOSE: {  // Daemon is only cleaning up the Channel task
-            ClearOwnTasks(hSession, channelId);
-            if (*payload != 0) {
-                --(*payload);
-                Send(hSession->sessionId, channelId, CMD_KERNEL_CHANNEL_CLOSE, payload, 1);
-            }
-            ret = true;
-            break;
-        }
-        default:
-            ret = true;
-            if (CheckControl(command)) {
-                ret = DispatchTaskData(hSession, channelId, command, payload, payloadSize);
-            } else {
-                LogMsg(hSession->sessionId, channelId, MSG_FAIL, "debugging is not allowed");
-                uint8_t count = 1;
-                Send(hSession->sessionId, channelId, CMD_KERNEL_CHANNEL_CLOSE, &count, 1);
-            }
-            break;
-    }
-    return ret;
-}
-
-bool HdcDaemon::RemoveInstanceTask(const uint8_t op, HTaskInfo hTask)
-{
-    bool ret = true;
-
-    if (!hTask->taskClass) {
-        return ret;
-    }
-
-    switch (hTask->taskType) {
-        case TYPE_UNITY:
-            ret = DoTaskRemove<HdcDaemonUnity>(hTask, op);
-            break;
-        case TYPE_SHELL:
-            ret = DoTaskRemove<HdcShell>(hTask, op);
-            break;
-        case TASK_FILE:
-            ret = DoTaskRemove<HdcTransferBase>(hTask, op);
-            break;
-        case TASK_FORWARD:
-            ret = DoTaskRemove<HdcDaemonForward>(hTask, op);
-            break;
-        case TASK_APP:
-            ret = DoTaskRemove<HdcDaemonApp>(hTask, op);
-            break;
-        default:
-            ret = false;
-            break;
-    }
-    return ret;
-}
-
-bool HdcDaemon::ServerCommand(const uint32_t sessionId, const uint32_t channelId, const uint16_t command,
-                              uint8_t *bufPtr, const int size)
-{
-    return Send(sessionId, channelId, command, reinterpret_cast<uint8_t *>(bufPtr), size) > 0;
-}
-
-void HdcDaemon::JdwpNewFileDescriptor(const uint8_t *buf, const int bytesIO)
-{
-    uint8_t spcmd = *const_cast<uint8_t *>(buf);
-    if (spcmd == SP_JDWP_NEWFD) {
-        int cnt = sizeof(uint8_t) + sizeof(uint32_t) * 2;
-        if (bytesIO < cnt) {
-            WRITE_LOG(LOG_FATAL, "jdwp newfd data insufficient bytesIO:%d", bytesIO);
-            return;
-        }
-        uint32_t pid = *reinterpret_cast<uint32_t *>(const_cast<uint8_t *>(buf + 1));
-        uint32_t fd = *reinterpret_cast<uint32_t *>(const_cast<uint8_t *>(buf + 5));  // 5 : fd offset
-        ((HdcJdwp *)clsJdwp)->SendJdwpNewFD(pid, fd);
-    } else if (spcmd == SP_ARK_NEWFD) {
-        // SP_ARK_NEWFD | fd[1] | ark:pid@tid@Debugger
-        int cnt = sizeof(uint8_t) + sizeof(uint32_t);
-        if (bytesIO < cnt) {
-            WRITE_LOG(LOG_FATAL, "ark newfd data insufficient bytesIO:%d", bytesIO);
-            return;
-        }
-        int32_t fd = *reinterpret_cast<int32_t *>(const_cast<uint8_t *>(buf + 1));
-        std::string arkstr = std::string(
-            reinterpret_cast<char *>(const_cast<uint8_t *>(buf + 5)), bytesIO - 5);  // 5 : fd offset
-        WRITE_LOG(LOG_DEBUG, "JdwpNewFileDescriptor arkstr:%s fd:%d", arkstr.c_str(), fd);
-        ((HdcJdwp *)clsJdwp)->SendArkNewFD(arkstr, fd);
-    }
-}
-
-void HdcDaemon::NotifyInstanceSessionFree(HSession hSession, bool freeOrClear)
-{
-    if (!freeOrClear) {
-        WRITE_LOG(LOG_WARN, "NotifyInstanceSessionFree freeOrClear false");
-        return;  // ignore step 1
-    }
-    if (clsUSBServ != nullptr) {
-        auto clsUsbModule = reinterpret_cast<HdcDaemonUSB *>(clsUSBServ);
-        clsUsbModule->OnSessionFreeFinally(hSession);
-    }
-}
-
-void HdcDaemon::InitSessionAuthInfo(uint32_t sessionid, string token)
-{
-    HdcDaemonAuthInfo info = {
-        AUTH_NONE,
-        token
-    };
-    mapAuthStatusMutex.lock();
-    mapAuthStatus[sessionid] = info;
-    mapAuthStatusMutex.unlock();
-}
-void HdcDaemon::UpdateSessionAuthOk(uint32_t sessionid)
-{
-    HdcDaemonAuthInfo info;
-    mapAuthStatusMutex.lock();
-    info = mapAuthStatus[sessionid];
-    info.authtype = AUTH_OK;
-    info.token = "";
-    info.pubkey = "";
-    mapAuthStatus[sessionid] = info;
-    mapAuthStatusMutex.unlock();
-}
-void HdcDaemon::UpdateSessionAuthPubkey(uint32_t sessionid, string pubkey)
-{
-    HdcDaemonAuthInfo info;
-    mapAuthStatusMutex.lock();
-    info = mapAuthStatus[sessionid];
-    info.authtype = AUTH_PUBLICKEY;
-    info.pubkey = pubkey;
-    mapAuthStatus[sessionid] = info;
-    mapAuthStatusMutex.unlock();
-}
-void HdcDaemon::UpdateSessionAuthmsg(uint32_t sessionid, string authmsg)
-{
-    HdcDaemonAuthInfo info;
-    mapAuthStatusMutex.lock();
-    info = mapAuthStatus[sessionid];
-    info.authtype = AUTH_FAIL;
-    info.authmsg = authmsg;
-    mapAuthStatus[sessionid] = info;
-    mapAuthStatusMutex.unlock();
-}
-void HdcDaemon::DeleteSessionAuthStatus(uint32_t sessionid)
-{
-    mapAuthStatusMutex.lock();
-    mapAuthStatus.erase(sessionid);
-    mapAuthStatusMutex.unlock();
-}
-HdcSessionBase::AuthType HdcDaemon::GetSessionAuthStatus(uint32_t sessionid)
-{
-    HdcDaemonAuthInfo info;
-
-    mapAuthStatusMutex.lock();
-    info = mapAuthStatus[sessionid];
-    mapAuthStatusMutex.unlock();
-
-    return info.authtype;
-}
-string HdcDaemon::GetSessionAuthToken(uint32_t sessionid)
-{
-    HdcDaemonAuthInfo info;
-
-    mapAuthStatusMutex.lock();
-    info = mapAuthStatus[sessionid];
-    mapAuthStatusMutex.unlock();
-
-    return info.token;
-}
-string HdcDaemon::GetSessionAuthPubkey(uint32_t sessionid)
-{
-    HdcDaemonAuthInfo info;
-
-    mapAuthStatusMutex.lock();
-    info = mapAuthStatus[sessionid];
-    mapAuthStatusMutex.unlock();
-
-    return info.pubkey;
-}
-string HdcDaemon::GetSessionAuthmsg(uint32_t sessionid)
-{
-    HdcDaemonAuthInfo info;
-
-    mapAuthStatusMutex.lock();
-    info = mapAuthStatus[sessionid];
-    mapAuthStatusMutex.unlock();
-
-    return info.authmsg;
-}
-void HdcDaemon::SendAuthOkMsg(SessionHandShake &handshake, uint32_t channelid,
-                              uint32_t sessionid, string msg, string daemonAuthResult)
-{
-    char hostname[BUF_SIZE_MEDIUM] = { 0 };
-    if (gethostname(hostname, BUF_SIZE_MEDIUM) != 0) {
-        WRITE_LOG(LOG_FATAL, "get hostname failed %s", strerror(errno));
-    }
-    if (handshake.version < "Ver: 3.0.0b") {
-        if (msg.empty()) {
-            msg = hostname;
-        }
-        handshake.buf = msg;
-    } else {
-        string emgmsg;
-        Base::TlvAppend(emgmsg, TAG_EMGMSG, msg);
-        Base::TlvAppend(emgmsg, TAG_DEVNAME, hostname);
-        Base::TlvAppend(emgmsg, TAG_DAEOMN_AUTHSTATUS, daemonAuthResult);
-        handshake.buf = emgmsg;
-    }
-
-    handshake.authType = AUTH_OK;
-    string bufString = SerialStruct::SerializeToString(handshake);
-    Send(sessionid, channelid, CMD_KERNEL_HANDSHAKE,
-            reinterpret_cast<uint8_t *>(const_cast<char *>(bufString.c_str())), bufString.size());
-    uint8_t count = 1;
-    Send(sessionid, channelid, CMD_KERNEL_CHANNEL_CLOSE, &count, 1);
-}
-void HdcDaemon::SendAuthSignMsg(SessionHandShake &handshake,
-        uint32_t channelId, uint32_t sessionid, string pubkey, string token)
-{
-    UpdateSessionAuthPubkey(sessionid, pubkey);
-    handshake.authType = AUTH_SIGNATURE;
-    handshake.buf = token;
-    string bufString = SerialStruct::SerializeToString(handshake);
-    Send(sessionid, channelId, CMD_KERNEL_HANDSHAKE,
-            reinterpret_cast<uint8_t *>(const_cast<char *>(bufString.c_str())), bufString.size());
-}
-void HdcDaemon::EchoHandshakeMsg(SessionHandShake &handshake, uint32_t channelid, uint32_t sessionid, string msg)
-{
-    SendAuthOkMsg(handshake, channelid, sessionid, msg, DAEOMN_UNAUTHORIZED);
-    LogMsg(sessionid, channelid, MSG_FAIL, msg.c_str());
-    UpdateSessionAuthmsg(sessionid, msg);
-}
-void HdcDaemon::AuthRejectLowClient(SessionHandShake &handshake, uint32_t channelid, uint32_t sessionid)
-{
-    string msg = "[E000001]:The sdk hdc.exe version is too low, please upgrade to the latest version.";
-    EchoHandshakeMsg(handshake, channelid, sessionid, msg);
-}
-}  // namespace Hdc
diff --git a/hdc/src/daemon/daemon.h b/hdc/src/daemon/daemon.h
deleted file mode 100644
index 180aca9..0000000
--- a/hdc/src/daemon/daemon.h
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_DAEMON_H
-#define HDC_DAEMON_H
-#include "daemon_common.h"
-#include "openssl/pem.h"
-
-namespace Hdc {
-enum UserPermit {
-    REFUSE = 0,
-    ALLOWONCE = 1,
-    ALLOWFORVER = 2,
-};
-struct HdcDaemonAuthInfo {
-    HdcSessionBase::AuthType authtype;
-    string token;
-    string pubkey;
-    string authmsg;
-};
-class HdcDaemon : public HdcSessionBase {
-public:
-#ifdef USE_CONFIG_UV_THREADS
-    HdcDaemon(bool serverOrDaemonIn, size_t uvThreadSize = SIZE_THREAD_POOL);
-#else
-    HdcDaemon(bool serverOrDaemonIn);
-#endif
-    virtual ~HdcDaemon();
-#ifdef HDC_SUPPORT_UART
-#ifdef HDC_EMULATOR
-    void InitMod(bool bEnableTCP, bool bEnableUSB, bool bEnableBridge, bool bEnableUART);
-#endif
-    void InitMod(bool bEnableTCP, bool bEnableUSB, bool bEnableUART);
-#else
-#ifdef HDC_EMULATOR
-    void InitMod(bool bEnableTCP, bool bEnableUSB, bool bEnableBridge);
-#endif
-    void InitMod(bool bEnableTCP, bool bEnableUSB);
-#endif
-    bool FetchCommand(HSession hSession, const uint32_t channelId, const uint16_t command, uint8_t *payload,
-                      const int payloadSize) override;
-    bool ServerCommand(const uint32_t sessionId, const uint32_t channelId, const uint16_t command, uint8_t *bufPtr,
-                       const int size) override;
-    void ClearKnownHosts();
-    void *clsTCPServ;
-    void *clsUSBServ;
-#ifdef HDC_EMULATOR
-    void *clsBridgeServ;
-#endif
-#ifdef HDC_SUPPORT_UART
-    void *clsUARTServ;
-#endif
-    void *clsJdwp;
-
-private:
-    bool RemoveInstanceTask(const uint8_t op, HTaskInfo hTask) override;
-    bool RedirectToTask(HTaskInfo hTaskInfo, HSession hSession, const uint32_t channelId, const uint16_t command,
-                        uint8_t *payload, const int payloadSize) override;
-    void JdwpNewFileDescriptor(const uint8_t *buf, const int bytesIO) override;
-    static bool CheckControl(const uint16_t command);
-    static bool IsExpectedParam(const std::string& param, const std::string& expect);
-    bool HandDaemonAuth(HSession hSession, const uint32_t channelId, SessionHandShake &handshake);
-    bool GetHostPubkeyInfo(const string& buf, string& hostname, string& pubkey);
-    bool AlreadyInKnownHosts(const string& key);
-    void UpdateKnownHosts(const string& key);
-    void ClearInstanceResource() override;
-    void DaemonSessionHandshakeInit(HSession &hSession, SessionHandShake &handshake);
-    void GetServerCapability(HSession &hSession, SessionHandShake &handshake);
-    bool DaemonSessionHandshake(HSession hSession, const uint32_t channelId, uint8_t *payload, int payloadSize);
-    void TryStopInstance();
-    UserPermit PostUIConfirm(string hostname, string pubkey);
-    bool ShowPermitDialog();
-    bool HandDaemonAuthInit(HSession hSession, const uint32_t channelId, SessionHandShake &handshake);
-    bool HandDaemonAuthPubkey(HSession hSession, const uint32_t channelId, SessionHandShake &handshake);
-    bool HandDaemonAuthSignature(HSession hSession, const uint32_t channelId, SessionHandShake &handshake);
-// deprecated, remove later
-#ifdef HDC_SUPPORT_FLASHD
-// null
-#else
-    void NotifyInstanceSessionFree(HSession hSession, bool freeOrClear) override;
-#endif
-
-    bool HandDaemonAuthBypass(void);
-    void SendAuthSignMsg(SessionHandShake &handshake,
-            uint32_t channelId, uint32_t sessionid, string pubkey, string token);
-    void SendAuthOkMsg(SessionHandShake &handshake, uint32_t channelid,
-                       uint32_t sessionid, string msg = "", string daemonAuthResult = DAEOMN_AUTH_SUCCESS);
-    void AuthRejectLowClient(SessionHandShake &handshake, uint32_t channelid, uint32_t sessionid);
-    void EchoHandshakeMsg(SessionHandShake &handshake, uint32_t channelid, uint32_t sessionid, string msg);
-    bool AuthVerify(HSession hSession, const string &encryptToken, const string &token, const string &pubkey);
-    bool AuthVerifyRsaSign(HSession hSession, const string &tokenSignBase64, const string &token, RSA *rsa);
-    bool RsaSignVerify(HSession hSession, EVP_PKEY_CTX *ctx, const string &tokenSignBase64, const string &token);
-    bool AuthVerifyRsa(HSession hSession, const string &encryptToken, const string &token, RSA *rsa);
-    void InitSessionAuthInfo(uint32_t sessionid, string token);
-    void UpdateSessionAuthOk(uint32_t sessionid);
-    void UpdateSessionAuthmsg(uint32_t sessionid, string authmsg);
-    void UpdateSessionAuthPubkey(uint32_t sessionid, string pubkey);
-    void DeleteSessionAuthStatus(uint32_t sessionid);
-    AuthType GetSessionAuthStatus(uint32_t sessionid);
-    string GetSessionAuthmsg(uint32_t sessionid);
-    string GetSessionAuthToken(uint32_t sessionid);
-    string GetSessionAuthPubkey(uint32_t sessionid);
-    std::map<uint32_t, HdcDaemonAuthInfo> mapAuthStatus;
-    std::mutex mapAuthStatusMutex;
-    bool enableSecure;
-};
-}  // namespace Hdc
-#endif
diff --git a/hdc/src/daemon/daemon_app.cpp b/hdc/src/daemon/daemon_app.cpp
deleted file mode 100644
index 557e904..0000000
--- a/hdc/src/daemon/daemon_app.cpp
+++ /dev/null
@@ -1,271 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "daemon_app.h"
-#include "decompress.h"
-
-namespace Hdc {
-HdcDaemonApp::HdcDaemonApp(HTaskInfo hTaskInfo)
-    : HdcTransferBase(hTaskInfo)
-{
-    commandBegin = CMD_APP_BEGIN;
-    commandData = CMD_APP_DATA;
-    funcAppModFinish = nullptr;
-}
-
-HdcDaemonApp::~HdcDaemonApp()
-{
-    WRITE_LOG(LOG_INFO, "~HdcDaemonApp channelId:%u", taskInfo->channelId);
-}
-
-bool HdcDaemonApp::ReadyForRelease()
-{
-    if (!HdcTaskBase::ReadyForRelease()) {
-        WRITE_LOG(LOG_WARN, "HdcTaskBase not ready for release channelId:%u", taskInfo->channelId);
-        return false;
-    }
-    if (!asyncCommand.ReadyForRelease()) {
-        WRITE_LOG(LOG_WARN, "asyncCommand not ready for release channelId:%u", taskInfo->channelId);
-        return false;
-    }
-    WRITE_LOG(LOG_INFO, "ReadyForRelease channelId:%u", taskInfo->channelId);
-    return true;
-}
-
-bool HdcDaemonApp::CommandDispatch(const uint16_t command, uint8_t *payload, const int payloadSize)
-{
-    if (!HdcTransferBase::CommandDispatch(command, payload, payloadSize)) {
-        WRITE_LOG(LOG_WARN, "HdcTransferBase::CommandDispatch false command:%u channelId:%u",
-            command, taskInfo->channelId);
-        return false;
-    }
-    bool ret = true;
-    switch (command) {
-        case CMD_APP_CHECK: {
-            string dstPath = "/data/local/tmp/";
-            string bufString(reinterpret_cast<char *>(payload), payloadSize);
-            SerialStruct::ParseFromString(ctxNow.transferConfig, bufString);
-            // update transferconfig to main context
-            ctxNow.master = false;
-            ctxNow.fsOpenReq.data = &ctxNow;
-#ifdef HDC_PCDEBUG
-            char tmpPath[256] = "";
-            size_t size = 256;
-            uv_os_tmpdir(tmpPath, &size);
-            dstPath = tmpPath;
-            dstPath += Base::GetPathSep();
-#endif
-            dstPath += ctxNow.transferConfig.optionalName;
-            ctxNow.localPath = dstPath;
-            ctxNow.transferBegin = Base::GetRuntimeMSec();
-            ctxNow.fileSize = ctxNow.transferConfig.fileSize;
-            ++refCount;
-            uv_fs_open(loopTask, &ctxNow.fsOpenReq, ctxNow.localPath.c_str(),
-                       UV_FS_O_TRUNC | UV_FS_O_CREAT | UV_FS_O_WRONLY, S_IWUSR | S_IRUSR | S_IRGRP | S_IROTH,
-                       OnFileOpen);
-            break;
-        }
-        case CMD_APP_UNINSTALL: {
-            // This maybe has a command implanting risk, since it is a controllable device, it can be ignored
-            string bufString(reinterpret_cast<char *>(payload), payloadSize);
-            string options = "";
-            string packages = "";
-            vector<string> segments;
-            Base::SplitString(bufString, " ", segments);
-            for (auto seg: segments) {
-                if (seg[0] == '-') {
-                    options += " " + seg;
-                } else {
-                    packages += " " + seg;
-                }
-            }
-            PackageShell(false, options.c_str(), packages);
-            break;
-        }
-        default:
-            break;
-    }
-    return ret;
-};
-
-bool HdcDaemonApp::AsyncInstallFinish(bool finish, int64_t exitStatus, const string result)
-{
-    if (mode == APPMOD_INSTALL) {
-        unlink(ctxNow.localPath.c_str());
-        string::size_type rindex = ctxNow.localPath.rfind(".tar");
-        if (rindex != string::npos) {
-            string dir = ctxNow.localPath.substr(0, rindex);
-            RemovePath(dir);
-            WRITE_LOG(LOG_DEBUG, "RemovePath dir:%s", dir.c_str());
-        }
-    }
-    asyncCommand.DoRelease();
-    string echo = result;
-    echo = Base::ReplaceAll(echo, "\n", " ");
-    vector<uint8_t> vecBuf;
-    vecBuf.push_back(mode);
-    vecBuf.push_back(exitStatus == 0);
-    vecBuf.insert(vecBuf.end(), (uint8_t *)echo.c_str(), (uint8_t *)echo.c_str() + echo.size());
-    SendToAnother(CMD_APP_FINISH, vecBuf.data(), vecBuf.size());
-    --refCount;
-#ifdef UNIT_TEST
-    Base::WriteBinFile((UT_TMP_PATH + "/appinstall.result").c_str(), (uint8_t *)MESSAGE_SUCCESS.c_str(),
-                       MESSAGE_SUCCESS.size(), true);
-#endif
-    return true;
-}
-
-void HdcDaemonApp::PackageShell(bool installOrUninstall, const char *options, const string package)
-{
-    ++refCount;
-    // asynccmd Other processes, no RunningProtect protection
-    chmod(package.c_str(), 0755);
-    string doBuf;
-    string opts = string(options);
-    if (installOrUninstall) { // either -p or -s is always required in install
-        if (opts.find("p") == string::npos && opts.find("s") == string::npos) {
-            // basic mode: blank options or both "-s" / "-p" are omitted
-            // eg. hdc install x.hap --> bm install -p x.hap
-            // eg. hdc install -r x.hap --> bm install -r -p x.hap
-            doBuf = Base::StringFormat("bm install %s -p %s", options, package.c_str());
-        } else {
-            // advansed mode for -p/-r/-s and some other options in the future
-            doBuf = Base::StringFormat("bm install %s %s", options, package.c_str());
-        }
-    } else {  // -n is always required in uninstall
-        if (opts.find("n") == string::npos) {
-            // basic mode: blank options or "-n" is omitted
-            // eg. hdc uninstall com.xx.xx --> bm uninstall -n com.xx.xx
-            // eg. hdc uninstall -s com.xx.xx --> bm uninstall -s -n com.xx.xx
-            doBuf = Base::StringFormat("bm uninstall %s -n %s", options, package.c_str());
-        } else {
-            // advansed mode for -s/-n and some other options in the future
-            doBuf = Base::StringFormat("bm uninstall %s %s", options, package.c_str());
-        }
-    }
-
-    funcAppModFinish = [this](bool finish, int64_t exitStatus, const string result) -> bool {
-        return this->AsyncInstallFinish(finish, exitStatus, result);
-    };
-    if (installOrUninstall) {
-        mode = APPMOD_INSTALL;
-    } else {
-        mode = APPMOD_UNINSTALL;
-    }
-    asyncCommand.Initial(loopTask, funcAppModFinish, AsyncCmd::OPTION_COMMAND_ONETIME);
-    asyncCommand.ExecuteCommand(doBuf);
-}
-
-void HdcDaemonApp::Sideload(const char *pathOTA)
-{
-    mode = APPMOD_SIDELOAD;
-    LogMsg(MSG_OK, "[placeholders] sideload %s", pathOTA);
-    TaskFinish();
-    unlink(pathOTA);
-}
-
-string HdcDaemonApp::Tar2Dir(const char *path)
-{
-    string dir;
-    string tarpath = path;
-    string::size_type rindex = tarpath.rfind(".tar");
-    if (rindex != string::npos) {
-        dir = tarpath.substr(0, rindex) + Base::GetPathSep();
-        WRITE_LOG(LOG_DEBUG, "path:%s dir:%s", path, dir.c_str());
-        Decompress dc(tarpath);
-        dc.DecompressToLocal(dir);
-    }
-    return dir;
-}
-
-int HdcDaemonApp::RemoveDir(const string &dir)
-{
-    DIR *pdir = opendir(dir.c_str());
-    if (pdir == nullptr) {
-        WRITE_LOG(LOG_FATAL, "opendir failed dir:%s", dir.c_str());
-        return -1;
-    }
-    struct dirent *ent;
-    struct stat st;
-    while ((ent = readdir(pdir)) != nullptr) {
-        if (ent->d_name[0] == '.') {
-            continue;
-        }
-        std::string subpath = dir + Base::GetPathSep() + ent->d_name;
-        if (lstat(subpath.c_str(), &st) == -1) {
-            WRITE_LOG(LOG_WARN, "lstat failed subpath:%s", subpath.c_str());
-            continue;
-        }
-        if (S_ISDIR(st.st_mode)) {
-            if (RemoveDir(subpath) == -1) {
-                closedir(pdir);
-                return -1;
-            }
-            rmdir(subpath.c_str());
-        } else if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) {
-            unlink(subpath.c_str());
-        } else {
-            WRITE_LOG(LOG_DEBUG, "lstat st_mode:%07o subpath:%s", st.st_mode, subpath.c_str());
-        }
-    }
-    if (rmdir(dir.c_str()) == -1) {
-        closedir(pdir);
-        return -1;
-    }
-    closedir(pdir);
-    return 0;
-}
-
-void HdcDaemonApp::RemovePath(const string &path)
-{
-    struct stat st;
-    if (lstat(path.c_str(), &st) == -1) {
-        WRITE_LOG(LOG_WARN, "lstat failed path:%s", path.c_str());
-        return;
-    }
-    if (S_ISREG(st.st_mode) || S_ISLNK(st.st_mode)) {
-        unlink(path.c_str());
-    } else if (S_ISDIR(st.st_mode)) {
-        if (path == "." || path == "..") {
-            return;
-        }
-        int rc = RemoveDir(path);
-        WRITE_LOG(LOG_INFO, "RemoveDir rc:%d path:%s", rc, path.c_str());
-    }
-}
-
-void HdcDaemonApp::WhenTransferFinish(CtxFile *context)
-{
-    if (context->lastErrno > 0) {
-        constexpr int bufSize = 1024;
-        char buf[bufSize] = { 0 };
-        uv_strerror_r(static_cast<int>(-context->lastErrno), buf, bufSize);
-        WRITE_LOG(LOG_DEBUG, "HdcDaemonApp WhenTransferFinish with errno:%d", context->lastErrno);
-        LogMsg(MSG_FAIL, "Transfer App at:%lld/%lld(Bytes), Reason: %s",
-               context->indexIO, context->fileSize, buf);
-        return;
-    }
-    if (ctxNow.transferConfig.functionName == CMDSTR_APP_SIDELOAD) {
-        Sideload(context->localPath.c_str());
-    } else if (ctxNow.transferConfig.functionName == CMDSTR_APP_INSTALL) {
-        string dir = Tar2Dir(context->localPath.c_str());
-        if (!dir.empty()) {
-            PackageShell(true, context->transferConfig.options.c_str(), dir.c_str());
-        } else {
-            PackageShell(true, context->transferConfig.options.c_str(), context->localPath.c_str());
-        }
-    } else {
-    }
-};
-}
diff --git a/hdc/src/daemon/daemon_app.h b/hdc/src/daemon/daemon_app.h
deleted file mode 100644
index 317230b..0000000
--- a/hdc/src/daemon/daemon_app.h
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_DAEMON_APP_H
-#define HDC_DAEMON_APP_H
-#include "daemon_common.h"
-
-namespace Hdc {
-class HdcDaemonApp : public HdcTransferBase {
-public:
-    HdcDaemonApp(HTaskInfo hTaskInfo);
-    virtual ~HdcDaemonApp();
-    bool CommandDispatch(const uint16_t command, uint8_t *payload, const int payloadSize) override;
-    bool ReadyForRelease() override;
-
-private:
-    void WhenTransferFinish(CtxFile *context) override;
-    void PackageShell(bool installOrUninstall, const char *options, const string package);
-    bool AsyncInstallFinish(bool finish, int64_t exitStatus, const string result);
-    void Sideload(const char *pathOTA);
-    string Tar2Dir(const char *path);
-    int RemoveDir(const string &dir);
-    void RemovePath(const string &path);
-
-    AsyncCmd asyncCommand;
-    AsyncCmd::CmdResultCallback funcAppModFinish;
-    AppModType mode = APPMOD_NONE;
-};
-}  // namespace Hdc
-#endif
diff --git a/hdc/src/daemon/daemon_bridge.cpp b/hdc/src/daemon/daemon_bridge.cpp
deleted file mode 100644
index 6697fbf..0000000
--- a/hdc/src/daemon/daemon_bridge.cpp
+++ /dev/null
@@ -1,147 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "daemon_bridge.h"
-#include <cstdlib>
-#include "arpa/inet.h"
-#include "netinet/in.h"
-#include "new"
-#include "sys/socket.h"
-#include "system_depend.h"
-#include "unistd.h"
-#include "common.h"
-#include "session.h"
-#include "uv-common.h"
-
-namespace Hdc {
-    HdcDaemonBridge::HdcDaemonBridge(const bool serverOrDaemonIn, void *ptrMainBase)
-        : HdcTCPBase(serverOrDaemonIn, ptrMainBase)
-    {
-        // If the listening value for the property setting is obtained, it will be 0 randomly assigned.
-        string strBridgePort;
-        SystemDepend::GetDevItem("persist.hdc.port", strBridgePort);
-        bridgeListenPort = atoi(strBridgePort.c_str());
-        if (bridgeListenPort <= 0) {
-            bridgeListenPort = 0;
-        }
-#ifdef HDC_DEBUG
-        const uint16_t DEBUG_TCP_PORT = 10178;
-        bridgeListenPort = DEBUG_TCP_PORT;
-#endif
-    }
-
-    HdcDaemonBridge::~HdcDaemonBridge()
-    {
-    }
-
-    void HdcDaemonBridge::Stop()
-    {
-        Base::TryCloseHandle((const uv_handle_t *)&servPipe);
-        WRITE_LOG(LOG_DEBUG, "~HdcDaemonBridge");
-    }
-
-    void HdcDaemonBridge::AllocBufferCallback(uv_handle_t *handle, size_t sizeSuggested, uv_buf_t *buf)
-    {
-        buf->base = (char *)new int[1];
-        buf->len = SOCKET_FD_LEN;
-    }
-
-    void HdcDaemonBridge::AcceptClient(uv_stream_t *uvpipe, ssize_t nread, const uv_buf_t *buf)
-    {
-        WRITE_LOG(LOG_DEBUG, "Accept New Client");
-        uv_loop_t *ptrLoop = uvpipe->loop;
-        uv_tcp_t *pServBridge = (uv_tcp_t *)uvpipe;
-        HdcDaemonBridge *thisClass = (HdcDaemonBridge *)pServBridge->data;
-        HdcSessionBase *ptrConnect = reinterpret_cast<HdcSessionBase *>(thisClass->clsMainBase);
-        const uint16_t maxWaitTime = UV_DEFAULT_INTERVAL;
-        int newPort = *(int *)buf->base;
-        int newClientFd;
-        int ret = 0;
-        if (nread != SOCKET_FD_LEN) {
-            WRITE_LOG(LOG_FATAL, "AcceptClient err nread %d", nread);
-            return;
-        }
-        auto ctrl = ptrConnect->BuildCtrlString(SP_START_SESSION, 0, nullptr, 0);
-        HSession hSession = ptrConnect->MallocSession(false, CONN_TCP, thisClass);
-        if (!hSession) {
-            goto freeBuf;
-        }
-
-        newClientFd = open("/dev/express_bridge", O_RDWR | O_NONBLOCK);
-        if (newClientFd < 0) {
-            WRITE_LOG(LOG_FATAL, "Unable to open new bridge connection err %d", errno);
-            goto freeSession;
-        }
-        ret = ioctl(newClientFd, IOC_CONNECT, static_cast<unsigned long>(newPort));
-        if (ret < 0) {
-            WRITE_LOG(LOG_FATAL, "Unable to ioctl new bridge err %d", errno);
-            goto freeFd;
-        }
-        hSession->fdChildWorkTCP = (uv_os_sock_t)newClientFd;
-        Base::StartWorkThread(ptrLoop, ptrConnect->SessionWorkThread, Base::FinishWorkThread, hSession);
-        // wait for thread up
-        while (hSession->childLoop.active_handles == 0) {
-            WRITE_LOG(LOG_DEBUG, "wait for thread up");
-            usleep(maxWaitTime);
-        }
-        Base::SendToPollFd(hSession->ctrlFd[STREAM_MAIN], ctrl.data(), ctrl.size());
-        goto freeBuf;
-
-    freeFd:
-        close(newClientFd);
-    freeSession:
-        ptrConnect->FreeSession(hSession->sessionId);
-    freeBuf:
-        delete[] buf->base;
-        return;
-    }
-
-    // Set the daemon-side TCP listening
-    int HdcDaemonBridge::SetBridgeListen()
-    {
-        // tcp listen
-        HdcSessionBase *ptrConnect = (HdcSessionBase *)clsMainBase;
-        servPipe.data = this;
-        int bridgeFd = open("/dev/express_bridge", O_RDWR | O_NONBLOCK);
-        if (bridgeFd <= 0) {
-            WRITE_LOG(LOG_FATAL, "SetBridgeListen open failed");
-            return ERR_FILE_OPEN;
-        }
-        int ret = ioctl(bridgeFd, IOC_BIND, (unsigned long)bridgeListenPort);
-        if (ret < 0) {
-            WRITE_LOG(LOG_FATAL, "SetBridgeListen IOC_BIND failed");
-            close(bridgeFd);
-            return ERR_API_FAIL;
-        }
-
-        uv_pipe_init(&ptrConnect->loopMain, &servPipe, 0);
-        uv_pipe_open(&servPipe, (uv_file)bridgeFd);
-        uv_read_start((uv_stream_t *)&servPipe, HdcDaemonBridge::AllocBufferCallback, HdcDaemonBridge::AcceptClient);
-
-        return RET_SUCCESS;
-    }
-
-    int HdcDaemonBridge::Initial()
-    {
-        WRITE_LOG(LOG_DEBUG, "HdcDaemonBridge init");
-        if (SetBridgeListen() != RET_SUCCESS) {
-            WRITE_LOG(LOG_FATAL, "Bridge listen failed");
-            return ERR_GENERIC;
-        }
-#ifndef UNIT_TEST
-        WRITE_LOG(LOG_INFO, "Bridge listen on port:[%d]", bridgeListenPort);
-#endif
-        return RET_SUCCESS;
-    }
-} // namespace Hdc
diff --git a/hdc/src/daemon/daemon_bridge.h b/hdc/src/daemon/daemon_bridge.h
deleted file mode 100644
index 913bb3e..0000000
--- a/hdc/src/daemon/daemon_bridge.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_DAEMON_BRIDGE_H
-#define HDC_DAEMON_BRIDGE_H
-#include <cstdint>
-#include "uv.h"
-#include "uv/unix.h"
-#include "tcp.h"
-#include <linux/ioctl.h>
-#include <sys/ioctl.h>
-
-#define IOC_MAGIC 0xE6
-
-#define IOC_BIND _IOW(IOC_MAGIC, 1, int)
-#define IOC_CONNECT _IOW(IOC_MAGIC, 2, int)
-
-#define SOCKET_FD_LEN 4
-
-namespace Hdc {
-class HdcDaemonBridge : public HdcTCPBase {
-public:
-    HdcDaemonBridge(const bool serverOrDaemonIn, void *ptrMainBase);
-    ~HdcDaemonBridge() override;
-    uint16_t bridgeListenPort;
-    int Initial();
-    void Stop();
-
-private:
-    static void AllocBufferCallback(uv_handle_t *handle, size_t sizeSuggested, uv_buf_t *buf);
-    static void AcceptClient(uv_stream_t *uvpipe, ssize_t nread, const uv_buf_t *buf);
-    int SetBridgeListen();
-    uv_pipe_t servPipe = {};
-};
-}  // namespace Hdc
-
-#endif
diff --git a/hdc/src/daemon/daemon_common.h b/hdc/src/daemon/daemon_common.h
deleted file mode 100644
index 5b1769a..0000000
--- a/hdc/src/daemon/daemon_common.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_DAEMON_COMMON_H
-#define HDC_DAEMON_COMMON_H
-
-// clang-format off
-#include "common.h"
-#include "define.h"
-#include "file.h"
-#include "forward.h"
-#include "async_cmd.h"
-#include "serial_struct.h"
-
-#ifndef HDC_HOST // daemon used
-#include "system_depend.h"
-#include "jdwp.h"
-#include "daemon.h"
-#include "daemon_unity.h"
-#include "daemon_tcp.h"
-#include "daemon_app.h"
-#include "daemon_usb.h"
-#include "daemon_bridge.h"
-#ifdef HDC_SUPPORT_UART
-#include "daemon_uart.h"
-#endif
-#include "daemon_forward.h"
-#include "shell.h"
-#endif
-// clang-format on
-
-namespace Hdc {
-}
-#endif
\ No newline at end of file
diff --git a/hdc/src/daemon/daemon_forward.cpp b/hdc/src/daemon/daemon_forward.cpp
deleted file mode 100644
index 94e6783..0000000
--- a/hdc/src/daemon/daemon_forward.cpp
+++ /dev/null
@@ -1,137 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "daemon_forward.h"
-#include <cstdint>
-#include "securec.h"
-#include "daemon.h"
-#include "jdwp.h"
-
-namespace Hdc {
-HdcDaemonForward::HdcDaemonForward(HTaskInfo hTaskInfo)
-    : HdcForwardBase(hTaskInfo)
-{
-}
-
-HdcDaemonForward::~HdcDaemonForward()
-{
-}
-
-void HdcDaemonForward::SetupJdwpPointCallBack(uv_idle_t *handle)
-{
-    HCtxForward ctxPoint = (HCtxForward)handle->data;
-    uint32_t id = ctxPoint->id;
-    HdcDaemonForward *thisClass = reinterpret_cast<HdcDaemonForward *>(ctxPoint->thisClass);
-    thisClass->SetupPointContinue(ctxPoint, 1);  // It usually works
-    Base::TryCloseHandle((const uv_handle_t *)handle, Base::CloseIdleCallback);
-    --thisClass->refCount;
-    WRITE_LOG(LOG_DEBUG, "SetupJdwpPointCallBack finish id:%u", id);
-    return;
-}
-
-bool HdcDaemonForward::SetupJdwpPoint(HCtxForward ctxPoint)
-{
-    HdcDaemon *daemon = (HdcDaemon *)taskInfo->ownerSessionClass;
-    HdcJdwp *clsJdwp = (HdcJdwp *)daemon->clsJdwp;
-    uint32_t pid = std::stol(ctxPoint->localArgs[1]);
-    if (ctxPoint->checkPoint) {
-        uint32_t id = ctxPoint->id;
-        bool ret = clsJdwp->CheckPIDExist(pid);
-        SetupPointContinue(ctxPoint, (int)ret);
-        WRITE_LOG(LOG_DEBUG, "Jdwp jump checkpoint id:%u", id);
-        return true;
-    }
-    // do slave connect
-    // fd[0] for forward, fd[1] for jdwp
-    // forward to close fd[0], fd[1] for jdwp close
-    int fds[2] = { 0 };
-    bool ret = false;
-    Base::CreateSocketPair(fds);
-    if (uv_tcp_init(loopTask, &ctxPoint->tcp)) {
-        return ret;
-    }
-    ctxPoint->tcp.data = ctxPoint;
-    if (uv_tcp_open(&ctxPoint->tcp, fds[0])) {
-        return ret;
-    }
-    constexpr auto len = sizeof(uint32_t);
-    uint8_t flag[1 + len + len];
-    flag[0] = SP_JDWP_NEWFD;
-    if (memcpy_s(flag + 1, sizeof(flag) - 1, &pid, len) ||
-        memcpy_s(flag + 1 + len, sizeof(flag) - len - 1, &fds[1], len)) {
-        return ret;
-    }
-    if (ThreadCtrlCommunicate(flag, sizeof(flag)) > 0) {
-        ret = true;
-    }
-    WRITE_LOG(LOG_DEBUG, "SendJdwpNewFD Finish,ret:%d fd0:%d fd1:%d", ret, fds[0], fds[1]);
-    if (!ret) {
-        Base::CloseSocketPair(fds);
-        return ret;
-    }
-
-    ++refCount;
-    Base::IdleUvTask(loopTask, ctxPoint, SetupJdwpPointCallBack);
-    return ret;
-}
-
-bool HdcDaemonForward::SetupArkPoint(HCtxForward ctxPoint)
-{
-    HdcDaemon *daemon = (HdcDaemon *)taskInfo->ownerSessionClass;
-    HdcJdwp *clsJdwp = (HdcJdwp *)daemon->clsJdwp;
-    std::string ark = ctxPoint->localArgs[0]; // ark
-    std::string svr = ctxPoint->localArgs[1]; // pid@tid@Debugger
-    std::size_t found = svr.find_first_of("@");
-    if (found == std::string::npos) {
-        SetupPointContinue(ctxPoint, true);
-        WRITE_LOG(LOG_DEBUG, "SetupArkPoint failed id:%s", svr.c_str());
-        ctxPoint->lastError = ark + ":" + svr + " parameter invalid";
-        return false;
-    }
-    std::string pidstr = svr.substr(0, found);
-    uint32_t pid = static_cast<uint32_t>(std::atoi(pidstr.c_str()));
-    bool ret = clsJdwp->CheckPIDExist(pid);
-    if (!ret) {
-        SetupPointContinue(ctxPoint, (int)ret);
-        WRITE_LOG(LOG_WARN, "SetupArkPoint failed pid:%u not exist", pid);
-        ctxPoint->lastError = ark + ":" + svr + " pid invalid";
-        return false;
-    }
-    // do slave connect
-    // fd[0] for forward, fd[1] for ark
-    ret = false;
-    Base::CreateSocketPair(fds);
-    std::string str = ark + ":" + svr;
-    uint32_t size = 1 + sizeof(int32_t) + str.size();
-    uint8_t buf[size];
-    buf[0] = SP_ARK_NEWFD;
-    if (memcpy_s(buf + 1, sizeof(int32_t), &fds[1], sizeof(int32_t)) ||
-        memcpy_s(buf + 1 + sizeof(int32_t), str.size(), str.c_str(), str.size())) {
-        Base::CloseSocketPair(fds);
-        return ret;
-    }
-    // buf: SP_ARK_NEWFD | fd[1] | pid@tid@Debugger
-    if (ThreadCtrlCommunicate(buf, size) > 0) {
-        ret = true;
-    }
-    WRITE_LOG(LOG_DEBUG, "SetupArkPoint Finish,ret:%d fd0:%d fd1:%d", ret, fds[0], fds[1]);
-    if (!ret) {
-        Base::CloseSocketPair(fds);
-        return ret;
-    }
-    ++refCount;
-    Base::IdleUvTask(loopTask, ctxPoint, SetupJdwpPointCallBack);
-    return ret;
-}
-}
diff --git a/hdc/src/daemon/daemon_forward.h b/hdc/src/daemon/daemon_forward.h
deleted file mode 100644
index 01af3f8..0000000
--- a/hdc/src/daemon/daemon_forward.h
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_DAEMON_FORWARD_H
-#define HDC_DAEMON_FORWARD_H
-#include "forward.h"
-
-namespace Hdc {
-class HdcDaemonForward : public HdcForwardBase {
-public:
-    HdcDaemonForward(HTaskInfo hTaskInfo);
-    virtual ~HdcDaemonForward();
-
-private:
-    bool SetupJdwpPoint(HCtxForward ctxPoint) override;
-    bool SetupArkPoint(HCtxForward ctxPoint) override;
-    static void SetupJdwpPointCallBack(uv_idle_t *handle);
-};
-}  // namespace Hdc
-
-#endif
diff --git a/hdc/src/daemon/daemon_tcp.cpp b/hdc/src/daemon/daemon_tcp.cpp
deleted file mode 100644
index ab8428e..0000000
--- a/hdc/src/daemon/daemon_tcp.cpp
+++ /dev/null
@@ -1,157 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "daemon_tcp.h"
-#include <cstdlib>
-#include "arpa/inet.h"
-#include "netinet/in.h"
-#include "new"
-#include "sys/socket.h"
-#include "system_depend.h"
-#include "unistd.h"
-#include "common.h"
-#include "session.h"
-
-namespace Hdc {
-HdcDaemonTCP::HdcDaemonTCP(const bool serverOrDaemonIn, void *ptrMainBase)
-    : HdcTCPBase(serverOrDaemonIn, ptrMainBase)
-{
-    // If the listening value for the property setting is obtained, it will be 0 randomly assigned.
-    string strTCPPort;
-    SystemDepend::GetDevItem("persist.hdc.port", strTCPPort);
-    tcpListenPort = atoi(strTCPPort.c_str());
-    if (tcpListenPort <= 0) {
-        WRITE_LOG(LOG_WARN, "persist.hdc.port is invalid, set default to 0");
-        tcpListenPort = 0;
-    }
-}
-
-HdcDaemonTCP::~HdcDaemonTCP()
-{
-}
-
-void HdcDaemonTCP::Stop()
-{
-    Base::TryCloseHandle((const uv_handle_t *)&servUDP);
-    Base::TryCloseHandle((const uv_handle_t *)&servTCP);
-    WRITE_LOG(LOG_DEBUG, "Stop tcpListenPort:%u", tcpListenPort);
-}
-
-void HdcDaemonTCP::TransmitConfig(const sockaddr *addrSrc, uv_udp_t *handle)
-{
-    char srcIP[BUF_SIZE_TINY] = "";
-    struct sockaddr addrSrcIPPort;
-    uv_udp_send_t *req = new uv_udp_send_t();
-    if (!req) {
-        return;
-    }
-    string sendBuf = Base::StringFormat("%s-%d", HANDSHAKE_MESSAGE.c_str(), tcpListenPort);
-    uv_buf_t sndbuf = uv_buf_init((char *)sendBuf.c_str(), sendBuf.size());
-    uv_ip4_name(const_cast<sockaddr_in *>(reinterpret_cast<const sockaddr_in *>(addrSrc)), srcIP, sizeof(srcIP));
-    uv_ip4_addr(srcIP, DEFAULT_PORT, const_cast<sockaddr_in *>(reinterpret_cast<const sockaddr_in *>(&addrSrcIPPort)));
-    uv_udp_send(req, handle, &sndbuf, 1, &addrSrcIPPort, SendUDPFinish);
-}
-
-void HdcDaemonTCP::AcceptClient(uv_stream_t *server, int status)
-{
-    uv_loop_t *ptrLoop = server->loop;
-    uv_tcp_t *pServTCP = (uv_tcp_t *)server;
-    HdcDaemonTCP *thisClass = (HdcDaemonTCP *)pServTCP->data;
-    HdcSessionBase *ptrConnect = reinterpret_cast<HdcSessionBase *>(thisClass->clsMainBase);
-    HdcSessionBase *daemon = reinterpret_cast<HdcSessionBase *>(thisClass->clsMainBase);
-    const uint16_t maxWaitTime = UV_DEFAULT_INTERVAL;
-    auto ctrl = daemon->BuildCtrlString(SP_START_SESSION, 0, nullptr, 0);
-    HSession hSession = ptrConnect->MallocSession(false, CONN_TCP, thisClass);
-    if (!hSession) {
-        WRITE_LOG(LOG_FATAL, "malloc tcp session failed");
-        return;
-    }
-    if (uv_accept(server, (uv_stream_t *)&hSession->hWorkTCP) < 0) {
-        WRITE_LOG(LOG_FATAL, "uv_accept error sessionId:%u", hSession->sessionId);
-        goto Finish;
-    }
-    if ((hSession->fdChildWorkTCP = Base::DuplicateUvSocket(&hSession->hWorkTCP)) < 0) {
-        WRITE_LOG(LOG_FATAL, "AcceptClient error fdChildWorkTCP:%d,errno:%d", hSession->fdChildWorkTCP, errno);
-        goto Finish;
-    }
-    Base::TryCloseHandle((uv_handle_t *)&hSession->hWorkTCP);
-    Base::StartWorkThread(ptrLoop, ptrConnect->SessionWorkThread, Base::FinishWorkThread, hSession);
-    // wait for thread up
-    while (hSession->childLoop.active_handles == 0) {
-        usleep(maxWaitTime);
-    }
-    Base::SendToPollFd(hSession->ctrlFd[STREAM_MAIN], ctrl.data(), ctrl.size());
-    return;
-Finish:
-    ptrConnect->FreeSession(hSession->sessionId);
-}
-
-void HdcDaemonTCP::RecvUDPEntry(const sockaddr *addrSrc, uv_udp_t *handle, const uv_buf_t *rcvbuf)
-{
-    TransmitConfig(addrSrc, handle);
-}
-
-void HdcDaemonTCP::SetUDPListen()
-{
-    struct sockaddr_in addr;
-    HdcSessionBase *ptrConnect = (HdcSessionBase *)clsMainBase;
-    // udp broadcast
-    servUDP.data = this;
-    uv_udp_init(&ptrConnect->loopMain, &servUDP);
-    uv_ip4_addr("0.0.0.0", DEFAULT_PORT, &addr);
-    uv_udp_bind(&servUDP, (const struct sockaddr *)&addr, UV_UDP_REUSEADDR);
-    uv_udp_recv_start(&servUDP, AllocStreamUDP, RecvUDP);
-}
-
-// Set the daemon-side TCP listening
-int HdcDaemonTCP::SetTCPListen()
-{
-    // tcp listen
-    HdcSessionBase *ptrConnect = (HdcSessionBase *)clsMainBase;
-    servTCP.data = this;
-    struct sockaddr_in addr = {};
-    int namelen;
-    const int DEFAULT_BACKLOG = 128;
-
-    uv_tcp_init(&ptrConnect->loopMain, &servTCP);
-    uv_ip4_addr("0.0.0.0", tcpListenPort, &addr);  // tcpListenPort == 0
-    uv_tcp_bind(&servTCP, (const struct sockaddr *)&addr, 0);
-    if (uv_listen((uv_stream_t *)&servTCP, DEFAULT_BACKLOG, (uv_connection_cb)AcceptClient)) {
-        return ERR_API_FAIL;
-    }
-    // Get listen port
-    Base::ZeroStruct(addr);
-    namelen = sizeof(addr);
-    if (uv_tcp_getsockname(&servTCP, (sockaddr *)&addr, &namelen)) {
-        return ERR_API_FAIL;
-    }
-    tcpListenPort = ntohs(addr.sin_port);
-    SystemDepend::SetDevItem("persist.hdc.port", std::to_string(tcpListenPort).c_str());
-    return RET_SUCCESS;
-}
-
-int HdcDaemonTCP::Initial()
-{
-    WRITE_LOG(LOG_DEBUG, "HdcDaemonTCP init");
-    SetUDPListen();
-    if (SetTCPListen() != RET_SUCCESS) {
-        WRITE_LOG(LOG_FATAL, "TCP listen failed");
-        return ERR_GENERIC;
-    }
-#ifndef UNIT_TEST
-    WRITE_LOG(LOG_INFO, "TCP listen on port:[%d]", tcpListenPort);
-#endif
-    return RET_SUCCESS;
-}
-}  // namespace Hdc
diff --git a/hdc/src/daemon/daemon_tcp.h b/hdc/src/daemon/daemon_tcp.h
deleted file mode 100644
index 1e1d384..0000000
--- a/hdc/src/daemon/daemon_tcp.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_DAEMON_TCP_H
-#define HDC_DAEMON_TCP_H
-#include <cstdint>
-#include "uv.h"
-#include "uv/unix.h"
-#include "tcp.h"
-struct sockaddr;
-
-namespace Hdc {
-class HdcDaemonTCP : public HdcTCPBase {
-public:
-    HdcDaemonTCP(const bool serverOrDaemonIn, void *ptrMainBase);
-    virtual ~HdcDaemonTCP();
-    void RecvUDPEntry(const sockaddr *addrSrc, uv_udp_t *handle, const uv_buf_t *rcvbuf) override;
-    uint16_t tcpListenPort;
-    int Initial();
-    void Stop();
-
-private:
-    static void AcceptClient(uv_stream_t *server, int status);
-    void TransmitConfig(const sockaddr *addrSrc, uv_udp_t *handle);
-    int SetTCPListen();
-    void SetUDPListen();
-
-    uv_tcp_t servTCP = {};
-    uv_udp_t servUDP = {};
-};
-}  // namespace Hdc
-
-#endif
diff --git a/hdc/src/daemon/daemon_uart.cpp b/hdc/src/daemon/daemon_uart.cpp
deleted file mode 100644
index 790294a..0000000
--- a/hdc/src/daemon/daemon_uart.cpp
+++ /dev/null
@@ -1,359 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifdef HDC_SUPPORT_UART
-
-#include "daemon_uart.h"
-
-#include <thread>
-#include <fcntl.h>
-#include <file_ex.h>
-#include <string_ex.h>
-
-#include <sys/file.h>
-#include <sys/mount.h>
-#include <sys/select.h>
-#include <sys/time.h>
-
-namespace Hdc {
-HdcDaemonUART::HdcDaemonUART(HdcDaemon &daemonSessionIn, ExternInterface &externInterface)
-    : HdcUARTBase(daemonSessionIn, externInterface), daemon(daemonSessionIn)
-{
-    checkSerialPort.data = nullptr;
-}
-
-int HdcDaemonUART::Initial(const std::string &devPathIn)
-{
-    int ret = 0;
-    devPath = devPathIn;
-    WRITE_LOG(LOG_DEBUG, "HdcDaemonUART init");
-    if (access(devPath.c_str(), F_OK) != 0) {
-        WRITE_LOG(LOG_DEBUG, "uartMod Disable, path is %s and errno is %d.", devPath.c_str(), errno);
-        return -1;
-    }
-#ifndef HDC_UT
-    std::string consoleActive;
-    if (OHOS::LoadStringFromFile(CONSOLE_ACTIVE_NODE, consoleActive)) {
-        consoleActive = OHOS::TrimStr(consoleActive, '\n');
-        WRITE_LOG(LOG_DEBUG, "consoleActive (%d):%s", consoleActive.length(),
-                  consoleActive.c_str());
-        if (!consoleActive.empty() and devPathIn.find(consoleActive.c_str()) != std::string::npos) {
-            WRITE_LOG(LOG_FATAL,
-                      "kernel use this dev(%s) as console , we can't open it as hdc uart dev",
-                      devPathIn.c_str());
-            return -1;
-        }
-    }
-#endif
-    constexpr int bufSize = 1024;
-    char buf[bufSize] = { 0 };
-    const uint16_t uartScanInterval = 1500;
-    ret = uv_timer_init(&daemon.loopMain, &checkSerialPort);
-    if (ret != 0) {
-        uv_err_name_r(ret, buf, bufSize);
-        WRITE_LOG(LOG_FATAL, "uv_timer_init failed %s", buf);
-    } else {
-        checkSerialPort.data = this;
-        ret = uv_timer_start(&checkSerialPort, UvWatchTimer, 0, uartScanInterval);
-        if (ret != 0) {
-            uv_err_name_r(ret, buf, bufSize);
-            WRITE_LOG(LOG_FATAL, "uv_timer_start failed %s", buf);
-        } else {
-            return 0;
-        }
-    }
-    return -1;
-}
-
-int HdcDaemonUART::PrepareBufForRead()
-{
-    constexpr int bufCoefficient = 1;
-    int readMax = MAX_UART_SIZE_IOBUF * bufCoefficient;
-    dataReadBuf.clear();
-    dataReadBuf.reserve(readMax);
-    return RET_SUCCESS;
-}
-
-void HdcDaemonUART::WatcherTimerCallBack()
-{
-    // try reanbel the uart device (reopen)
-    if (isAlive) {
-        return;
-    }
-    do {
-        if (uartHandle >= 0) {
-            if (CloseUartDevice() != RET_SUCCESS) {
-                break;
-            }
-        }
-        if ((OpenUartDevice() != RET_SUCCESS)) {
-            WRITE_LOG(LOG_DEBUG, "OpenUartdevice fail ! ");
-            break;
-        }
-        if ((PrepareBufForRead() != RET_SUCCESS)) {
-            WRITE_LOG(LOG_DEBUG, "PrepareBufForRead fail ! ");
-            break;
-        }
-        // read and write thread need this flag
-        isAlive = true;
-        if ((LoopUARTRead() != RET_SUCCESS)) {
-            WRITE_LOG(LOG_DEBUG, "LoopUARTRead fail ! ");
-            break;
-        }
-        if ((LoopUARTWrite() != RET_SUCCESS)) {
-            WRITE_LOG(LOG_DEBUG, "LoopUARTWrite fail ! ");
-            break;
-        }
-        return;
-    } while (false);
-    WRITE_LOG(LOG_FATAL, "WatcherTimerCallBack found some issue");
-    isAlive = false;
-}
-
-int HdcDaemonUART::CloseUartDevice()
-{
-    int ret = Base::CloseFd(uartHandle);
-    if (ret < 0) {
-        WRITE_LOG(LOG_FATAL, "CloseUartDevice failed ret: %d", ret);
-    }
-    isAlive = false;
-    return ret;
-}
-
-int HdcDaemonUART::OpenUartDevice()
-{
-    int ret = ERR_GENERIC;
-    while (true) {
-        if ((uartHandle = open(devPath.c_str(), O_RDWR | O_NOCTTY | O_NDELAY)) < 0) {
-            WRITE_LOG(LOG_WARN, "%s: cannot open uartHandle: errno=%d", devPath.c_str(), errno);
-            break;
-        }
-        uv_sleep(UART_IO_WAIT_TIME_100);
-        // cannot open with O_CLOEXEC, must fcntl
-        fcntl(uartHandle, F_SETFD, FD_CLOEXEC);
-        int flag = fcntl(uartHandle, F_GETFL);
-        flag &= ~O_NONBLOCK;
-        fcntl(uartHandle, F_SETFL, flag);
-        WRITE_LOG(LOG_DEBUG, "Set SetSerial ");
-        if (SetSerial(uartHandle, DEFAULT_BAUD_RATE_VALUE, UART_BIT2, 'N', 1) != RET_SUCCESS) {
-            break;
-        }
-        ret = RET_SUCCESS;
-        break;
-    }
-    if (ret != RET_SUCCESS) {
-        WRITE_LOG(LOG_DEBUG, "OpenUartdevice SerialHandle:%d fail.", uartHandle);
-    }
-    return ret;
-}
-
-void HdcDaemonUART::ResetOldSession(uint32_t sessionId)
-{
-    if (sessionId == 0) {
-        sessionId = currentSessionId;
-    }
-    HSession hSession = daemon.AdminSession(OP_QUERY, sessionId, nullptr);
-    if (hSession == nullptr) {
-        return;
-    }
-    if (hSession->hUART != nullptr) {
-        hSession->hUART->resetIO = true;
-    }
-    // The Host side is restarted, but the USB cable is still connected
-    WRITE_LOG(LOG_WARN, "Hostside softreset to restart daemon, old sessionId:%u", sessionId);
-    OnTransferError(hSession);
-}
-
-HSession HdcDaemonUART::GetSession(const uint32_t sessionId, bool create = false)
-{
-    HSession hSession = daemon.AdminSession(OP_QUERY, sessionId, nullptr);
-    if (hSession == nullptr and create) {
-        hSession = PrepareNewSession(sessionId);
-    }
-    return hSession;
-}
-
-void HdcDaemonUART::OnTransferError(const HSession session)
-{
-    // review maybe we can do something more ?
-    if (session != nullptr) {
-        WRITE_LOG(LOG_FATAL, "%s %s", __FUNCTION__, session->ToDebugString().c_str());
-        daemon.FreeSession(session->sessionId);
-        ClearUARTOutMap(session->sessionId);
-    }
-}
-
-void HdcDaemonUART::OnNewHandshakeOK(const uint32_t sessionId)
-{
-    currentSessionId = sessionId;
-}
-
-HSession HdcDaemonUART::PrepareNewSession(uint32_t sessionId)
-{
-    WRITE_LOG(LOG_FATAL, "%s sessionId:%u", __FUNCTION__, sessionId);
-    HSession hSession = daemon.MallocSession(false, CONN_SERIAL, this, sessionId);
-    if (!hSession) {
-        WRITE_LOG(LOG_FATAL, "new session malloc failed for sessionId:%u", sessionId);
-        return nullptr;
-    }
-    if (currentSessionId != 0) {
-        // reset old session
-        // The Host side is restarted, but the cable is still connected
-        WRITE_LOG(LOG_WARN, "New session coming, restart old sessionId:%u", currentSessionId);
-        daemon.PushAsyncMessage(currentSessionId, ASYNC_FREE_SESSION, nullptr, 0);
-    }
-    externInterface.StartWorkThread(&daemon.loopMain, daemon.SessionWorkThread,
-                                    Base::FinishWorkThread, hSession);
-    auto funcNewSessionUp = [](uv_timer_t *handle) -> void {
-        HSession hSession = reinterpret_cast<HSession>(handle->data);
-        HdcDaemon &daemonSession = *reinterpret_cast<HdcDaemon *>(hSession->classInstance);
-        if (hSession->childLoop.active_handles == 0) {
-            WRITE_LOG(LOG_DEBUG, "No active_handles.");
-            return;
-        }
-        if (!hSession->isDead) {
-            auto ctrl = daemonSession.BuildCtrlString(SP_START_SESSION, 0, nullptr, 0);
-            Base::SendToPollFd(hSession->ctrlFd[STREAM_MAIN], ctrl.data(), ctrl.size());
-            WRITE_LOG(LOG_DEBUG, "Main thread uartio migrate finish");
-        }
-        Base::TryCloseHandle(reinterpret_cast<uv_handle_t *>(handle), Base::CloseTimerCallback);
-    };
-    externInterface.TimerUvTask(&daemon.loopMain, hSession, funcNewSessionUp);
-    return hSession;
-}
-
-// review Merge this with Host side
-void HdcDaemonUART::DeamonReadThread()
-{
-    HdcUART deamonUart;
-    deamonUart.devUartHandle = uartHandle;
-    dataReadBuf.clear();
-    // after we got the head or something , we will expected some size
-    size_t expectedSize = 0;
-    // use < not <= because if it full , should not read again
-    while (isAlive && dataReadBuf.size() < MAX_READ_BUFFER) {
-        ssize_t bytesRead = ReadUartDev(dataReadBuf, expectedSize, deamonUart);
-        if (bytesRead == 0) {
-            WRITE_LOG(LOG_DEBUG, "%s read %zd, clean the data try read again.", __FUNCTION__,
-                      bytesRead);
-            // drop current cache
-            expectedSize = 0;
-            dataReadBuf.clear();
-            continue;
-        } else if (bytesRead < 0) {
-            WRITE_LOG(LOG_DEBUG, "%s read abnormal, stop uart module.", __FUNCTION__);
-            Stop();
-            break;
-        }
-        WRITE_LOG(LOG_DEBUG, "DeamonReadThread bytesRead:%d, totalReadBytes.size():%d.", bytesRead,
-                  dataReadBuf.size());
-
-        if (dataReadBuf.size() < sizeof(UartHead)) {
-            continue; // no enough ,read again
-        }
-        expectedSize = PackageProcess(dataReadBuf);
-    }
-    if (isAlive) {
-        WRITE_LOG(LOG_WARN, "totalReadSize is full %zu/%zu, DeamonReadThread exit..",
-                  dataReadBuf.size(), expectedSize);
-    } else {
-        WRITE_LOG(LOG_WARN, "dev is not alive, DeamonReadThread exit..");
-    }
-    // why not free session here
-    isAlive = false;
-    return;
-}
-
-void HdcDaemonUART::DeamonWriteThread()
-{
-    while (isAlive) {
-        WRITE_LOG(LOG_DEBUG, "DeamonWriteThread wait sendLock.");
-        transfer.Wait();
-        SendPkgInUARTOutMap();
-    }
-    WRITE_LOG(LOG_WARN, "dev is not alive, DeamonWriteThread exit..");
-    return;
-}
-
-int HdcDaemonUART::LoopUARTRead()
-{
-    try {
-        std::thread deamonReadThread([this]() { this->DeamonReadThread(); });
-        deamonReadThread.detach();
-        return 0;
-    } catch (...) {
-        WRITE_LOG(LOG_WARN, "create thread DeamonReadThread failed");
-    }
-    return -1;
-}
-
-int HdcDaemonUART::LoopUARTWrite()
-{
-    try {
-        std::thread deamonWriteThread([this]() { this->DeamonWriteThread(); });
-        deamonWriteThread.detach();
-        return 0;
-    } catch (...) {
-        WRITE_LOG(LOG_WARN, "create thread DeamonWriteThread failed");
-    }
-    return -1;
-}
-
-bool HdcDaemonUART::IsSendReady(HSession hSession)
-{
-    if (isAlive and !hSession->isDead and uartHandle >= 0 and !hSession->hUART->resetIO) {
-        return true;
-    } else {
-        if (!isAlive) {
-            WRITE_LOG(LOG_WARN, "!isAlive");
-        } else if (hSession->isDead) {
-            WRITE_LOG(LOG_WARN, "session isDead");
-        } else if (uartHandle < 0) {
-            WRITE_LOG(LOG_WARN, "uartHandle is not valid");
-        } else if (hSession->hUART->resetIO) {
-            WRITE_LOG(LOG_WARN, "session have resetIO");
-        }
-        return false;
-    }
-};
-
-HdcDaemonUART::~HdcDaemonUART()
-{
-    Stop();
-}
-
-void HdcDaemonUART::Stop()
-{
-    WRITE_LOG(LOG_DEBUG, "%s run!", __FUNCTION__);
-    if (!stopped) {
-        stopped = true;
-        std::lock_guard<std::mutex> lock(workThreadProcessingData);
-
-        // maybe some data response not back to host
-        // like smode need response.
-        ResponseUartTrans(currentSessionId, 0, PKG_OPTION_FREE);
-        EnsureAllPkgsSent();
-        isAlive = false;
-        WRITE_LOG(LOG_DEBUG, "%s free main session", __FUNCTION__);
-        if (checkSerialPort.data != nullptr) {
-            externInterface.TryCloseHandle((uv_handle_t *)&checkSerialPort);
-            checkSerialPort.data = nullptr;
-        }
-        CloseUartDevice();
-        WRITE_LOG(LOG_DEBUG, "%s free main session finish", __FUNCTION__);
-    }
-}
-} // namespace Hdc
-#endif // HDC_SUPPORT_UART
diff --git a/hdc/src/daemon/daemon_uart.h b/hdc/src/daemon/daemon_uart.h
deleted file mode 100644
index 2ee1a68..0000000
--- a/hdc/src/daemon/daemon_uart.h
+++ /dev/null
@@ -1,68 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_DAEMON_UART_H
-#define HDC_DAEMON_UART_H
-#include <pthread.h>
-#include "daemon_common.h"
-
-namespace Hdc {
-class HdcDaemon;
-
-class HdcDaemonUART : public HdcUARTBase {
-public:
-    explicit HdcDaemonUART(HdcDaemon&, ExternInterface& = HdcUARTBase::defaultInterface);
-    int Initial(const std::string &devPathIn = UART_HDC_NODE);
-    ~HdcDaemonUART();
-
-    void OnNewHandshakeOK(const uint32_t sessionId);
-    void Stop();
-protected:
-    virtual HSession GetSession(const uint32_t sessionId, bool create) override;
-    virtual void OnTransferError(const HSession session) override;
-
-private:
-    static inline void UvWatchTimer(uv_timer_t *handle)
-    {
-        if (handle != nullptr) {
-            HdcDaemonUART *thisClass = static_cast<HdcDaemonUART *>(handle->data);
-            if (thisClass != nullptr) {
-                thisClass->WatcherTimerCallBack();
-                return;
-            }
-        }
-        WRITE_LOG(LOG_FATAL, "UvWatchTimer have not got correct class parameter");
-    };
-    virtual void WatcherTimerCallBack(); // ut will overider this
-    virtual int CloseUartDevice();
-    virtual int OpenUartDevice();
-    virtual int LoopUARTRead();
-    virtual int LoopUARTWrite();
-    virtual bool IsSendReady(HSession hSession);
-    virtual int PrepareBufForRead();
-    virtual HSession PrepareNewSession(uint32_t sessionId);
-    virtual void DeamonReadThread();
-    virtual void DeamonWriteThread();
-    std::vector<uint8_t> dataReadBuf; // from uart dev
-    virtual void ResetOldSession(uint32_t sessionId) override;
-
-    uv_timer_t checkSerialPort; // server-use
-    uint32_t currentSessionId = 0;
-    bool isAlive = false;
-    std::string devPath;
-
-    HdcDaemon &daemon;
-};
-} // namespace Hdc
-#endif
diff --git a/hdc/src/daemon/daemon_unity.cpp b/hdc/src/daemon/daemon_unity.cpp
deleted file mode 100644
index 89b18f0..0000000
--- a/hdc/src/daemon/daemon_unity.cpp
+++ /dev/null
@@ -1,413 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include <cstdlib>
-#include <sys/mount.h>
-#include <sys/wait.h>
-
-#include "daemon_unity.h"
-
-namespace Hdc {
-HdcDaemonUnity::HdcDaemonUnity(HTaskInfo hTaskInfo)
-    : HdcTaskBase(hTaskInfo)
-{
-    currentDataCommand = CMD_KERNEL_ECHO_RAW;  // Default output to shelldata
-}
-
-HdcDaemonUnity::~HdcDaemonUnity()
-{
-    WRITE_LOG(LOG_DEBUG, "~HdcDaemonUnity channelId:%u", taskInfo->channelId);
-}
-
-void HdcDaemonUnity::StopTask()
-{
-    // Remove jpid tracker when stopping task
-    RemoveJdwpTracker();
-    asyncCommand.DoRelease();
-}
-
-bool HdcDaemonUnity::ReadyForRelease()
-{
-    if (!HdcTaskBase::ReadyForRelease() || !asyncCommand.ReadyForRelease()) {
-        WRITE_LOG(LOG_DEBUG, "not ready for release channelId:%u", taskInfo->channelId);
-        return false;
-    }
-    return true;
-}
-
-bool HdcDaemonUnity::AsyncCmdOut(bool finish, int64_t exitStatus, const string result)
-{
-#ifdef UNIT_TEST
-    Base::WriteBinFile((UT_TMP_PATH + "/execute.result").c_str(), (uint8_t *)result.c_str(), result.size(),
-                       countUt++ == 0);
-#endif
-    bool ret = false;
-    bool wantFinish = false;
-    do {
-        if (finish) {
-            wantFinish = true;
-            ret = true;
-            --refCount;
-            break;
-        }
-        if (!SendToAnother(currentDataCommand, reinterpret_cast<uint8_t *>(const_cast<char *>(result.c_str())),
-            result.size())) {
-            break;
-        }
-        ret = true;
-    } while (false);
-    if (wantFinish) {
-        TaskFinish();
-    }
-    return ret;
-}
-
-int HdcDaemonUnity::ExecuteShell(const char *shellCommand)
-{
-    do {
-        AsyncCmd::CmdResultCallback funcResultOutput;
-        funcResultOutput = [this](bool finish, int64_t exitStatus, const string result) -> bool {
-            return this->AsyncCmdOut(finish, exitStatus, result);
-        };
-        if (!asyncCommand.Initial(loopTask, funcResultOutput)) {
-            break;
-        }
-        asyncCommand.ExecuteCommand(shellCommand);
-        ++refCount;
-        return RET_SUCCESS;
-    } while (false);
-
-    TaskFinish();
-    WRITE_LOG(LOG_DEBUG, "Shell failed finish");
-    return -1;
-}
-
-bool HdcDaemonUnity::FindMountDeviceByPath(const char *toQuery, char *dev)
-{
-    int ret = false;
-    int len = BUF_SIZE_DEFAULT2;
-    char buf[BUF_SIZE_DEFAULT2];
-
-    FILE *fp = fopen("/proc/mounts", "r");
-    if (fp == nullptr) {
-        WRITE_LOG(LOG_FATAL, "fopen /proc/mounts error:%d", errno);
-        return false;
-    }
-
-    while (fgets(buf, len, fp) != nullptr) {
-        char dir[BUF_SIZE_SMALL] = "";
-        int freq;
-        int passnno;
-        int res = 0;
-        // clang-format off
-        res = sscanf_s(buf, "%255s %255s %*s %*s %d %d\n", dev, BUF_SIZE_SMALL - 1,
-                       dir, BUF_SIZE_SMALL - 1, &freq, &passnno);
-        // clang-format on
-        dev[BUF_SIZE_SMALL - 1] = '\0';
-        dir[BUF_SIZE_SMALL - 1] = '\0';
-        if (res == 4 && (strcmp(toQuery, dir) == 0)) {  // 4 : The correct number of parameters
-            WRITE_LOG(LOG_DEBUG, "FindMountDeviceByPath dev:%s dir:%s", dev, dir);
-            ret = true;
-            break;
-        }
-    }
-    int rc = fclose(fp);
-    if (rc != 0) {
-        WRITE_LOG(LOG_WARN, "fclose rc:%d error:%d", rc, errno);
-    }
-    if (!ret) {
-        WRITE_LOG(LOG_FATAL, "FindMountDeviceByPath not found %s", toQuery);
-    }
-    return ret;
-}
-
-bool HdcDaemonUnity::RemountPartition(const char *dir)
-{
-    int fd;
-    int off = 0;
-    char dev[BUF_SIZE_SMALL] = "";
-
-    if (!FindMountDeviceByPath(dir, dev) || strlen(dev) < 4) {  // 4 : file count
-        WRITE_LOG(LOG_FATAL, "FindMountDeviceByPath failed %s", dir);
-        return false;
-    }
-
-    if ((fd = open(dev, O_RDONLY | O_CLOEXEC)) < 0) {
-        WRITE_LOG(LOG_FATAL, "Open device:%s failed，error:%d", dev, errno);
-        return false;
-    }
-    ioctl(fd, BLKROSET, &off);
-    Base::CloseFd(fd);
-
-    if (mount(dev, dir, "none", MS_REMOUNT, nullptr) < 0) {
-        WRITE_LOG(LOG_FATAL, "Mount device failed dev:%s dir:%s error:%d", dev, dir, errno);
-        return false;
-    }
-    return true;
-}
-
-bool HdcDaemonUnity::CallRemount()
-{
-    int pipefd[2];
-    pid_t pid;
-    int exitStatus;
-
-    if (pipe(pipefd) == -1) {
-        WRITE_LOG(LOG_FATAL, "Failed to create pipe: %s", strerror(errno));
-        return false;
-    }
-    pid = fork();
-    if (pid < 0) {
-        WRITE_LOG(LOG_FATAL, "Failed to fork: %s", strerror(errno));
-        return false;
-    }
-    if (pid == 0) {
-        close(pipefd[0]);
-        signal(SIGCHLD, SIG_DFL);
-        exitStatus = system("remount");
-        write(pipefd[1], &exitStatus, sizeof(int));
-        close(pipefd[1]);
-        _exit(0);
-    } else {
-        close(pipefd[1]);
-        read(pipefd[0], &exitStatus, sizeof(int));
-        close(pipefd[0]);
-        waitpid(pid, nullptr, 0);
-        if (exitStatus == -1) {
-            WRITE_LOG(LOG_FATAL, "Failed to execute /bin/remount: %s", strerror(errno));
-            return false;
-        } else if (WIFEXITED(exitStatus) && WEXITSTATUS(exitStatus) != 0) {
-            WRITE_LOG(LOG_FATAL, "Remount failed with exit code: %d", WEXITSTATUS(exitStatus));
-            return false;
-        }
-    }
-
-    return true;
-}
-
-bool HdcDaemonUnity::RemountDevice()
-{
-    if (getuid() != 0) {
-        LogMsg(MSG_FAIL, "Operate need running as root");
-        return false;
-    }
-    struct stat info;
-    if (!lstat("/vendor", &info) && (info.st_mode & S_IFMT) == S_IFDIR) {
-        if (!RemountPartition("/vendor")) {
-            WRITE_LOG(LOG_FATAL, "Mount failed /vendor (via mount)");
-        }
-    }
-    if (!lstat("/system", &info) && (info.st_mode & S_IFMT) == S_IFDIR) {
-        if (!RemountPartition("/")) {
-            WRITE_LOG(LOG_FATAL, "Mount failed /system (via mount)");
-        }
-    }
-
-    if (CallRemount()) {
-        LogMsg(MSG_OK, "Mount finish");
-        return true;
-    } else {
-        LogMsg(MSG_FAIL, "Mount failed");
-        return false;
-    }
-}
-
-bool HdcDaemonUnity::RebootDevice(const string &cmd)
-{
-    sync();
-    return SystemDepend::RebootDevice(cmd);
-}
-
-bool HdcDaemonUnity::SetDeviceRunMode(const char *cmd)
-{
-    WRITE_LOG(LOG_INFO, "Set run mode:%s", cmd);
-    string tmp(cmd);
-    char *ptr = tmp.data();
-    char *token = nullptr;
-
-#ifdef HDC_EMULATOR
-    LogMsg(MSG_FAIL, "[E001300]Not support tmode for Emulator");
-    return true;
-#endif
-
-    // hdc tmode usb, do nothing
-    if (strcmp(CMDSTR_TMODE_USB.c_str(), cmd) == 0) {
-        LogMsg(MSG_FAIL, "[E001000]For USB debugging, please set it on the device's Settings UI");
-        return true;
-    }
-    // not usb and not tcp
-    if (strncmp("port", cmd, strlen("port")) != 0) {
-        LogMsg(MSG_FAIL, "[E001001]Unknown command");
-        return false;
-    }
-
-    // bypass port
-    token = strtok_r(ptr, " ", &ptr);
-    // get next token
-    token = strtok_r(ptr, " ", &ptr);
-    // hdc tmode port
-    if (token == nullptr) {
-        LogMsg(MSG_OK, "Set device run mode successful.");
-        SystemDepend::SetDevItem("persist.hdc.mode", "tcp");
-        SystemDepend::SetDevItem("persist.hdc.mode.tcp", "enable");
-    } else {
-        /*
-        * hdc tmode port xxxxxx
-        * hdc tmode port close
-        */
-        if (strcmp(token, "close") == 0) {
-            SystemDepend::SetDevItem("persist.hdc.port", "0");
-            SystemDepend::SetDevItem("persist.hdc.mode.tcp", "disable");
-        } else {
-            string tmp(token);
-            if (tmp.find_first_not_of("0123456789") != string::npos) {
-                LogMsg(MSG_FAIL, "[E001100]Invalid port");
-                return false;
-            }
-            LogMsg(MSG_OK, "Set device run mode successful.");
-            SystemDepend::SetDevItem("persist.hdc.mode", "tcp");
-            SystemDepend::SetDevItem("persist.hdc.port", token);
-            SystemDepend::SetDevItem("persist.hdc.mode.tcp", "enable");
-        }
-    }
-    return true;
-}
-
-inline bool HdcDaemonUnity::GetHiLog(const char *cmd)
-{
-    string cmdDo = "hilog";
-    if (cmd && !strcmp(const_cast<char *>(cmd), "h")) {
-        cmdDo += " -h";
-    }
-    ExecuteShell(cmdDo.c_str());
-    return true;
-}
-
-inline bool HdcDaemonUnity::ListJdwpProcess(void *daemonIn)
-{
-    HdcDaemon *daemon = (HdcDaemon *)daemonIn;
-    string result = ((HdcJdwp *)daemon->clsJdwp)->GetProcessList();
-    if (!result.size()) {
-        result = EMPTY_ECHO;
-    } else {
-        result.erase(result.end() - 1);  // remove tail \n
-    }
-    LogMsg(MSG_OK, result.c_str());
-    return true;
-}
-
-inline bool HdcDaemonUnity::TrackJdwpProcess(void *daemonIn, const string& param)
-{
-    HdcDaemon *daemon = static_cast<HdcDaemon *>(daemonIn);
-    taskInfo->debugRelease = 1;
-    if (param == "p") {
-        taskInfo->debugRelease = 0;
-    } else if (param == "a") {
-        // allApp with display debug or release
-        constexpr uint8_t allAppWithDr = 3;
-        taskInfo->debugRelease = allAppWithDr;
-    }
-    if (!((static_cast<HdcJdwp *>(daemon->clsJdwp))->CreateJdwpTracker(taskInfo))) {
-        string result = MESSAGE_FAIL;
-        LogMsg(MSG_OK, result.c_str());
-        return false;
-    }
-    return true;
-}
-
-inline void HdcDaemonUnity::RemoveJdwpTracker()
-{
-    HdcDaemon *daemon = static_cast<HdcDaemon *>(taskInfo->ownerSessionClass);
-    (static_cast<HdcJdwp *>(daemon->clsJdwp))->RemoveJdwpTracker(taskInfo);
-}
-
-bool HdcDaemonUnity::CommandDispatch(const uint16_t command, uint8_t *payload, const int payloadSize)
-{
-    bool ret = true;
-    HdcDaemon *daemon = (HdcDaemon *)taskInfo->ownerSessionClass;
-    // Both are not executed, do not need to be detected 'childReady'
-    string strPayload = string(reinterpret_cast<char *>(payload), payloadSize);
-#ifdef HDC_DEBUG
-    WRITE_LOG(LOG_DEBUG, "CommandDispatch command:%d", command);
-#endif // HDC_DEBUG
-    switch (command) {
-        case CMD_UNITY_EXECUTE: {
-            ExecuteShell(const_cast<char *>(strPayload.c_str()));
-            break;
-        }
-        case CMD_UNITY_REMOUNT: {
-            ret = false;
-            RemountDevice();
-            break;
-        }
-        case CMD_UNITY_REBOOT: {
-            ret = false;
-            RebootDevice(strPayload);
-            break;
-        }
-        case CMD_UNITY_RUNMODE: {
-            ret = false;
-            SetDeviceRunMode(strPayload.c_str());
-            break;
-        }
-        case CMD_UNITY_HILOG: {
-            GetHiLog(strPayload.c_str());
-            break;
-        }
-        case CMD_UNITY_ROOTRUN: {
-            ret = false;
-            string debugMode;
-            // hdcd restart in old pid
-            bool restart = true;
-            SystemDepend::GetDevItem("const.debuggable", debugMode);
-            if (debugMode == "1") {
-                if (payloadSize != 0 && !strcmp(strPayload.c_str(), "r")) {
-                    SystemDepend::SetDevItem("persist.hdc.root", "0");
-                } else {
-                    // hdcd restart in new pid
-                    restart = false;
-                    SystemDepend::SetDevItem("persist.hdc.root", "1");
-                }
-            } else {
-                LogMsg(MSG_FAIL, "Cannot set root run mode in undebuggable version.");
-                return false;
-            }
-            daemon->PostStopInstanceMessage(restart);
-            break;
-        }
-        case CMD_UNITY_BUGREPORT_INIT: {
-            currentDataCommand = CMD_UNITY_BUGREPORT_DATA;
-            ExecuteShell("hidumper");
-            break;
-        }
-        case CMD_JDWP_LIST: {
-            ret = false;
-            ListJdwpProcess(daemon);
-            break;
-        }
-        case CMD_JDWP_TRACK: {
-            if (!TrackJdwpProcess(daemon, strPayload)) {
-                ret = false;
-            }
-            break;
-        }
-        default:
-            break;
-    }
-#ifdef HDC_DEBUG
-    WRITE_LOG(LOG_DEBUG, "CommandDispatch command:%d finish.", command);
-#endif // HDC_LOCAL_DEBUG
-    return ret;
-};
-}  // namespace Hdc
diff --git a/hdc/src/daemon/daemon_unity.h b/hdc/src/daemon/daemon_unity.h
deleted file mode 100644
index 4ebe545..0000000
--- a/hdc/src/daemon/daemon_unity.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_DAEMON_UNITY_H
-#define HDC_DAEMON_UNITY_H
-#include "daemon_common.h"
-
-namespace Hdc {
-class HdcDaemonUnity : public HdcTaskBase {
-public:
-    HdcDaemonUnity(HTaskInfo hTaskInfo);
-    virtual ~HdcDaemonUnity();
-    bool CommandDispatch(const uint16_t command, uint8_t *payload, const int payloadSize) override;
-    void StopTask() override;
-    bool ReadyForRelease() override;
-
-private:
-    static void OnFdRead(uv_fs_t *req);
-    int ExecuteShell(const char *shellCommand);
-    bool FindMountDeviceByPath(const char *toQuery, char *dev);
-    bool RemountPartition(const char *dir);
-    bool CallRemount();
-    bool RemountDevice();
-    bool RebootDevice(const string &cmd);
-    bool SetDeviceRunMode(const char *cmd);
-    bool GetHiLog(const char *cmd);
-    bool ListJdwpProcess(void *daemonIn);
-    bool AsyncCmdOut(bool finish, int64_t exitStatus, const string result);
-    bool TrackJdwpProcess(void *daemonIn, const string& param);
-    void RemoveJdwpTracker();
-
-    AsyncCmd asyncCommand;
-    uint16_t currentDataCommand;
-#ifdef UNIT_TEST
-    int countUt = 0;
-#endif
-};
-}  // namespace Hdc
-#endif  // HDC_DAEMON_UNITY_H
diff --git a/hdc/src/daemon/daemon_usb.cpp b/hdc/src/daemon/daemon_usb.cpp
deleted file mode 100644
index 5619d77..0000000
--- a/hdc/src/daemon/daemon_usb.cpp
+++ /dev/null
@@ -1,715 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "daemon_usb.h"
-#include <cerrno>
-#include <cstddef>
-#include "arpa/inet.h"
-#include "asm-generic/int-ll64.h"
-#include "fcntl.h"
-#include "linux/usb/functionfs.h"
-#include "new"
-#include "sched.h"
-#include "system_depend.h"
-#include "unistd.h"
-#include "uv/unix.h"
-#include "daemon.h"
-#include "usb_ffs.h"
-
-namespace Hdc {
-static constexpr int CONFIG_COUNT2 = 2;
-static constexpr int CONFIG_COUNT3 = 3;
-static constexpr int CONFIG_COUNT5 = 5;
-
-struct UvData {
-    HdcDaemonUSB *daemonUsb;
-    const uint8_t *buf;
-};
-
-HdcDaemonUSB::HdcDaemonUSB(const bool serverOrDaemonIn, void *ptrMainBase)
-    : HdcUSBBase(serverOrDaemonIn, ptrMainBase)
-{
-}
-
-HdcDaemonUSB::~HdcDaemonUSB()
-{
-    // Closed in the IO loop, no longer closing CLOSE ENDPOINT
-    Base::CloseFd(controlEp);
-    if (ctxRecv.buf) {
-        delete[] ctxRecv.buf;
-    }
-    uv_fs_req_cleanup(&ctxRecv.req);
-}
-
-void HdcDaemonUSB::Stop()
-{
-    WRITE_LOG(LOG_DEBUG, "HdcDaemonUSB Stop");
-    // Here only clean up the IO-related resources, session related resources clear reason to clean up the session
-    // module
-    modRunning = false;
-    WRITE_LOG(LOG_DEBUG, "HdcDaemonUSB Stop free main session");
-    Base::TryCloseHandle((uv_handle_t *)&checkEP);
-    CloseEndpoint(&usbHandle);
-    WRITE_LOG(LOG_DEBUG, "HdcDaemonUSB Stop free main session finish");
-}
-
-string HdcDaemonUSB::GetDevPath(const std::string &path)
-{
-    DIR *dir = ::opendir(path.c_str());
-    if (dir == nullptr) {
-        WRITE_LOG(LOG_WARN, "%s: cannot open devpath: errno: %d", path.c_str(), errno);
-        return "";
-    }
-
-    string res = USB_FFS_BASE;
-    string node;
-    int count = 0;
-    struct dirent *entry = nullptr;
-    while ((entry = ::readdir(dir))) {
-        if (*entry->d_name == '.') {
-            continue;
-        }
-        node = entry->d_name;
-        ++count;
-    }
-    if (count > 1) {
-        res += "hdc";
-    } else {
-        res += node;
-    }
-    ::closedir(dir);
-    return res;
-}
-
-int HdcDaemonUSB::GetMaxPacketSize(int fdFfs)
-{
-    // no ioctl support, todo dynamic get
-    return MAX_PACKET_SIZE_HISPEED;
-}
-
-int HdcDaemonUSB::Initial()
-{
-    // after Linux-3.8，kernel switch to the USB Function FS
-    // Implement USB hdc function in user space
-    WRITE_LOG(LOG_DEBUG, "HdcDaemonUSB init");
-    basePath = GetDevPath(USB_FFS_BASE);
-    if (access((basePath + "/ep0").c_str(), F_OK) != 0) {
-        WRITE_LOG(LOG_DEBUG,"Only support usb-ffs, make sure kernel3.8+ and usb-ffs enabled, "
-                  "usbmode disabled: errno: %d, basePath: %s ", errno, basePath.c_str());
-        return ERR_API_FAIL;
-    }
-    ctxRecv.thisClass = this;
-    ctxRecv.bufSizeMax = Base::GetUsbffsBulkSize();
-    ctxRecv.buf = new uint8_t[ctxRecv.bufSizeMax]();
-    if (!ctxRecv.buf) {
-        WRITE_LOG(LOG_FATAL, "Init alloc memory failed");
-        return ERR_BUF_ALLOC;
-    }
-
-    HdcDaemon *daemon = (HdcDaemon *)clsMainBase;
-    WRITE_LOG(LOG_DEBUG, "HdcDaemonUSB::Initiall");
-    uv_timer_init(&daemon->loopMain, &checkEP);
-    checkEP.data = this;
-    uv_timer_start(&checkEP, WatchEPTimer, 0, TIME_BASE);
-    return 0;
-}
-
-// make gnuc++ happy. Clang support direct assignment value to structure, buf g++ weakness
-void HdcDaemonUSB::FillUsbV2Head(UsbFunctionfsDescV2 &descUsbFfs)
-{
-    descUsbFfs.head.magic = LONG_LE(FUNCTIONFS_DESCRIPTORS_MAGIC_V2);
-    descUsbFfs.head.length = LONG_LE(sizeof(descUsbFfs));
-    descUsbFfs.head.flags
-        = FUNCTIONFS_HAS_FS_DESC | FUNCTIONFS_HAS_HS_DESC | FUNCTIONFS_HAS_SS_DESC | FUNCTIONFS_HAS_MS_OS_DESC;
-    descUsbFfs.config1Count = CONFIG_COUNT3;
-    descUsbFfs.config2Count = CONFIG_COUNT3;
-    descUsbFfs.config3Count = CONFIG_COUNT5;
-    descUsbFfs.configWosCount = CONFIG_COUNT2;
-    descUsbFfs.config1Desc = config1;
-    descUsbFfs.config2Desc = config2;
-    descUsbFfs.config3Desc = config3;
-    descUsbFfs.wosHead = g_wosHead;
-    descUsbFfs.wosDesc = g_wosDesc;
-    descUsbFfs.osPropHead = g_osPropHead;
-    descUsbFfs.osPropValues = g_osPropValues;
-}
-
-// DAEMON end USB module USB-FFS EP port connection
-int HdcDaemonUSB::ConnectEPPoint(HUSB hUSB)
-{
-    int ret = ERR_GENERIC;
-    struct UsbFunctionfsDescV2 descUsbFfs = {};
-    FillUsbV2Head(descUsbFfs);
-    while (true) {
-        if (controlEp <= 0) {
-            // After the control port sends the instruction, the device is initialized by the device to the HOST host,
-            // which can be found for USB devices. Do not send initialization to the EP0 control port, the USB
-            // device will not be initialized by Host
-            WRITE_LOG(LOG_DEBUG, "Begin send to control(EP0) for usb descriptor init");
-            string ep0Path = basePath + "/ep0";
-            if ((controlEp = open(ep0Path.c_str(), O_RDWR)) < 0) {
-                WRITE_LOG(LOG_WARN, "%s: cannot open control endpoint: errno=%d", ep0Path.c_str(), errno);
-                break;
-            }
-            if (write(controlEp, &descUsbFfs, sizeof(descUsbFfs)) < 0) {
-                WRITE_LOG(LOG_WARN, "%s: write ffs configs failed: errno=%d", ep0Path.c_str(), errno);
-                break;
-            }
-            if (write(controlEp, &USB_FFS_VALUE, sizeof(USB_FFS_VALUE)) < 0) {
-                WRITE_LOG(LOG_WARN, "%s: write USB_FFS_VALUE failed: errno=%d", ep0Path.c_str(), errno);
-                break;
-            }
-            // active usbrc，Send USB initialization signal
-            SystemDepend::SetDevItem("sys.usb.ffs.ready.hdc", "0");
-            SystemDepend::SetDevItem("sys.usb.ffs.ready", "1");
-            SystemDepend::SetDevItem("sys.usb.ffs.ready.hdc", "1");
-            WRITE_LOG(LOG_DEBUG, "ConnectEPPoint ctrl init finish, set usb-ffs ready");
-        }
-        string outPath = basePath + "/ep1";
-        if ((hUSB->bulkOut = open(outPath.c_str(), O_RDWR)) < 0) {
-            WRITE_LOG(LOG_WARN, "%s: cannot open bulk-out ep: errno=%d", outPath.c_str(), errno);
-            break;
-        }
-        string inPath = basePath + "/ep2";
-        if ((hUSB->bulkIn = open(inPath.c_str(), O_RDWR)) < 0) {
-            WRITE_LOG(LOG_WARN, "%s: cannot open bulk-in ep: errno=%d", inPath.c_str(), errno);
-            break;
-        }
-        // cannot open with O_CLOEXEC, must fcntl
-        fcntl(controlEp, F_SETFD, FD_CLOEXEC);
-        fcntl(hUSB->bulkOut, F_SETFD, FD_CLOEXEC);
-        fcntl(hUSB->bulkIn, F_SETFD, FD_CLOEXEC);
-        hUSB->wMaxPacketSizeSend = GetMaxPacketSize(hUSB->bulkIn);
-
-        WRITE_LOG(LOG_DEBUG, "New bulk in\\out open bulkout:%d bulkin:%d", hUSB->bulkOut, hUSB->bulkIn);
-        ret = RET_SUCCESS;
-        break;
-    }
-    if (ret != RET_SUCCESS) {
-        CloseEndpoint(hUSB, true);
-    }
-    return ret;
-}
-
-void HdcDaemonUSB::CloseEndpoint(HUSB hUSB, bool closeCtrlEp)
-{
-    Base::CloseFd(hUSB->bulkIn);
-    Base::CloseFd(hUSB->bulkOut);
-    if (controlEp > 0 && closeCtrlEp) {
-        Base::CloseFd(controlEp);
-        controlEp = 0;
-    }
-    isAlive = false;
-    WRITE_LOG(LOG_FATAL, "DaemonUSB close endpoint");
-}
-
-void HdcDaemonUSB::ResetOldSession(uint32_t sessionId, bool isSoftReset)
-{
-    HdcDaemon *daemon = reinterpret_cast<HdcDaemon *>(clsMainBase);
-    if (sessionId == 0) {
-        sessionId = currentSessionId;
-    }
-    HSession hSession = daemon->AdminSession(OP_QUERY, sessionId, nullptr);
-    if (hSession == nullptr) {
-        WRITE_LOG(LOG_FATAL, "ResetOldSession hSession nullptr sessionId:%u", sessionId);
-        return;
-    }
-    // The Host side is restarted, but the USB cable is still connected
-    hSession->isSoftReset = isSoftReset;
-    WRITE_LOG(LOG_WARN, "Hostside softreset to restart daemon, old sessionId:%u isSoftReset:%d",
-        sessionId, isSoftReset);
-    daemon->FreeSession(sessionId);
-}
-
-// Prevent other USB data misfortunes to send the program crash
-int HdcDaemonUSB::AvailablePacket(uint8_t *ioBuf, int ioBytes, uint32_t *sessionId)
-{
-    int ret = RET_SUCCESS;
-    while (true) {
-        if (!IsUsbPacketHeader(ioBuf, ioBytes)) {
-            break;
-        }
-        // usb header
-        USBHead *usbPayloadHeader = reinterpret_cast<struct USBHead *>(ioBuf);
-        uint32_t inSessionId = ntohl(usbPayloadHeader->sessionId);
-        if ((usbPayloadHeader->option & USB_OPTION_RESET)) {
-            WRITE_LOG(LOG_INFO, "USB_OPTION_RESET inSessionId:%u, currentSessionId:%u",
-                inSessionId, currentSessionId);
-            ResetOldSession(inSessionId, true);
-            ret = ERR_IO_SOFT_RESET;
-            break;
-        }
-        *sessionId = inSessionId;
-        break;
-    }
-    return ret;
-}
-
-// Work in subcrete，Work thread is ready
-bool HdcDaemonUSB::ReadyForWorkThread(HSession hSession)
-{
-    HdcUSBBase::ReadyForWorkThread(hSession);
-    return true;
-};
-
-int HdcDaemonUSB::CloseBulkEp(bool bulkInOut, int bulkFd, uv_loop_t *loop)
-{
-    struct CtxCloseBulkEp {
-        uv_fs_t req;
-        HdcDaemonUSB *thisClass;
-        bool bulkInOut;
-    };
-    CtxCloseBulkEp *ctx = new(std::nothrow) CtxCloseBulkEp();
-    if (ctx == nullptr) {
-        WRITE_LOG(LOG_FATAL, "CloseBulkEp new ctx failed");
-        return -1;
-    }
-    uv_fs_t *req = &ctx->req;
-    req->data = ctx;
-    ctx->bulkInOut = bulkInOut;
-    ctx->thisClass = this;
-    isAlive = false;
-    WRITE_LOG(LOG_DEBUG, "CloseBulkEp bulkFd:%d", bulkFd);
-    uv_fs_close(loop, req, bulkFd, [](uv_fs_t *req) {
-        auto ctx = (CtxCloseBulkEp *)req->data;
-        WRITE_LOG(LOG_DEBUG, "Try to abort blukin write callback %s", ctx->bulkInOut ? "bulkin" : "bulkout");
-        if (ctx->bulkInOut) {
-            ctx->thisClass->usbHandle.bulkIn = 0;
-        } else {
-            ctx->thisClass->usbHandle.bulkOut = 0;
-        }
-        uv_fs_req_cleanup(req);
-        delete ctx;
-    });
-    return 0;
-}
-
-int HdcDaemonUSB::SendUSBIOSync(HSession hSession, HUSB hMainUSB, const uint8_t *data, const int length)
-{
-    int bulkIn = hMainUSB->bulkIn;
-    int childRet = 0;
-    int ret = ERR_IO_FAIL;
-    int offset = 0;
-    StartTraceScope("HdcDaemonUSB::SendUSBIOSync");
-    while (modRunning && isAlive && !hSession->isDead) {
-        childRet = write(bulkIn, const_cast<uint8_t *>(data) + offset, length - offset);
-        if (childRet <= 0) {
-            int err = errno;
-            if (err == EINTR) {
-                WRITE_LOG(LOG_WARN, "BulkinWrite write EINTR, try again, offset:%u bulkIn:%d bulkOut:%d",
-                    offset, bulkIn, hMainUSB->bulkOut);
-                continue;
-            } else {
-                WRITE_LOG(LOG_FATAL, "BulkinWrite write fatal errno %d", err);
-                isAlive = false;
-            }
-            break;
-        }
-        offset += childRet;
-        if (offset >= length) {
-            break;
-        }
-    }
-    if (offset == length) {
-        ret = length;
-    } else {
-        WRITE_LOG(LOG_FATAL, "BulkinWrite write failed, nsize:%d really:%d modRunning:%d isAlive:%d SessionDead:%d",
-                  length, offset, modRunning, isAlive, hSession->isDead);
-    }
-    return ret;
-}
-
-int HdcDaemonUSB::SendUSBRaw(HSession hSession, uint8_t *data, const int length)
-{
-    StartTraceScope("HdcDaemonUSB::SendUSBRaw");
-    HdcDaemon *daemon = (HdcDaemon *)hSession->classInstance;
-    uint32_t sessionId = hSession->sessionId;
-    std::unique_lock<std::mutex> lock(mutexUsbFfs);
-    if (daemon->IsSessionDeleted(sessionId)) {
-        WRITE_LOG(LOG_DEBUG, "SendUSBRaw session %u is deleted", sessionId);
-        return ERR_SESSION_DEAD;
-    }
-    ++hSession->ref;
-    int ret = SendUSBIOSync(hSession, &usbHandle, data, length);
-    --hSession->ref;
-    if (ret < 0) {
-        daemon->FreeSession(hSession->sessionId);
-        WRITE_LOG(LOG_DEBUG, "SendUSBRaw try to freesession");
-    }
-    return ret;
-}
-
-// cross thread call
-void HdcDaemonUSB::OnNewHandshakeOK(const uint32_t sessionId)
-{
-    currentSessionId = sessionId;  // sync with server, and set server's real Id
-}
-
-// MainThreadCall, when seession was freed
-void HdcDaemonUSB::OnSessionFreeFinally(const HSession hSession)
-{
-    WRITE_LOG(LOG_DEBUG, "OnSessionFreeFinally sid:%u currentsid:%u", hSession->sessionId, currentSessionId);
-    if (hSession->isSoftReset) {
-        WRITE_LOG(LOG_INFO, "OnSessionFreeFinally sid:%u softreset", hSession->sessionId);
-        return;
-    }
-    if (currentSessionId == hSession->sessionId) {
-        WRITE_LOG(LOG_DEBUG, "OnSessionFreeFinally set isAlive false");
-        isAlive = false;
-        // uv_cancel ctxRecv.req == UV_EBUSY, not effect immediately. It must be close by logic
-    }
-}
-
-HSession HdcDaemonUSB::PrepareNewSession(uint32_t sessionId, uint8_t *pRecvBuf, int recvBytesIO)
-{
-    HdcDaemon *daemon = reinterpret_cast<HdcDaemon *>(clsMainBase);
-    StartTraceScope("HdcDaemonUSB::PrepareNewSession");
-    HSession hChildSession = daemon->MallocSession(false, CONN_USB, this, sessionId);
-    if (!hChildSession) {
-        WRITE_LOG(LOG_FATAL, "malloc session failed sessionId:%u", sessionId);
-        return nullptr;
-    }
-    currentSessionId = sessionId;
-    Base::StartWorkThread(&daemon->loopMain, daemon->SessionWorkThread, Base::FinishWorkThread, hChildSession);
-
-    HSessionInfo hSessionInfo = new(std::nothrow) HdcSessionInfo();
-    if (hSessionInfo == nullptr) {
-        WRITE_LOG(LOG_FATAL, "PrepareNewSession new hSessionInfo failed");
-        return nullptr;
-    }
-    hSessionInfo->sessionId = hChildSession->sessionId;
-    hSessionInfo->classInstance = hChildSession->classInstance;
-    hSessionInfo->classModule = hChildSession->classModule;
-    hSessionInfo->hSession = hChildSession;
-    auto funcNewSessionUp = [](uv_timer_t *handle) -> void {
-        HSessionInfo hSessionInfo = reinterpret_cast<HSessionInfo>(handle->data);
-        if (hSessionInfo == nullptr) {
-            Base::TryCloseHandle(reinterpret_cast<uv_handle_t *>(handle), Base::CloseTimerCallback);
-            WRITE_LOG(LOG_FATAL, "hSessionInfo is null");
-            return;
-        }
-        HdcDaemon *daemon = reinterpret_cast<HdcDaemon *>(hSessionInfo->classInstance);
-        if (daemon->IsSessionDeleted(hSessionInfo->sessionId)) {
-            WRITE_LOG(LOG_INFO, "funcNewSessionUp session is deleted");
-            delete hSessionInfo;
-            handle->data = nullptr;
-            Base::TryCloseHandle(reinterpret_cast<uv_handle_t *>(handle), Base::CloseTimerCallback);
-            return;
-        }
-        HSession hChildSession = hSessionInfo->hSession;
-        if (hChildSession->childLoop.active_handles == 0) {
-            return;
-        }
-        if (!hChildSession->isDead) {
-            auto ctrl = daemon->BuildCtrlString(SP_START_SESSION, 0, nullptr, 0);
-            Base::SendToPollFd(hChildSession->ctrlFd[STREAM_MAIN], ctrl.data(), ctrl.size());
-            WRITE_LOG(LOG_DEBUG, "Main thread usbio migrate finish");
-        }
-        delete hSessionInfo;
-        handle->data = nullptr;
-        Base::TryCloseHandle(reinterpret_cast<uv_handle_t *>(handle), Base::CloseTimerCallback);
-    };
-    Base::TimerUvTask(&daemon->loopMain, hSessionInfo, funcNewSessionUp);
-    return hChildSession;
-}
-
-void HdcDaemonUSB::UvWriteCallback(uv_write_t *req, int status)
-{
-    StartTraceScope("HdcDaemonUSB::UvWriteCallback");
-    if (status < 0) {
-        constexpr int bufSize = 1024;
-        char buf[bufSize] = { 0 };
-        uv_strerror_r(status, buf, bufSize);
-        WRITE_LOG(LOG_WARN, "SendCallback failed,status:%d %s", status, buf);
-    }
-    UvData *uvData = reinterpret_cast<UvData *>(req->data);
-    if (uvData) {
-#ifndef CONFIG_USE_JEMALLOC_DFX_INIF
-        uvData->daemonUsb->cirbuf.Free(uvData->buf);
-#else
-        delete[] uvData->buf;
-#endif
-        delete uvData;
-    }
-    delete req;
-}
-
-int HdcDaemonUSB::UsbToStream(uv_stream_t *stream, const uint8_t *buf, const int size)
-{
-    StartTraceScope("HdcDaemonUSB::UsbToStream");
-    int ret = ERR_GENERIC;
-    uv_write_t *reqWrite = new uv_write_t();
-    if (!reqWrite) {
-        WRITE_LOG(LOG_WARN, "UsbToStream new write_t failed size:%d", size);
-#ifndef CONFIG_USE_JEMALLOC_DFX_INIF
-        cirbuf.Free(buf);
-#else
-        delete[] buf;
-#endif
-        return ERR_BUF_ALLOC;
-    }
-    uv_buf_t bfr;
-    while (true) {
-        UvData *uvData = new(std::nothrow) UvData();
-        if (uvData == nullptr) {
-            WRITE_LOG(LOG_FATAL, "UsbToStream new uvData failed size:%d", size);
-#ifndef CONFIG_USE_JEMALLOC_DFX_INIF
-            cirbuf.Free(buf);
-#else
-            delete[] buf;
-#endif
-            delete reqWrite;
-            return ERR_BUF_ALLOC;
-        }
-        uvData->daemonUsb = this;
-        uvData->buf = buf;
-        reqWrite->data = reinterpret_cast<void *>(uvData);
-        bfr.base = (char *)buf;
-        bfr.len = size;
-        if (!uv_is_writable(stream)) {
-            WRITE_LOG(LOG_WARN, "UsbToStream uv_is_writable false size:%d", size);
-            delete reqWrite;
-#ifndef CONFIG_USE_JEMALLOC_DFX_INIF
-            cirbuf.Free(buf);
-#else
-            delete[] buf;
-#endif
-            delete uvData;
-            break;
-        }
-        ret = uv_write(reqWrite, stream, &bfr, 1, UvWriteCallback);
-        if (ret < 0) {
-            WRITE_LOG(LOG_WARN, "UsbToStream uv_write false ret:%d", ret);
-            delete reqWrite;
-#ifndef CONFIG_USE_JEMALLOC_DFX_INIF
-            cirbuf.Free(buf);
-#else
-            delete[] buf;
-#endif
-            delete uvData;
-            ret = ERR_IO_FAIL;
-            break;
-        }
-        ret = size;
-        break;
-    }
-    return ret;
-}
-
-int HdcDaemonUSB::UsbToHdcProtocol(uv_stream_t *stream, uint8_t *appendData, int dataSize)
-{
-    StartTraceScope("HdcDaemonUSB::UsbToHdcProtocol");
-#ifndef CONFIG_USE_JEMALLOC_DFX_INIF
-    uint8_t *data = cirbuf.Malloc();
-#else
-    uint8_t *data = new uint8_t[dataSize];
-#endif
-    if (data == nullptr) {
-        WRITE_LOG(LOG_WARN, "UsbToHdcProtocol data nullptr");
-        return -1;
-    }
-    if (memcpy_s(data, dataSize, appendData, dataSize)) {
-        WRITE_LOG(LOG_WARN, "UsbToHdcProtocol memory copy failed dataSize:%d", dataSize);
-#ifndef CONFIG_USE_JEMALLOC_DFX_INIF
-        cirbuf.Free(data);
-#else
-        delete[] data;
-#endif
-        return ERR_BUF_COPY;
-    }
-    return UsbToStream(stream, data, dataSize);
-}
-
-int HdcDaemonUSB::DispatchToWorkThread(uint32_t sessionId, uint8_t *readBuf, int readBytes)
-{
-    HSession hChildSession = nullptr;
-    HdcDaemon *daemon = reinterpret_cast<HdcDaemon *>(clsMainBase);
-    int childRet = RET_SUCCESS;
-    StartTraceScope("HdcDaemonUSB::DispatchToWorkThread");
-    if (sessionId == 0) {
-        // hdc packet data
-        sessionId = currentSessionId;
-    }
-    if (currentSessionId != 0 && sessionId != currentSessionId) {
-        WRITE_LOG(LOG_WARN, "New session coming, restart old sessionId:%u", currentSessionId);
-        ResetOldSession(currentSessionId);
-        currentSessionId = 0;
-    }
-    hChildSession = daemon->AdminSession(OP_QUERY, sessionId, nullptr);
-    if (!hChildSession) {
-        hChildSession = PrepareNewSession(sessionId, readBuf, readBytes);
-        if (!hChildSession) {
-            WRITE_LOG(LOG_WARN, "prep new session err for sessionId:%u", sessionId);
-            return ERR_SESSION_NOFOUND;
-        }
-    }
-
-    if (hChildSession->childCleared || hChildSession->isDead) {
-        WRITE_LOG(LOG_WARN, "session dead clr:%d - %d", hChildSession->childCleared, hChildSession->isDead);
-        return ERR_SESSION_DEAD;
-    }
-    uv_stream_t *stream = reinterpret_cast<uv_stream_t *>(&hChildSession->dataPipe[STREAM_MAIN]);
-    if ((childRet = SendToHdcStream(hChildSession, stream, readBuf, readBytes)) < 0) {
-        WRITE_LOG(LOG_WARN, "DispatchToWorkThread SendToHdcStream err ret:%d", childRet);
-        return ERR_IO_FAIL;
-    }
-    return childRet;
-}
-
-bool HdcDaemonUSB::JumpAntiquePacket(const uint8_t &buf, ssize_t bytes) const
-{
-    constexpr size_t antiqueFlagSize = 4;
-    constexpr size_t antiqueFullSize = 24;
-    // anti CNXN 0x4e584e43
-    uint8_t flag[] = { 0x43, 0x4e, 0x58, 0x4e };
-    if (bytes == antiqueFullSize && !memcmp(&buf, flag, antiqueFlagSize)) {
-        return true;
-    }
-    return false;
-}
-
-// Only physically swap EP ports will be reset
-void HdcDaemonUSB::OnUSBRead(uv_fs_t *req)
-{  // Only read at the main thread
-    StartTraceScope("HdcDaemonUSB::OnUSBRead");
-    auto ctxIo = reinterpret_cast<CtxUvFileCommonIo *>(req->data);
-    auto hUSB = reinterpret_cast<HUSB>(ctxIo->data);
-    auto thisClass = reinterpret_cast<HdcDaemonUSB *>(ctxIo->thisClass);
-    uint8_t *bufPtr = ctxIo->buf;
-    ssize_t bytesIOBytes = req->result;
-    uint32_t sessionId = 0;
-    bool ret = false;
-    int childRet = 0;
-    if (bytesIOBytes > hUSB->wMaxPacketSizeSend && bytesIOBytes != thisClass->saveNextReadSize) {
-        WRITE_LOG(LOG_WARN, "Not full packet, wanted:%d really:%d", thisClass->saveNextReadSize, bytesIOBytes);
-    }
-    while (thisClass->isAlive) {
-        // Don't care is module running, first deal with this
-        if (bytesIOBytes < 0) {
-            // logic alive and EINTER is gdb attach
-            //
-            // [about gdb attach known issue]
-            // When GDB debugging is loaded, the number of USB read interrupts of libuv will increase. Multiple
-            // interrupts will increase the correctness of USB data reading. Setting GDB to asynchronous mode or using
-            // log debugging can avoid this problem
-            if (bytesIOBytes != -EINTR) {  // Epoll will be broken when gdb attach
-                constexpr int bufSize = 1024;
-                char buf[bufSize] = { 0 };
-                uv_strerror_r(bytesIOBytes, buf, bufSize);
-                WRITE_LOG(LOG_WARN, "USBIO ret:%d failed:%s", bytesIOBytes, buf);
-                ret = false;
-                break;
-            } else {
-                WRITE_LOG(LOG_ALL, "OnUSBRead signal EINTR");
-            }
-        } else if (bytesIOBytes == 0) {  // zero packet
-            WRITE_LOG(LOG_ALL, "Zero packet received");
-        } else {
-            if (thisClass->JumpAntiquePacket(*bufPtr, bytesIOBytes)) {
-                WRITE_LOG(LOG_DEBUG, "JumpAntiquePacket auto jump");
-                ret = true;
-                break;
-            }
-            // guess is head of packet
-            if ((childRet = thisClass->AvailablePacket((uint8_t *)bufPtr, bytesIOBytes, &sessionId)) != RET_SUCCESS) {
-                if (childRet != ERR_IO_SOFT_RESET) {
-                    WRITE_LOG(LOG_WARN, "AvailablePacket check failed, ret:%d buf:%-50s", bytesIOBytes, bufPtr);
-                    break;
-                }
-                // reset packet
-                childRet = 0;  // need max size
-            } else {
-                // AvailablePacket case
-                if ((childRet = thisClass->DispatchToWorkThread(sessionId, bufPtr, bytesIOBytes)) < 0) {
-                    WRITE_LOG(LOG_FATAL, "DispatchToWorkThread failed");
-                    break;
-                }
-            }
-        }
-        int nextReadSize = childRet == 0 ? hUSB->wMaxPacketSizeSend : std::min(childRet, Base::GetUsbffsBulkSize());
-        thisClass->saveNextReadSize = nextReadSize;
-        if (thisClass->LoopUSBRead(hUSB, nextReadSize) < 0) {
-            WRITE_LOG(LOG_FATAL, "LoopUSBRead failed");
-            break;
-        }
-        ret = true;
-        break;
-    }
-    if (!ret) {
-        WRITE_LOG(LOG_INFO, "OnUSBRead ret false, set isAlive = false");
-        thisClass->isAlive = false;
-        thisClass->ctxRecv.atPollQueue = false;
-    }
-}
-
-int HdcDaemonUSB::LoopUSBRead(HUSB hUSB, int readMaxWanted)
-{
-    StartTraceScope("HdcDaemonUSB::LoopUSBRead");
-    int ret = ERR_GENERIC;
-    HdcDaemon *daemon = reinterpret_cast<HdcDaemon *>(clsMainBase);
-    uv_buf_t iov;
-    ctxRecv.data = hUSB;
-    ctxRecv.bufSize = readMaxWanted;
-    ctxRecv.req = {};
-    uv_fs_t *req = &ctxRecv.req;
-    req->data = &ctxRecv;
-    iov = uv_buf_init(reinterpret_cast<char *>(ctxRecv.buf), ctxRecv.bufSize);
-    ret = uv_fs_read(&daemon->loopMain, req, hUSB->bulkOut, &iov, 1, -1, OnUSBRead);
-    if (ret < 0) {
-        WRITE_LOG(LOG_FATAL, "uv_fs_read ret:%d < 0", ret);
-        return ERR_API_FAIL;
-    }
-    ctxRecv.atPollQueue = true;
-    return RET_SUCCESS;
-}
-
-// Because USB can connect to only one host，daemonUSB is only one Session by default
-void HdcDaemonUSB::WatchEPTimer(uv_timer_t *handle)
-{
-    HdcDaemonUSB *thisClass = (HdcDaemonUSB *)handle->data;
-    HUSB hUSB = &thisClass->usbHandle;
-    HdcDaemon *daemon = reinterpret_cast<HdcDaemon *>(thisClass->clsMainBase);
-    if (thisClass->isAlive || thisClass->ctxRecv.atPollQueue) {
-        return;
-    }
-    bool resetEp = false;
-    do {
-        if (hUSB->bulkIn > 0) {
-            WRITE_LOG(LOG_DEBUG, "Watchdog close bulkin");
-            thisClass->CloseBulkEp(true, thisClass->usbHandle.bulkIn, &daemon->loopMain);
-            resetEp = true;
-        }
-        if (hUSB->bulkOut > 0) {
-            WRITE_LOG(LOG_DEBUG, "Watchdog close bulkout");
-            thisClass->CloseBulkEp(false, thisClass->usbHandle.bulkOut, &daemon->loopMain);
-            resetEp = true;
-        }
-        if (thisClass->controlEp > 0) {
-            Base::CloseFd(thisClass->controlEp);
-            resetEp = true;
-        }
-    } while (false);
-    if (resetEp || thisClass->usbHandle.bulkIn != 0 || thisClass->usbHandle.bulkOut != 0) {
-        return;
-    }
-    // until all bulkport reset
-    if (thisClass->ConnectEPPoint(hUSB) != RET_SUCCESS) {
-        WRITE_LOG(LOG_DEBUG, "WatchEPTimer ConnectEPPoint failed");
-        return;
-    }
-    // connect OK
-    thisClass->isAlive = true;
-    thisClass->LoopUSBRead(hUSB, hUSB->wMaxPacketSizeSend);
-}
-}  // namespace Hdc
diff --git a/hdc/src/daemon/daemon_usb.h b/hdc/src/daemon/daemon_usb.h
deleted file mode 100644
index d2b2c2d..0000000
--- a/hdc/src/daemon/daemon_usb.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_DAEMON_USB_H
-#define HDC_DAEMON_USB_H
-#include "usb.h"
-
-namespace Hdc {
-class HdcDaemonUSB : public HdcUSBBase {
-public:
-    HdcDaemonUSB(const bool serverOrDaemonIn, void *ptrMainBase);
-    virtual ~HdcDaemonUSB();
-    int Initial();
-    void Stop();
-    int SendUSBRaw(HSession hSession, uint8_t *data, const int length) override;
-    void OnNewHandshakeOK(const uint32_t sessionId);
-    void OnSessionFreeFinally(const HSession hSession);
-
-private:
-    struct CtxUvFileCommonIo {
-        void *thisClass;
-        void *data;
-        uint8_t *buf;
-        int bufSizeMax;
-        int bufSize;
-        bool atPollQueue;
-        uv_fs_t req;
-    };
-    static void OnUSBRead(uv_fs_t *req);
-    static void WatchEPTimer(uv_timer_t *handle);
-    static void UvWriteCallback(uv_write_t *req, int status);
-    int ConnectEPPoint(HUSB hUSB);
-    int DispatchToWorkThread(uint32_t sessionId, uint8_t *readBuf, int readBytes);
-    int AvailablePacket(uint8_t *ioBuf, int ioBytes, uint32_t *sessionId);
-    void CloseEndpoint(HUSB hUSB, bool closeCtrlEp = false);
-    string GetDevPath(const std::string &path);
-    bool ReadyForWorkThread(HSession hSession) override;
-    int LoopUSBRead(HUSB hUSB, int readMaxWanted);
-    HSession PrepareNewSession(uint32_t sessionId, uint8_t *pRecvBuf, int recvBytesIO);
-    bool JumpAntiquePacket(const uint8_t &buf, ssize_t bytes) const;
-    int SendUSBIOSync(HSession hSession, HUSB hMainUSB, const uint8_t *data, const int length);
-    int CloseBulkEp(bool bulkInOut, int bulkFd, uv_loop_t *loop);
-    void ResetOldSession(uint32_t sessionId, bool isSoftReset = false);
-    int GetMaxPacketSize(int fdFfs);
-    int UsbToHdcProtocol(uv_stream_t *stream, uint8_t *appendData, int dataSize) override;
-    void FillUsbV2Head(struct UsbFunctionfsDescV2 &descUsbFfs);
-    int UsbToStream(uv_stream_t *stream, const uint8_t *buf, const int size);
-
-    HdcUSB usbHandle = {};
-    string basePath;                // usb device's base path
-    uint32_t currentSessionId = 0;  // USB mode,limit only one session
-    uv_timer_t checkEP;             // server-use
-    mutex mutexUsbFfs;
-    bool isAlive = false;
-    int controlEp = 0;  // EP0
-    CtxUvFileCommonIo ctxRecv = {};
-    int saveNextReadSize = 0;
-#ifndef CONFIG_USE_JEMALLOC_DFX_INIF
-    CircleBuffer cirbuf;
-#endif
-};
-}  // namespace Hdc
-#endif
diff --git a/hdc/src/daemon/etc/BUILD.gn b/hdc/src/daemon/etc/BUILD.gn
deleted file mode 100644
index 403d003..0000000
--- a/hdc/src/daemon/etc/BUILD.gn
+++ /dev/null
@@ -1,67 +0,0 @@
-# Copyright (c) 2022 Huawei Device Co., Ltd.
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-import("//build/ohos.gni")
-import("//developtools/hdc/hdc.gni")
-
-group("daemon_etc") {
-  deps = [
-    ":hdc.para",
-    ":hdc.para.dac",
-    ":hdcd.cfg",
-  ]
-}
-
-ohos_prebuilt_etc("hdcd.cfg") {
-  source = "hdcd.root.cfg"
-  if (build_variant == "user") {
-    source = "hdcd.cfg"
-  }
-  if (hdc_feature_support_sudo && build_variant == "user") {
-    source = "hdcd_sudo.cfg"
-  }
-  relative_install_dir = "init"
-  install_images = [
-    "system",
-    "updater",
-  ]
-  output = "hdcd.cfg"
-  part_name = "hdc"
-  subsystem_name = "developtools"
-}
-
-ohos_prebuilt_etc("hdc.para") {
-  source = "hdc.root.para"
-  if (build_variant == "user") {
-    source = "hdc.para"
-  }
-  relative_install_dir = "param"
-  install_images = [
-    "system",
-    "updater",
-  ]
-  output = "hdc.para"
-  part_name = "hdc"
-  subsystem_name = "developtools"
-}
-
-ohos_prebuilt_etc("hdc.para.dac") {
-  source = "hdc.para.dac"
-  relative_install_dir = "param"
-  install_images = [
-    "system",
-    "updater",
-  ]
-  part_name = "hdc"
-  subsystem_name = "developtools"
-}
diff --git a/hdc/src/daemon/etc/hdc.para b/hdc/src/daemon/etc/hdc.para
deleted file mode 100644
index f6e87da..0000000
--- a/hdc/src/daemon/etc/hdc.para
+++ /dev/null
@@ -1,17 +0,0 @@
-# Copyright (C) 2024 Huawei Device Co., Ltd.
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-const.hdc.version = "Ver: 3.0.0b"
-persist.hdc.mode.usb = "disable"
-persist.hdc.mode.tcp = "disable"
-persist.hdc.mode.uart = "disable"
diff --git a/hdc/src/daemon/etc/hdc.para.dac b/hdc/src/daemon/etc/hdc.para.dac
deleted file mode 100644
index d79e25a..0000000
--- a/hdc/src/daemon/etc/hdc.para.dac
+++ /dev/null
@@ -1,46 +0,0 @@
-# Copyright (c) 2022 Huawei Device Co., Ltd.
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-sys.usb.ffs.ready = root:shell:0660
-sys.usb.ffs.ready.hdc = root:shell:0660
-persist.hdc.root = root:shell:0660
-persist.hdc.mode = root:shell:0660
-persist.hdc.port = root:shell:0660
-persist.hdc.uv.threads = root:shell:0660
-persist.hdc.daemon.auth_result = root:shell:0660
-persist.hdc.client.hostname = root:shell:0660
-persist.hdc.client.pubkey_sha256 = root:shell:0660
-persist.hdc.daemon.auth_cancel = root:shell:0660
-const.hdc.secure = root:shell:0660
-const.hdc.version = root:shell:0644
-
-# hdc control, init, edm and usb_host can write control by selinux
-persist.hdc.control = usb_host:edm:0664
-persist.hdc.control.shell = root:shell:0644
-persist.hdc.control.file = root:shell:0644
-persist.hdc.control.fport = root:shell:0644
-persist.hdc.control_system = system:system:0664
-
-# hdcd can be replaced when it is without uart
-# you should setenforce 0 and mount to write /system
-persist.hdc.replace = root:root:0770
-
-#for atcmd HDCAUTHPASS
-persist.hdc.auth_bypass = root:shell:0666
-
-# for hdcd jdwp
-persist.hdc.jdwp = root:shell:0664
-
-persist.hdc.mode.usb = root:shell:0660
-persist.hdc.mode.tcp = root:shell:0660
-persist.hdc.mode.uart = root:shell:0660
diff --git a/hdc/src/daemon/etc/hdc.root.para b/hdc/src/daemon/etc/hdc.root.para
deleted file mode 100644
index 3a80aa8..0000000
--- a/hdc/src/daemon/etc/hdc.root.para
+++ /dev/null
@@ -1,17 +0,0 @@
-# Copyright (C) 2024 Huawei Device Co., Ltd.
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-
-const.hdc.version = "Ver: 3.0.0b"
-persist.hdc.mode.usb = "enable"
-persist.hdc.mode.tcp = "disable"
-persist.hdc.mode.uart = "disable"
diff --git a/hdc/src/daemon/etc/hdcd.cfg b/hdc/src/daemon/etc/hdcd.cfg
deleted file mode 100644
index 5ef970e..0000000
--- a/hdc/src/daemon/etc/hdcd.cfg
+++ /dev/null
@@ -1,116 +0,0 @@
-{
-    "jobs" : [{
-            "name" : "post-fs-data",
-            "cmds" : [
-                "mkdir /data/service/el1/public/hdc 0775 root shell",
-                "restorecon /data/service/el1/public/hdc"
-            ]
-        },{
-            "name" : "param:persist.hdc.control=false",
-            "condition" : "persist.hdc.control=false",
-            "cmds" : [
-                "setparam persist.hdc.control.shell false",
-                "setparam persist.hdc.control.file false",
-                "setparam persist.hdc.control.fport false"
-            ]
-        },{
-            "name" : "param:persist.hdc.control=true",
-            "condition" : "persist.hdc.control=true",
-            "cmds" : [
-                "setparam persist.hdc.control.shell true",
-                "setparam persist.hdc.control.file true",
-                "setparam persist.hdc.control.fport true"
-            ]
-        },{
-            "name" : "param:persist.hdc.control_system=true",
-            "condition" : "persist.hdc.control_system=true",
-            "cmds" : [
-                "setparam persist.hdc.control true"
-            ]
-        },{
-            "name" : "param:persist.hdc.control_system=false",
-            "condition" : "persist.hdc.control_system=false",
-            "cmds" : [
-                "setparam persist.hdc.control false"
-            ]
-        },{
-            "name" : "param:persist.hdc.daemon.auth_cancel=true",
-            "condition" : "persist.hdc.daemon.auth_cancel=true",
-            "cmds" : [
-                "reset hdcd"
-            ]
-        },{
-            "name" : "boot && param:const.runmode=normal && const.secure=1 && (const.product.devicetype=phone || const.product.devicetype=tablet)",
-            "condition" : "boot && const.runmode=normal && const.secure=1 && (const.product.devicetype=phone || const.product.devicetype=tablet)",
-            "cmds" : [
-                "setparam const.hdc.secure 1"
-            ]
-        },{
-            "name" : "param:persist.hdc.mode.tcp=enable",
-            "condition" : "persist.hdc.mode.tcp=enable",
-            "cmds" : [
-                "stop hdcd",
-                "sleep 1",
-                "start hdcd"
-            ]
-        },{
-            "name" : "param:persist.hdc.mode.tcp=disable && param:persist.hdc.mode.usb=enable",
-            "condition" : "persist.hdc.mode.tcp=disable && persist.hdc.mode.usb=enable",
-            "cmds" : [
-                "stop hdcd",
-                "sleep 1",
-                "start hdcd"
-            ]
-        },{
-            "name" : "param:persist.hdc.mode.tcp=disable && param:persist.hdc.mode.usb=disable",
-            "condition" : "persist.hdc.mode.tcp=disable && persist.hdc.mode.usb=disable",
-            "cmds" : [
-                "stop hdcd"
-            ]
-        }
-    ],
-    "services" : [{
-            "name" : "hdcd",
-            "path" : ["/system/bin/hdcd"],
-            "caps" : ["CAP_NET_RAW"],
-            "uid" : "shell",
-            "gid" : [ "shell", "log", "readproc", "file_manager", "user_data_rw", "netsys_socket" ],
-            "socket" : [{
-                "name" : "hdcd",
-                "family" : "AF_UNIX",
-                "type" : "SOCK_SEQPACKET",
-                "protocol" : "default",
-                "permissions" : "0660",
-                "uid" : "shell",
-                "gid" : "shell"
-            }],
-            "critical" : [ 0, 5, 10 ],
-            "apl" : "normal",
-            "permission" : [
-                "ohos.permission.DUMP",
-                "ohos.permission.GET_BUNDLE_INFO_PRIVILEGED",
-                "ohos.permission.INSTALL_BUNDLE",
-                "ohos.permission.REMOVE_CACHE_FILES",
-                "ohos.permission.CLEAN_BACKGROUND_PROCESSES",
-                "ohos.permission.START_ABILITIES_FROM_BACKGROUND",
-                "ohos.permission.CLEAN_APPLICATION_DATA",
-                "ohos.permission.START_SYSTEM_DIALOG",
-                "ohos.permission.GET_RUNNING_INFO"
-            ],
-            "permission_acls" : [
-                "ohos.permission.DUMP",
-                "ohos.permission.GET_BUNDLE_INFO_PRIVILEGED",
-                "ohos.permission.INSTALL_BUNDLE",
-                "ohos.permission.REMOVE_CACHE_FILES",
-                "ohos.permission.START_ABILITIES_FROM_BACKGROUND",
-                "ohos.permission.CLEAN_APPLICATION_DATA",
-                "ohos.permission.START_SYSTEM_DIALOG",
-                "ohos.permission.GET_RUNNING_INFO"
-            ],
-            "sandbox" : 0,
-            "start-mode" : "condition",
-            "secon" : "u:r:hdcd:s0",
-            "disabled" : 1
-        }
-    ]
-}
diff --git a/hdc/src/daemon/etc/hdcd.root.cfg b/hdc/src/daemon/etc/hdcd.root.cfg
deleted file mode 100644
index a5f9797..0000000
--- a/hdc/src/daemon/etc/hdcd.root.cfg
+++ /dev/null
@@ -1,139 +0,0 @@
-{
-    "jobs" : [{
-            "name" : "post-fs-data",
-            "cmds" : [
-                "mkdir /data/service/el1/public/hdc 0775 root shell",
-                "restorecon /data/service/el1/public/hdc"
-            ]
-        },{
-            "name" : "param:persist.hdc.control=false",
-            "condition" : "persist.hdc.control=false",
-            "cmds" : [
-                "setparam persist.hdc.control.shell false",
-                "setparam persist.hdc.control.file false",
-                "setparam persist.hdc.control.fport false"
-            ]
-        },{
-            "name" : "param:persist.hdc.control=true",
-            "condition" : "persist.hdc.control=true",
-            "cmds" : [
-                "setparam persist.hdc.control.shell true",
-                "setparam persist.hdc.control.file true",
-                "setparam persist.hdc.control.fport true"
-            ]
-        },{
-            "name" : "param:persist.hdc.control_system=true",
-            "condition" : "persist.hdc.control_system=true",
-            "cmds" : [
-                "setparam persist.hdc.control true"
-            ]
-        },{
-            "name" : "param:persist.hdc.control_system=false",
-            "condition" : "persist.hdc.control_system=false",
-            "cmds" : [
-                "setparam persist.hdc.control false"
-            ]
-        },{
-            "name" : "param:persist.hdc.replace=true",
-            "condition" : "persist.hdc.replace=true",
-            "cmds" : [
-                "stop hdcd",
-                "chmod 0755 /data/hdcd",
-                "chmod 0644 /data/libuv.so",
-                "chmod 0644 /data/libhdc.dylib.so",
-                "chmod 0644 /data/libylong_runtime.dylib.so",
-                "sleep 1",
-                "copy /data/hdcd /system/bin/hdcd",
-                "copy /data/libuv.so /system/lib64/libuv.so",
-                "copy /data/libuv.so /system/lib/libuv.so",
-                "copy /data/libhdc.dylib.so /system/lib64/libhdc.dylib.so",
-                "copy /data/libhdc.dylib.so /system/lib/libhdc.dylib.so",
-                "copy /data/libylong_runtime.dylib.so /system/lib64/libylong_runtime.dylib.so",
-                "copy /data/libylong_runtime.dylib.so /system/lib/libylong_runtime.dylib.so",
-                "start hdcd",
-                "setparam persist.hdc.replace false"
-            ]
-        },{
-            "name" : "boot && param:const.hdc.secure=0",
-            "condition" : "boot && const.secure=0",
-            "cmds" : [
-                "setparam const.hdc.secure 0"
-            ]
-        },{
-            "name" : "param:persist.hdc.mode.tcp=enable",
-            "condition" : "persist.hdc.mode.tcp=enable",
-            "cmds" : [
-                "stop hdcd",
-                "sleep 1",
-                "start hdcd"
-            ]
-        },{
-            "name" : "param:persist.hdc.mode.tcp=disable && param:persist.hdc.mode.usb=enable",
-            "condition" : "persist.hdc.mode.tcp=disable && persist.hdc.mode.usb=enable",
-            "cmds" : [
-                "stop hdcd",
-                "sleep 1",
-                "start hdcd"
-            ]
-        },{
-            "name" : "param:persist.hdc.mode.tcp=disable && param:persist.hdc.mode.usb=disable",
-            "condition" : "persist.hdc.mode.tcp=disable && persist.hdc.mode.usb=disable",
-            "cmds" : [
-                "stop hdcd"
-            ]
-        }
-    ],
-    "services" : [{
-            "name" : "hdcd",
-            "path" : ["/system/bin/hdcd"],
-            "uid" : "root",
-            "gid" : [ "root", "shell", "log", "readproc", "file_manager", "user_data_rw" ],
-            "setuid" : true,
-            "socket" : [{
-                "name" : "hdcd",
-                "family" : "AF_UNIX",
-                "type" : "SOCK_SEQPACKET",
-                "protocol" : "default",
-                "permissions" : "0660",
-                "uid" : "root",
-                "gid" : "shell"
-            }],
-            "critical" : [ 0, 5, 10 ],
-            "apl" : "normal",
-            "permission" : [
-                "ohos.permission.CHANGE_ABILITY_ENABLED_STATE",
-                "ohos.permission.DUMP",
-                "ohos.permission.GET_BUNDLE_INFO_PRIVILEGED",
-                "ohos.permission.INSTALL_BUNDLE",
-                "ohos.permission.REMOVE_CACHE_FILES",
-                "ohos.permission.ACCELEROMETER",
-                "ohos.permission.CLEAN_BACKGROUND_PROCESSES",
-                "ohos.permission.START_ABILITIES_FROM_BACKGROUND",
-                "ohos.permission.PERMISSION_USED_STATS",
-                "ohos.permission.NOTIFICATION_CONTROLLER",
-                "ohos.permission.PUBLISH_SYSTEM_COMMON_EVENT",
-                "ohos.permission.CLEAN_APPLICATION_DATA",
-                "ohos.permission.START_SYSTEM_DIALOG",
-                "ohos.permission.GET_RUNNING_INFO"
-            ],
-            "permission_acls" : [
-                "ohos.permission.CHANGE_ABILITY_ENABLED_STATE",
-                "ohos.permission.DUMP",
-                "ohos.permission.GET_BUNDLE_INFO_PRIVILEGED",
-                "ohos.permission.INSTALL_BUNDLE",
-                "ohos.permission.REMOVE_CACHE_FILES",
-                "ohos.permission.START_ABILITIES_FROM_BACKGROUND",
-                "ohos.permission.PERMISSION_USED_STATS",
-                "ohos.permission.NOTIFICATION_CONTROLLER",
-                "ohos.permission.PUBLISH_SYSTEM_COMMON_EVENT",
-                "ohos.permission.CLEAN_APPLICATION_DATA",
-                "ohos.permission.START_SYSTEM_DIALOG",
-                "ohos.permission.GET_RUNNING_INFO"
-            ],
-            "sandbox" : 0,
-            "start-mode" : "condition",
-            "secon" : "u:r:su:s0",
-            "disabled" : 1
-        }
-    ]
-}
diff --git a/hdc/src/daemon/etc/hdcd_sudo.cfg b/hdc/src/daemon/etc/hdcd_sudo.cfg
deleted file mode 100644
index 82c7f0c..0000000
--- a/hdc/src/daemon/etc/hdcd_sudo.cfg
+++ /dev/null
@@ -1,132 +0,0 @@
-{
-    "jobs" : [{
-            "name" : "post-fs-data",
-            "cmds" : [
-                "mkdir /data/service/el1/public/hdc 0775 root shell",
-                "restorecon /data/service/el1/public/hdc"
-            ]
-        },{
-            "name" : "param:persist.hdc.control=false",
-            "condition" : "persist.hdc.control=false",
-            "cmds" : [
-                "setparam persist.hdc.control.shell false",
-                "setparam persist.hdc.control.file false",
-                "setparam persist.hdc.control.fport false"
-            ]
-        },{
-            "name" : "param:persist.hdc.control=true",
-            "condition" : "persist.hdc.control=true",
-            "cmds" : [
-                "setparam persist.hdc.control.shell true",
-                "setparam persist.hdc.control.file true",
-                "setparam persist.hdc.control.fport true"
-            ]
-        },{
-            "name" : "param:persist.hdc.control_system=true",
-            "condition" : "persist.hdc.control_system=true",
-            "cmds" : [
-                "setparam persist.hdc.control true"
-            ]
-        },{
-            "name" : "param:persist.hdc.control_system=false",
-            "condition" : "persist.hdc.control_system=false",
-            "cmds" : [
-                "setparam persist.hdc.control false"
-            ]
-        },{
-            "name" : "param:persist.hdc.daemon.auth_cancel=true",
-            "condition" : "persist.hdc.daemon.auth_cancel=true",
-            "cmds" : [
-                "reset hdcd"
-            ]
-        },{
-            "name" : "boot && param:const.secure=1 && (const.product.devicetype=phone || const.product.devicetype=tablet)",
-            "condition" : "boot && const.secure=1 && (const.product.devicetype=phone || const.product.devicetype=tablet)",
-            "cmds" : [
-                "setparam const.hdc.secure 1"
-            ]
-        },{
-            "name" : "param:persist.hdc.mode.tcp=enable",
-            "condition" : "persist.hdc.mode.tcp=enable",
-            "cmds" : [
-                "stop hdcd",
-                "sleep 1",
-                "start hdcd"
-            ]
-        },{
-            "name" : "param:persist.hdc.mode.tcp=disable && param:persist.hdc.mode.usb=enable",
-            "condition" : "persist.hdc.mode.tcp=disable && persist.hdc.mode.usb=enable",
-            "cmds" : [
-                "stop hdcd",
-                "sleep 1",
-                "start hdcd"
-            ]
-        },{
-            "name" : "param:persist.hdc.mode.tcp=disable && param:persist.hdc.mode.usb=disable",
-            "condition" : "persist.hdc.mode.tcp=disable && persist.hdc.mode.usb=disable",
-            "cmds" : [
-                "stop hdcd"
-            ]
-        }
-    ],
-    "services" : [{
-            "name" : "hdcd",
-            "path" : ["/system/bin/hdcd"],
-            "uid" : "shell",
-            "gid" : [ "shell", "log", "readproc", "file_manager", "user_data_rw", "netsys_socket" ],
-            "socket" : [{
-                "name" : "hdcd",
-                "family" : "AF_UNIX",
-                "type" : "SOCK_SEQPACKET",
-                "protocol" : "default",
-                "permissions" : "0660",
-                "uid" : "shell",
-                "gid" : "shell"
-            }],
-            "critical" : [ 0, 5, 10 ],
-            "apl" : "normal",
-            "permission" : [
-                "ohos.permission.CHANGE_ABILITY_ENABLED_STATE",
-                "ohos.permission.DUMP",
-                "ohos.permission.GET_BUNDLE_INFO_PRIVILEGED",
-                "ohos.permission.INSTALL_BUNDLE",
-                "ohos.permission.LISTEN_BUNDLE_CHANGE",
-                "ohos.permission.REMOVE_CACHE_FILES",
-                "ohos.permission.ACCELEROMETER",
-                "ohos.permission.CLEAN_BACKGROUND_PROCESSES",
-                "ohos.permission.START_ABILITIES_FROM_BACKGROUND",
-                "ohos.permission.PERMISSION_USED_STATS",
-                "ohos.permission.NOTIFICATION_CONTROLLER",
-                "ohos.permission.PUBLISH_SYSTEM_COMMON_EVENT",
-                "ohos.permission.CLEAN_APPLICATION_DATA",
-                "ohos.permission.START_SYSTEM_DIALOG",
-                "ohos.permission.GET_RUNNING_INFO",
-                "ohos.permission.MANAGE_USER_IDM",
-                "ohos.permission.ACCESS_PIN_AUTH",
-                "ohos.permission.ACCESS_USER_AUTH_INTERNAL"
-            ],
-            "permission_acls" : [
-                "ohos.permission.CHANGE_ABILITY_ENABLED_STATE",
-                "ohos.permission.DUMP",
-                "ohos.permission.GET_BUNDLE_INFO_PRIVILEGED",
-                "ohos.permission.INSTALL_BUNDLE",
-                "ohos.permission.LISTEN_BUNDLE_CHANGE",
-                "ohos.permission.REMOVE_CACHE_FILES",
-                "ohos.permission.START_ABILITIES_FROM_BACKGROUND",
-                "ohos.permission.PERMISSION_USED_STATS",
-                "ohos.permission.NOTIFICATION_CONTROLLER",
-                "ohos.permission.PUBLISH_SYSTEM_COMMON_EVENT",
-                "ohos.permission.CLEAN_APPLICATION_DATA",
-                "ohos.permission.START_SYSTEM_DIALOG",
-                "ohos.permission.GET_RUNNING_INFO",
-                "ohos.permission.MANAGE_USER_IDM",
-                "ohos.permission.ACCESS_PIN_AUTH",
-                "ohos.permission.ACCESS_USER_AUTH_INTERNAL"
-            ],
-            "sandbox" : 0,
-            "start-mode" : "condition",
-            "secon" : "u:r:hdcd:s0",
-            "disabled" : 1
-        }
-    ]
-}
diff --git a/hdc/src/daemon/jdwp.cpp b/hdc/src/daemon/jdwp.cpp
deleted file mode 100644
index 62de24f..0000000
--- a/hdc/src/daemon/jdwp.cpp
+++ /dev/null
@@ -1,720 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "jdwp.h"
-#include <sys/eventfd.h>
-#include <thread>
-#include "system_depend.h"
-
-namespace Hdc {
-HdcJdwp::HdcJdwp(uv_loop_t *loopIn)
-{
-    listenPipe.data = this;
-    loop = loopIn;
-    refCount = 0;
-    uv_rwlock_init(&lockMapContext);
-    uv_rwlock_init(&lockJdwpTrack);
-    awakenPollFd = -1;
-    stop = false;
-}
-
-HdcJdwp::~HdcJdwp()
-{
-    Base::CloseFd(awakenPollFd);
-    uv_rwlock_destroy(&lockMapContext);
-    uv_rwlock_destroy(&lockJdwpTrack);
-}
-
-bool HdcJdwp::ReadyForRelease()
-{
-    return refCount == 0;
-}
-
-void HdcJdwp::Stop()
-{
-    stop = true;
-    WakePollThread();
-    auto funcListenPipeClose = [](uv_handle_t *handle) -> void {
-        HdcJdwp *thisClass = (HdcJdwp *)handle->data;
-        --thisClass->refCount;
-    };
-    Base::TryCloseHandle((const uv_handle_t *)&listenPipe, funcListenPipeClose);
-    freeContextMutex.lock();
-    for (auto &&obj : mapCtxJdwp) {
-        HCtxJdwp v = obj.second;
-        FreeContext(v);
-    }
-    AdminContext(OP_CLEAR, 0, nullptr);
-    freeContextMutex.unlock();
-}
-
-void *HdcJdwp::MallocContext()
-{
-    HCtxJdwp ctx = nullptr;
-    if ((ctx = new ContextJdwp()) == nullptr) {
-        return nullptr;
-    }
-    ctx->isDebug = 0;
-    ctx->thisClass = this;
-    ctx->pipe.data = ctx;
-    ++refCount;
-    return ctx;
-}
-
-// Single thread, two parameters can be used
-void HdcJdwp::FreeContext(HCtxJdwp ctx)
-{
-    if (ctx->finish) {
-        return;
-    }
-    ctx->finish = true;
-    WRITE_LOG(LOG_INFO, "FreeContext for targetPID :%d", ctx->pid);
-    Base::TryCloseHandle((const uv_handle_t *)&ctx->pipe);
-    if (!stop) {
-        AdminContext(OP_REMOVE, ctx->pid, nullptr);
-    }
-    auto funcReqClose = [](uv_idle_t *handle) -> void {
-        HCtxJdwp ctxIn = (HCtxJdwp)handle->data;
-        --ctxIn->thisClass->refCount;
-        Base::TryCloseHandle((uv_handle_t *)handle, Base::CloseIdleCallback);
-#ifndef HDC_EMULATOR
-        if (ctxIn != nullptr) {
-            delete ctxIn;
-            ctxIn = nullptr;
-        }
-#endif
-    };
-    Base::IdleUvTask(loop, ctx, funcReqClose);
-}
-
-void HdcJdwp::RemoveFdFromPollList(uint32_t pid)
-{
-    for (auto &&pair : pollNodeMap) {
-        if (pair.second.ppid == pid) {
-            WRITE_LOG(LOG_INFO, "RemoveFdFromPollList for pid:%d.", pid);
-            pollNodeMap.erase(pair.second.pollfd.fd);
-            break;
-        }
-    }
-}
-
-void HdcJdwp::ReadStream(uv_stream_t *pipe, ssize_t nread, const uv_buf_t *buf)
-{
-    static std::once_flag firstLog;
-    std::call_once(firstLog, [&]() { SystemDepend::SetDevItem("persist.hdc.jdwp", "0"); });
-    
-    bool ret = true;
-    if (nread == UV_ENOBUFS) {  // It is definite enough, usually only 4 bytes
-        ret = false;
-        WRITE_LOG(LOG_DEBUG, "HdcJdwp::ReadStream IOBuf max");
-    } else if (nread == 0) {
-        return;
-#ifdef JS_JDWP_CONNECT
-    } else if (nread < signed(JS_PKG_MIN_SIZE + sizeof(JsMsgHeader)) ||
-               nread > signed(JS_PKG_MAX_SIZE + sizeof(JsMsgHeader))) {
-#else
-    } else if (nread < 0 || nread != 4) {  // 4 : 4 bytes
-#endif  // JS_JDWP_CONNECT
-        ret = false;
-        WRITE_LOG(LOG_DEBUG, "HdcJdwp::ReadStream invalid package nread:%d.", nread);
-    }
-
-    HCtxJdwp ctxJdwp = static_cast<HCtxJdwp>(pipe->data);
-    HdcJdwp *thisClass = static_cast<HdcJdwp *>(ctxJdwp->thisClass);
-    if (ret) {
-        uint32_t pid = 0;
-        char *p = ctxJdwp->buf;
-        if (nread == sizeof(uint32_t)) {  // Java: pid
-            pid = atoi(p);
-        } else {  // JS:pid PkgName
-#ifdef JS_JDWP_CONNECT
-            // pid isDebug pkgName/processName
-            struct JsMsgHeader *jsMsg = reinterpret_cast<struct JsMsgHeader *>(p);
-            if (jsMsg->msgLen == nread) {
-                pid = jsMsg->pid;
-                string pkgName = string((char *)p + sizeof(JsMsgHeader), jsMsg->msgLen - sizeof(JsMsgHeader));
-                ctxJdwp->pkgName = pkgName;
-                ctxJdwp->isDebug = jsMsg->isDebug;
-            } else {
-                ret = false;
-                WRITE_LOG(LOG_DEBUG, "HdcJdwp::ReadStream invalid js package size %d:%d.", jsMsg->msgLen, nread);
-            }
-#endif  // JS_JDWP_CONNECT
-        }
-        if (pid > 0) {
-            ctxJdwp->pid = pid;
-#ifdef JS_JDWP_CONNECT
-            WRITE_LOG(LOG_DEBUG, "JDWP accept pid:%d-pkg:%s isDebug:%d",
-                pid, ctxJdwp->pkgName.c_str(), ctxJdwp->isDebug);
-#else
-            WRITE_LOG(LOG_DEBUG, "JDWP accept pid:%d", pid);
-#endif  // JS_JDWP_CONNECT
-            thisClass->AdminContext(OP_ADD, pid, ctxJdwp);
-            ret = true;
-            int fd = -1;
-            if (uv_fileno(reinterpret_cast<uv_handle_t *>(&(ctxJdwp->pipe)), &fd) < 0) {
-                WRITE_LOG(LOG_DEBUG, "HdcJdwp::ReadStream uv_fileno fail.");
-            } else {
-                thisClass->freeContextMutex.lock();
-                thisClass->pollNodeMap.emplace(fd, PollNode(fd, pid));
-                thisClass->freeContextMutex.unlock();
-                thisClass->WakePollThread();
-            }
-        }
-    }
-    Base::ZeroArray(ctxJdwp->buf);
-    if (!ret) {
-        WRITE_LOG(LOG_INFO, "ReadStream proc:%d err, free it.", ctxJdwp->pid);
-        thisClass->freeContextMutex.lock();
-        thisClass->FreeContext(ctxJdwp);
-        thisClass->freeContextMutex.unlock();
-    }
-}
-
-#ifdef JS_JDWP_CONNECT
-string HdcJdwp::GetProcessListExtendPkgName(uint8_t dr)
-{
-    constexpr uint8_t releaseApp = 2;
-    constexpr uint8_t allAppWithDr = 3;
-    string ret;
-    uv_rwlock_rdlock(&lockMapContext);
-    for (auto &&v : mapCtxJdwp) {
-        HCtxJdwp hj = v.second;
-        if (dr == 0) {
-            // allApp
-            ret += std::to_string(v.first) + " " + hj->pkgName + "\n";
-        } else if (dr == 1) {
-            // debugApp
-            if (hj->isDebug) {
-                ret += std::to_string(v.first) + " " + hj->pkgName + "\n";
-            }
-        } else if (dr == releaseApp) {
-            // releaseApp
-            if (!hj->isDebug) {
-                ret += std::to_string(v.first) + " " + hj->pkgName + "\n";
-            }
-        } else if (dr == allAppWithDr) {
-            // allApp with display debug or release
-            string apptype = "release";
-            if (hj->isDebug) {
-                apptype = "debug";
-            }
-            ret += std::to_string(v.first) + " " + hj->pkgName + " " + apptype + "\n";
-        }
-    }
-    uv_rwlock_rdunlock(&lockMapContext);
-    return ret;
-}
-#endif  // JS_JDWP_CONNECT
-
-void HdcJdwp::AcceptClient(uv_stream_t *server, int status)
-{
-    uv_pipe_t *listenPipe = (uv_pipe_t *)server;
-    HdcJdwp *thisClass = (HdcJdwp *)listenPipe->data;
-    HCtxJdwp ctxJdwp = (HCtxJdwp)thisClass->MallocContext();
-    if (!ctxJdwp) {
-        return;
-    }
-    uv_pipe_init(thisClass->loop, &ctxJdwp->pipe, 1);
-    if (uv_accept(server, (uv_stream_t *)&ctxJdwp->pipe) < 0) {
-        WRITE_LOG(LOG_DEBUG, "uv_accept failed");
-        thisClass->freeContextMutex.lock();
-        thisClass->FreeContext(ctxJdwp);
-        thisClass->freeContextMutex.unlock();
-        return;
-    }
-    auto funAlloc = [](uv_handle_t *handle, size_t sizeSuggested, uv_buf_t *buf) -> void {
-        HCtxJdwp ctxJdwp = (HCtxJdwp)handle->data;
-        buf->base = (char *)ctxJdwp->buf;
-        buf->len = sizeof(ctxJdwp->buf);
-    };
-    uv_read_start((uv_stream_t *)&ctxJdwp->pipe, funAlloc, ReadStream);
-}
-
-// Test bash connnet(UNIX-domain sockets):nc -U path/ohjpid-control < hexpid.file
-// Test uv connect(pipe): 'uv_pipe_connect'
-bool HdcJdwp::JdwpListen()
-{
-#ifdef HDC_PCDEBUG
-    // if test, can be enabled
-    return true;
-    const char jdwpCtrlName[] = { 'o', 'h', 'j', 'p', 'i', 'd', '-', 'c', 'o', 'n', 't', 'r', 'o', 'l', 0 };
-    unlink(jdwpCtrlName);
-#else
-    const char jdwpCtrlName[] = { '\0', 'o', 'h', 'j', 'p', 'i', 'd', '-', 'c', 'o', 'n', 't', 'r', 'o', 'l', 0 };
-#endif
-    const int DEFAULT_BACKLOG = 4;
-    bool ret = false;
-    while (true) {
-        uv_pipe_init(loop, &listenPipe, 0);
-        listenPipe.data = this;
-        if (UvPipeBind(&listenPipe, jdwpCtrlName, sizeof(jdwpCtrlName))) {
-            WRITE_LOG(LOG_FATAL, "UvPipeBind failed");
-            return ret;
-        }
-        if (uv_listen((uv_stream_t *)&listenPipe, DEFAULT_BACKLOG, AcceptClient)) {
-            WRITE_LOG(LOG_FATAL, "uv_listen failed");
-            break;
-        }
-        ++refCount;
-        ret = true;
-        break;
-    }
-    // listenPipe close by stop
-    return ret;
-}
-
-int HdcJdwp::UvPipeBind(uv_pipe_t* handle, const char* name, size_t size)
-{
-    char buffer[BUF_SIZE_DEFAULT] = { 0 };
-
-    if (handle->io_watcher.fd >= 0) {
-        WRITE_LOG(LOG_FATAL, "socket already bound %d", handle->io_watcher.fd);
-        return -1;
-    }
-
-    int type = SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC;
-    int sockfd = socket(AF_UNIX, type, 0);
-    if (sockfd < 0) {
-        strerror_r(errno, buffer, BUF_SIZE_DEFAULT);
-        WRITE_LOG(LOG_FATAL, "socket failed errno:%d %s", errno, buffer);
-        return -1;
-    }
-
-#if defined(SO_NOSIGPIPE)
-    int on = 1;
-    setsockopt(sockfd, SOL_SOCKET, SO_NOSIGPIPE, &on, sizeof(on));
-#endif
-
-    struct sockaddr_un saddr;
-    Base::ZeroStruct(saddr);
-    size_t capacity = sizeof(saddr.sun_path);
-    size_t min = size < capacity ? size : capacity;
-    for (size_t i = 0; i < min; i++) {
-        saddr.sun_path[i] = name[i];
-    }
-    saddr.sun_path[capacity - 1] = '\0';
-    saddr.sun_family = AF_UNIX;
-    size_t saddrLen = sizeof(saddr.sun_family) + size - 1;
-    int err = bind(sockfd, reinterpret_cast<struct sockaddr*>(&saddr), saddrLen);
-    if (err != 0) {
-        strerror_r(errno, buffer, BUF_SIZE_DEFAULT);
-        WRITE_LOG(LOG_FATAL, "bind failed errno:%d %s", errno, buffer);
-        close(sockfd);
-        return -1;
-    }
-    constexpr uint32_t uvHandleBound = 0x00002000;
-    handle->flags |= uvHandleBound;
-    handle->io_watcher.fd = sockfd;
-    return 0;
-}
-
-// Working in the main thread, but will be accessed by each session thread, so we need to set thread lock
-void *HdcJdwp::AdminContext(const uint8_t op, const uint32_t pid, HCtxJdwp ctxJdwp)
-{
-    HCtxJdwp hRet = nullptr;
-    switch (op) {
-        case OP_ADD: {
-            uv_rwlock_wrlock(&lockMapContext);
-            const int maxMapSize = 1024;
-            if (mapCtxJdwp.size() < maxMapSize) {
-                mapCtxJdwp[pid] = ctxJdwp;
-            }
-            uv_rwlock_wrunlock(&lockMapContext);
-            break;
-        }
-        case OP_REMOVE:
-            uv_rwlock_wrlock(&lockMapContext);
-            mapCtxJdwp.erase(pid);
-            RemoveFdFromPollList(pid);
-            uv_rwlock_wrunlock(&lockMapContext);
-            break;
-        case OP_QUERY: {
-            uv_rwlock_rdlock(&lockMapContext);
-            if (mapCtxJdwp.count(pid)) {
-                hRet = mapCtxJdwp[pid];
-            }
-            uv_rwlock_rdunlock(&lockMapContext);
-            break;
-        }
-        case OP_CLEAR: {
-            uv_rwlock_wrlock(&lockMapContext);
-            mapCtxJdwp.clear();
-            pollNodeMap.clear();
-            uv_rwlock_wrunlock(&lockMapContext);
-            break;
-        }
-        default:
-            break;
-    }
-    if (op == OP_ADD || op == OP_REMOVE || op == OP_CLEAR) {
-        uv_rwlock_wrlock(&lockJdwpTrack);
-        ProcessListUpdated();
-        uv_rwlock_wrunlock(&lockJdwpTrack);
-    }
-    return hRet;
-}
-
-// work on main thread
-void HdcJdwp::SendCallbackJdwpNewFD(uv_write_t *req, int status)
-{
-    // It usually works successful, not notify session work
-    HCtxJdwp ctx = (HCtxJdwp)req->data;
-    if (status >= 0) {
-        WRITE_LOG(LOG_DEBUG, "SendCallbackJdwpNewFD successful %d, active jdwp forward", ctx->pid);
-    } else {
-        WRITE_LOG(LOG_WARN, "SendCallbackJdwpNewFD failed %d", ctx->pid);
-    }
-    delete req;
-}
-
-// Each session calls the interface through the main thread message queue, which cannot be called directly across
-// threads
-// work on main thread
-bool HdcJdwp::SendJdwpNewFD(uint32_t targetPID, int fd)
-{
-    bool ret = false;
-    while (true) {
-        HCtxJdwp ctx = (HCtxJdwp)AdminContext(OP_QUERY, targetPID, nullptr);
-        if (!ctx) {
-            break;
-        }
-        ctx->dummy = static_cast<uint8_t>('!');
-        if (uv_tcp_init(loop, &ctx->jvmTCP)) {
-            break;
-        }
-        if (uv_tcp_open(&ctx->jvmTCP, fd)) {
-            break;
-        }
-        // transfer fd to jvm
-        // clang-format off
-        if (Base::SendToStreamEx((uv_stream_t *)&ctx->pipe, (uint8_t *)&ctx->dummy, 1, (uv_stream_t *)&ctx->jvmTCP,
-            (void *)SendCallbackJdwpNewFD, (const void *)ctx) < 0) {
-            break;
-        }
-        // clang-format on
-        ++refCount;
-        ret = true;
-        WRITE_LOG(LOG_DEBUG, "SendJdwpNewFD successful targetPID:%d fd%d", targetPID, fd);
-        break;
-    }
-    return ret;
-}
-
-bool HdcJdwp::SendArkNewFD(const std::string str, int fd)
-{
-    bool ret = false;
-    while (true) {
-        // str(ark:pid@tid@Debugger)
-        size_t pos = str.find_first_of(':');
-        std::string right = str.substr(pos + 1);
-        pos = right.find_first_of("@");
-        std::string pidstr = right.substr(0, pos);
-        uint32_t pid = static_cast<uint32_t>(std::atoi(pidstr.c_str()));
-        HCtxJdwp ctx = (HCtxJdwp)AdminContext(OP_QUERY, pid, nullptr);
-        if (!ctx) {
-            WRITE_LOG(LOG_FATAL, "SendArkNewFD query pid:%u failed", pid);
-            break;
-        }
-        uint32_t size = sizeof(int32_t) + str.size();
-        // fd | str(ark:pid@tid@Debugger)
-        uint8_t buf[size];
-        if (memcpy_s(buf, sizeof(int32_t), &fd, sizeof(int32_t)) != EOK) {
-            WRITE_LOG(LOG_WARN, "From fd Create buf failed, fd:%d", fd);
-            return false;
-        }
-        if (memcpy_s(buf + sizeof(int32_t), str.size(), str.c_str(), str.size()) != EOK) {
-            WRITE_LOG(LOG_WARN, "SendArkNewFD failed fd:%d str:%s", fd, str.c_str());
-            return false;
-        }
-        uv_stream_t *stream = (uv_stream_t *)&ctx->pipe;
-        SendFdToApp(stream->io_watcher.fd, buf, size, fd);
-        ret = true;
-        WRITE_LOG(LOG_DEBUG, "SendArkNewFD successful str:%s fd%d", str.c_str(), fd);
-        Base::CloseFd(fd);
-        break;
-    }
-    return ret;
-}
-
-bool HdcJdwp::SendFdToApp(int sockfd, uint8_t *buf, int size, int fd)
-{
-    struct iovec iov;
-    iov.iov_base = buf;
-    iov.iov_len = static_cast<unsigned int>(size);
-    struct msghdr msg;
-    msg.msg_name = nullptr;
-    msg.msg_namelen = 0;
-    msg.msg_iov = &iov;
-    msg.msg_iovlen = 1;
-
-    int len = CMSG_SPACE(static_cast<unsigned int>(sizeof(fd)));
-    char ctlBuf[len];
-    msg.msg_control = ctlBuf;
-    msg.msg_controllen = sizeof(ctlBuf);
-
-    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
-    if (cmsg == nullptr) {
-        WRITE_LOG(LOG_FATAL, "SendFdToApp cmsg is nullptr");
-        return false;
-    }
-    cmsg->cmsg_level = SOL_SOCKET;
-    cmsg->cmsg_type = SCM_RIGHTS;
-    cmsg->cmsg_len = CMSG_LEN(sizeof(fd));
-    if (memcpy_s(CMSG_DATA(cmsg), sizeof(fd), &fd, sizeof(fd)) != 0) {
-        WRITE_LOG(LOG_FATAL, "SendFdToApp memcpy error:%d", errno);
-        return false;
-    }
-    if (sendmsg(sockfd, &msg, 0) < 0) {
-        WRITE_LOG(LOG_FATAL, "SendFdToApp sendmsg errno:%d", errno);
-        return false;
-    }
-    return true;
-}
-
-// cross thread call begin
-bool HdcJdwp::CheckPIDExist(uint32_t targetPID)
-{
-    HCtxJdwp ctx = (HCtxJdwp)AdminContext(OP_QUERY, targetPID, nullptr);
-    return ctx != nullptr;
-}
-
-string HdcJdwp::GetProcessList()
-{
-    string ret;
-    uv_rwlock_rdlock(&lockMapContext);
-    for (auto &&v : mapCtxJdwp) {
-        ret += std::to_string(v.first) + "\n";
-    }
-    uv_rwlock_rdunlock(&lockMapContext);
-    return ret;
-}
-// cross thread call finish
-
-size_t HdcJdwp::JdwpProcessListMsg(char *buffer, size_t bufferlen, uint8_t dr)
-{
-    // Message is length-prefixed with 4 hex digits in ASCII.
-    static constexpr size_t headerLen = 5;
-    char head[headerLen + 2];
-#ifdef JS_JDWP_CONNECT
-    string result = GetProcessListExtendPkgName(dr);
-#else
-    string result = GetProcessList();
-#endif // JS_JDWP_CONNECT
-
-    size_t len = result.length();
-    if (bufferlen < (len + headerLen)) {
-        WRITE_LOG(LOG_WARN, "truncating JDWP process list (max len = %zu) ", bufferlen);
-        len = bufferlen;
-    }
-    if (snprintf_s(head, sizeof head, sizeof head - 1, "%04zx\n", len) < 0) {
-        WRITE_LOG(LOG_WARN, " JdwpProcessListMsg head fail.");
-        return 0;
-    }
-    if (memcpy_s(buffer, bufferlen, head, headerLen) != EOK) {
-        WRITE_LOG(LOG_WARN, " JdwpProcessListMsg get head fail.");
-        return 0;
-    }
-    if (memcpy_s(buffer + headerLen, (bufferlen - headerLen), result.c_str(), len) != EOK) {
-        WRITE_LOG(LOG_WARN, " JdwpProcessListMsg get data  fail.");
-        return 0;
-    }
-    return len + headerLen;
-}
-
-void HdcJdwp::SendProcessList(HTaskInfo t, string data)
-{
-    if (t == nullptr || data.size() == 0) {
-        WRITE_LOG(LOG_WARN, " SendProcessList, Nothing needs to be sent.");
-        return;
-    }
-    void *clsSession = t->ownerSessionClass;
-    HdcSessionBase *sessionBase = static_cast<HdcSessionBase *>(clsSession);
-    sessionBase->LogMsg(t->sessionId, t->channelId, MSG_OK, data.c_str());
-}
-
-void HdcJdwp::ProcessListUpdated(HTaskInfo task)
-{
-    if (jdwpTrackers.size() <= 0) {
-        return;
-    }
-#ifdef JS_JDWP_CONNECT
-    static constexpr uint32_t jpidTrackListSize = 1024 * 4;
-#else
-    static constexpr uint32_t jpidTrackListSize = 1024;
-#endif // JS_JDWP_CONNECT
-    std::string data;
-    if (task != nullptr) {
-        data.resize(jpidTrackListSize);
-        size_t len = JdwpProcessListMsg(&data[0], data.size(), task->debugRelease);
-        if (len > 0) {
-            data.resize(len);
-            SendProcessList(task, data);
-        }
-        return;
-    }
-    for (auto iter = jdwpTrackers.begin(); iter != jdwpTrackers.end();) {
-        if (*iter == nullptr) {
-            continue;
-        }
-        // The channel for the track-jpid has been stopped.
-        if ((*iter)->taskStop || (*iter)->taskFree || !(*iter)->taskClass) {
-            iter = jdwpTrackers.erase(remove(jdwpTrackers.begin(), jdwpTrackers.end(), *iter), jdwpTrackers.end());
-            if (jdwpTrackers.size() == 0) {
-                return;
-            }
-        } else {
-            data.resize(jpidTrackListSize);
-            size_t len = JdwpProcessListMsg(&data[0], data.size(), (*iter)->debugRelease);
-            if (len > 0) {
-                data.resize(len);
-                SendProcessList(*iter, data);
-            }
-            iter++;
-        }
-    }
-}
-
-bool HdcJdwp::CreateJdwpTracker(HTaskInfo taskInfo)
-{
-    if (taskInfo == nullptr) {
-        return false;
-    }
-    uv_rwlock_wrlock(&lockJdwpTrack);
-    auto it = std::find(jdwpTrackers.begin(), jdwpTrackers.end(), taskInfo);
-    if (it == jdwpTrackers.end()) {
-        jdwpTrackers.push_back(taskInfo);
-    }
-    ProcessListUpdated(taskInfo);
-    uv_rwlock_wrunlock(&lockJdwpTrack);
-    return true;
-}
-
-void HdcJdwp::RemoveJdwpTracker(HTaskInfo taskInfo)
-{
-    if (taskInfo == nullptr) {
-        return;
-    }
-    uv_rwlock_wrlock(&lockJdwpTrack);
-    auto it = std::find(jdwpTrackers.begin(), jdwpTrackers.end(), taskInfo);
-    if (it != jdwpTrackers.end()) {
-        WRITE_LOG(LOG_DEBUG, "RemoveJdwpTracker channelId:%d, taskType:%d.", taskInfo->channelId, taskInfo->taskType);
-        jdwpTrackers.erase(remove(jdwpTrackers.begin(), jdwpTrackers.end(), *it), jdwpTrackers.end());
-    }
-    uv_rwlock_wrunlock(&lockJdwpTrack);
-}
-
-void HdcJdwp::DrainAwakenPollThread() const
-{
-    uint64_t value = 0;
-    ssize_t retVal = read(awakenPollFd, &value, sizeof(value));
-    if (retVal < 0) {
-        WRITE_LOG(LOG_FATAL, "DrainAwakenPollThread: Failed to read data from awaken pipe %d", retVal);
-    }
-}
-
-void HdcJdwp::WakePollThread()
-{
-    if (awakenPollFd < 0) {
-        WRITE_LOG(LOG_DEBUG, "awakenPollFd: MUST initialized before notifying");
-        return;
-    }
-    static const uint64_t increment = 1;
-    ssize_t retVal = write(awakenPollFd, &increment, sizeof(increment));
-    if (retVal < 0) {
-        WRITE_LOG(LOG_FATAL, "WakePollThread: Failed to write data into awaken pipe %d", retVal);
-    }
-}
-
-void *HdcJdwp::FdEventPollThread(void *args)
-{
-    auto thisClass = static_cast<HdcJdwp *>(args);
-    std::vector<struct pollfd> pollfds;
-    size_t size = 0;
-    while (!thisClass->stop) {
-        thisClass->freeContextMutex.lock();
-        if (size != thisClass->pollNodeMap.size() || thisClass->pollNodeMap.size() == 0) {
-            pollfds.clear();
-            struct pollfd pollFd;
-            for (const auto &pair : thisClass->pollNodeMap) {
-                pollFd.fd = pair.second.pollfd.fd;
-                pollFd.events = pair.second.pollfd.events;
-                pollFd.revents = pair.second.pollfd.revents;
-                pollfds.push_back(pollFd);
-            }
-            pollFd.fd = thisClass->awakenPollFd;
-            pollFd.events = POLLIN;
-            pollFd.revents = 0;
-            pollfds.push_back(pollFd);
-            size = pollfds.size();
-        }
-        thisClass->freeContextMutex.unlock();
-        poll(&pollfds[0], size, -1);
-        for (const auto &pollfdsing : pollfds) {
-            if (pollfdsing.revents & (POLLNVAL | POLLRDHUP | POLLHUP | POLLERR)) {  // POLLNVAL:fd not open
-                thisClass->freeContextMutex.lock();
-                auto it = thisClass->pollNodeMap.find(pollfdsing.fd);
-                if (it != thisClass->pollNodeMap.end()) {
-                    uint32_t targetPID = it->second.ppid;
-                    HCtxJdwp ctx = static_cast<HCtxJdwp>(thisClass->AdminContext(OP_QUERY, targetPID, nullptr));
-                    if (ctx != nullptr) {
-                        thisClass->AdminContext(OP_REMOVE, targetPID, nullptr);
-                    }
-                }
-                thisClass->freeContextMutex.unlock();
-            } else if (pollfdsing.revents & POLLIN) {
-                if (pollfdsing.fd == thisClass->awakenPollFd) {
-                    thisClass->DrainAwakenPollThread();
-                }
-            }
-        }
-    }
-    return nullptr;
-}
-
-int HdcJdwp::CreateFdEventPoll()
-{
-    pthread_t tid;
-    Base::CloseFd(awakenPollFd);
-    awakenPollFd = eventfd(0, EFD_CLOEXEC | EFD_NONBLOCK);
-    if (awakenPollFd < 0) {
-        WRITE_LOG(LOG_FATAL, "CreateFdEventPoll : Failed to create awakenPollFd");
-        return ERR_GENERIC;
-    }
-    int tret = pthread_create(&tid, nullptr, FdEventPollThread, this);
-    if (tret != 0) {
-        WRITE_LOG(LOG_INFO, "FdEventPollThread create fail.");
-        return tret;
-    }
-    return RET_SUCCESS;
-}
-
-// jdb -connect com.sun.jdi.SocketAttach:hostname=localhost,port=8000
-int HdcJdwp::Initial()
-{
-    freeContextMutex.lock();
-    pollNodeMap.clear();
-    freeContextMutex.unlock();
-    if (!JdwpListen()) {
-        WRITE_LOG(LOG_FATAL, "JdwpListen failed");
-        return ERR_MODULE_JDWP_FAILED;
-    }
-    SystemDepend::SetDevItem("persist.hdc.jdwp", "0");
-    SystemDepend::SetDevItem("persist.hdc.jdwp", "1");
-    if (CreateFdEventPoll() < 0) {
-        return ERR_MODULE_JDWP_FAILED;
-    }
-    return RET_SUCCESS;
-}
-}
diff --git a/hdc/src/daemon/jdwp.h b/hdc/src/daemon/jdwp.h
deleted file mode 100644
index 9144242..0000000
--- a/hdc/src/daemon/jdwp.h
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_JDWP_H
-#define HDC_JDWP_H
-#include "daemon_common.h"
-#include <poll.h>
-#include <unordered_map>
-namespace Hdc {
-class HdcJdwp {
-public:
-    HdcJdwp(uv_loop_t *loopIn);
-    virtual ~HdcJdwp();
-    int Initial();
-    void Stop();
-    bool CreateJdwpTracker(HTaskInfo taskInfo);
-    void RemoveJdwpTracker(HTaskInfo taskInfo);
-    bool ReadyForRelease();
-    string GetProcessList();
-    bool SendJdwpNewFD(uint32_t targetPID, int fd);
-    bool SendArkNewFD(const std::string str, int fd);
-    bool CheckPIDExist(uint32_t targetPID);
-    bool SendFdToApp(int sockfd, uint8_t *buf, int size, int fd);
-
-#ifdef FUZZ_TEST
-public:
-#else
-private:
-#endif
-#ifdef JS_JDWP_CONNECT
-    static constexpr uint8_t JS_PKG_MIN_SIZE = 7;  // JsMsgHeader + "pkgName:"uint8_t[7~128]
-    static constexpr uint8_t JS_PKG_MAX_SIZE = 128;
-    struct JsMsgHeader {
-        uint32_t msgLen;
-        uint32_t pid;
-        uint8_t isDebug; // 1:debugApp 0:releaseApp
-    };
-    string GetProcessListExtendPkgName(uint8_t dr);
-#endif // JS_JDWP_CONNECT
-    struct _PollFd {
-        int fd;
-        short events;
-        short revents;
-    };
-    struct PollNode {
-        _PollFd pollfd;
-        uint32_t ppid;
-        PollNode(int fd, uint32_t pid)
-        {
-            Base::ZeroStruct(pollfd);
-            pollfd.fd = fd;
-            pollfd.events = POLLNVAL | POLLRDHUP | POLLHUP | POLLERR;
-            pollfd.revents = 0;
-            ppid = pid;
-        }
-    };
-    struct ContextJdwp {
-        uint32_t pid;
-        uv_pipe_t pipe;
-        HdcJdwp *thisClass;
-        bool finish;
-#ifdef JS_JDWP_CONNECT
-        char buf[JS_PKG_MAX_SIZE + sizeof(JsMsgHeader)];
-        string pkgName;
-#else
-        char buf[sizeof(uint32_t)];
-#endif  // JS_JDWP_CONNECT
-        uint8_t dummy;
-        uv_tcp_t jvmTCP;
-        uint8_t isDebug;
-    };
-    using HCtxJdwp = struct ContextJdwp *;
-
-    bool JdwpListen();
-    static int UvPipeBind(uv_pipe_t* handle, const char* name, size_t size);
-    static void AcceptClient(uv_stream_t *server, int status);
-    static void ReadStream(uv_stream_t *pipe, ssize_t nread, const uv_buf_t *buf);
-    static void SendCallbackJdwpNewFD(uv_write_t *req, int status);
-    static void *FdEventPollThread(void *args);
-    void RemoveFdFromPollList(uint32_t pid);
-    size_t JdwpProcessListMsg(char *buffer, size_t bufferlen, uint8_t dr);
-    void *MallocContext();
-    void FreeContext(HCtxJdwp ctx);
-    void *AdminContext(const uint8_t op, const uint32_t pid, HCtxJdwp ctxJdwp);
-    int CreateFdEventPoll();
-    void ProcessListUpdated(HTaskInfo task = nullptr);
-    void SendProcessList(HTaskInfo t, string data);
-    void DrainAwakenPollThread() const;
-    void WakePollThread();
-    uv_loop_t *loop;
-    uv_pipe_t listenPipe = {};
-    uint32_t refCount;
-    int32_t awakenPollFd;
-    map<uint32_t, HCtxJdwp> mapCtxJdwp;
-    uv_rwlock_t lockMapContext;
-    uv_rwlock_t lockJdwpTrack;
-    std::unordered_map<int, PollNode> pollNodeMap;  // fd, PollNode
-    std::vector<HTaskInfo> jdwpTrackers;
-    bool stop;
-    std::mutex freeContextMutex;
-};
-} // namespace Hdc
-#endif
diff --git a/hdc/src/daemon/main.cpp b/hdc/src/daemon/main.cpp
deleted file mode 100644
index e250390..0000000
--- a/hdc/src/daemon/main.cpp
+++ /dev/null
@@ -1,387 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <grp.h>
-#include <pwd.h>
-#include <unistd.h>
-#include <sys/types.h>
-#include "daemon_common.h"
-#if defined(SURPPORT_SELINUX)
-#include "selinux/selinux.h"
-#endif
-using namespace Hdc;
-
-static bool g_enableUsb = false;
-#ifdef HDC_SUPPORT_UART
-static bool g_enableUart = false;
-#endif
-static bool g_enableTcp = false;
-#ifdef HDC_EMULATOR
-static bool g_enableBridge = false;
-#endif
-static bool g_backgroundRun = false;
-namespace Hdc {
-bool RestartDaemon(bool forkchild)
-{
-    char path[256] = "";
-    size_t nPathSize = 256;
-    uv_exepath(path, &nPathSize);
-    execl(path, "hdcd", forkchild ? "-forkchild" : nullptr, nullptr);
-    return true;
-}
-
-void GetTCPChannelMode(void)
-{
-    string modeValue;
-    if (SystemDepend::GetDevItem("persist.hdc.mode.tcp", modeValue)) {
-        g_enableTcp = (modeValue == "enable");
-        WRITE_LOG(LOG_INFO, "Property %s TCP", modeValue.c_str());
-    }
-    modeValue.clear();
-    if (SystemDepend::GetDevItem("persist.hdc.mode.usb", modeValue)) {
-        g_enableUsb = (modeValue == "enable");
-        WRITE_LOG(LOG_INFO, "Property %s USB", modeValue.c_str());
-    }
-    return;
-}
-
-bool ForkChildCheck(int argc, const char *argv[])
-{
-    // hdcd        #service start foreground
-    // hdcd -b     #service start backgroundRun
-    // hdcd -fork  #fork
-    Base::PrintMessage("Background mode, persist.hdc.mode");
-    string workMode;
-    SystemDepend::GetDevItem("persist.hdc.mode", workMode);
-    workMode = Base::Trim(workMode);
-    if (workMode == "all") {
-        WRITE_LOG(LOG_DEBUG, "Property enable USB and TCP");
-        g_enableUsb = true;
-        g_enableTcp = true;
-#ifdef HDC_SUPPORT_UART
-        g_enableUart = true;
-#endif
-#ifdef HDC_SUPPORT_UART
-    } else if (workMode == CMDSTR_TMODE_UART) {
-        WRITE_LOG(LOG_DEBUG, "Property enable UART");
-        g_enableUart = true;
-#endif
-#ifdef HDC_EMULATOR
-    } else if (workMode == CMDSTR_TMODE_BRIDGE || workMode.empty()) {
-        WRITE_LOG(LOG_DEBUG, "Property enable Bridge");
-        g_enableBridge = true;
-#endif
-    } else if (workMode == CMDSTR_TMODE_USB || workMode == CMDSTR_TMODE_TCP) {
-        // for tcp and usb, we use persist.hdc.mode.tcp and persist.hdc.mode.usb to control
-        GetTCPChannelMode();
-    } else {
-        WRITE_LOG(LOG_DEBUG, "Default USB mode");
-        g_enableUsb = true;
-#ifdef HDC_SUPPORT_UART
-        WRITE_LOG(LOG_DEBUG, "Default UART mode");
-        g_enableUart = true;
-#endif
-    }
-    if (argc == CMD_ARG1_COUNT) {
-        if (!strcmp(argv[1], "-forkchild")) {
-            g_backgroundRun = false;  // forkchild,Forced foreground
-        } else if (!strcmp(argv[1], "-b")) {
-            g_backgroundRun = true;
-        }
-    }
-    return true;
-}
-
-static size_t CheckUvThreadConfig()
-{
-    return SystemDepend::GetDevUint("persist.hdc.uv.threads", SIZE_THREAD_POOL);
-}
-
-int BackgroundRun()
-{
-    pid_t pc = fork();  // create process as daemon process
-    if (pc < 0) {
-        return -1;
-    } else if (!pc) {
-        int i;
-        const int MAX_NUM = 64;
-        for (i = 0; i < MAX_NUM; ++i) {
-            int fd = i;
-            Base::CloseFd(fd);
-        }
-        RestartDaemon(true);
-    } else {  // >0 orig process
-    }
-    return 0;
-}
-
-string DaemonUsage()
-{
-    string ret = "";
-    ret = "\n                         Harmony device connector daemon(HDCD) Usage: hdcd [options]...\n\n"
-          "\n"
-          "general options:\n"
-          " -h                            - Print help\n"
-          " -l 0-5                        - Print runtime log\n"
-          "\n"
-          "daemon mode options:\n"
-          " -b                            - Daemon run in background/fork mode\n"
-#ifdef HDC_SUPPORT_UART
-          " -i                            - Enable UART mode\n"
-#endif
-          " -u                            - Enable USB mode\n"
-          " -t                            - Enable TCP mode\n";
-    return ret;
-}
-
-bool GetDaemonCommandlineOptions(int argc, const char *argv[])
-{
-    int ch;
-    // hdcd -l4 ...
-    WRITE_LOG(LOG_DEBUG, "Foreground cli-mode");
-    // Both settings are running with parameters
-    while ((ch = getopt(argc, const_cast<char *const *>(argv), "utl:")) != -1) {
-        switch (ch) {
-            case 'l': {
-                int logLevel = atoi(optarg);
-                if (logLevel < 0 || logLevel > LOG_LAST) {
-                    WRITE_LOG(LOG_DEBUG, "Loglevel error!\n");
-                    return -1;
-                }
-                Base::SetLogLevel(logLevel);
-                break;
-            }
-            case 'u': {
-                Base::PrintMessage("Option USB enabled");
-                g_enableUsb = true;
-                break;
-            }
-            case 't': {
-                Base::PrintMessage("Option TCP enabled");
-                g_enableTcp = true;
-                break;
-            }
-#ifdef HDC_SUPPORT_UART
-            case 'i': { // enable uart
-                Base::PrintMessage("Parament Enable UART");
-                g_enableUart = true;
-                break;
-            }
-#endif
-            default:
-                Base::PrintMessage("Option:%c non-supported!", ch);
-                exit(0);
-                break;
-        }
-    }
-    return true;
-}
-
-bool DropRootPrivileges()
-{
-    int ret;
-    const char *userName = "shell";
-    vector<const char *> groupsNames = { "shell", "log", "readproc", "file_manager", "user_data_rw" };
-    struct passwd *user;
-    gid_t *gids = nullptr;
-
-    user = getpwnam(userName);
-    if (user == nullptr) {
-        WRITE_LOG(LOG_FATAL, "getpwuid %s fail, %s", userName, strerror(errno));
-        return false;
-    }
-
-    gids = static_cast<gid_t *>(calloc(groupsNames.size(), sizeof(gid_t)));
-    if (gids == nullptr) {
-        WRITE_LOG(LOG_FATAL, "calloc fail");
-        return false;
-    }
-
-    for (size_t i = 0; i < groupsNames.size(); i++) {
-        struct group *group = getgrnam(groupsNames[i]);
-        if (group == nullptr) {
-            WRITE_LOG(LOG_FATAL, "calloc fail");
-            continue;
-        }
-        gids[i] = group->gr_gid;
-    }
-
-    ret = setuid(user->pw_uid);
-    if (ret) {
-        WRITE_LOG(LOG_FATAL, "setuid %s fail, %s", userName, strerror(errno));
-        free(gids);
-        return false;
-    }
-
-    ret = setgid(user->pw_gid);
-    if (ret) {
-        WRITE_LOG(LOG_FATAL, "setgid %s fail, %s", userName, strerror(errno));
-        free(gids);
-        return false;
-    }
-
-    ret = setgroups(groupsNames.size(), gids);
-    if (ret) {
-        WRITE_LOG(LOG_FATAL, "setgroups %s fail, %s", userName, strerror(errno));
-        free(gids);
-        return false;
-    }
-
-    free(gids);
-#if defined(SURPPORT_SELINUX)
-    if (setcon("u:r:hdcd:s0") != 0) {
-        WRITE_LOG(LOG_FATAL, "setcon fail, errno %s", userName, strerror(errno));
-    }
-#endif
-    return true;
-}
-
-bool NeedDropRootPrivileges()
-{
-    string rootMode;
-    string debugMode;
-    SystemDepend::GetDevItem("const.debuggable", debugMode);
-    SystemDepend::GetDevItem("persist.hdc.root", rootMode);
-    if (debugMode == "1") {
-        if (rootMode == "1") {
-            int rc = setuid(0);
-            if (rc != 0) {
-                char buffer[BUF_SIZE_DEFAULT] = { 0 };
-                strerror_r(errno, buffer, BUF_SIZE_DEFAULT);
-                WRITE_LOG(LOG_FATAL, "setuid(0) fail %s", buffer);
-            }
-            WRITE_LOG(LOG_DEBUG, "Root run rc:%d", rc);
-        } else if (rootMode == "0") {
-            if (getuid() == 0) {
-                return DropRootPrivileges();
-            }
-        }
-        // default keep root
-    } else {
-        return DropRootPrivileges();
-    }
-    return true;
-}
-} // namespace Hdc
-
-#ifndef UNIT_TEST
-// daemon running with default behavior. options also can be given to custom its behavior including b/t/u/l etc.
-int main(int argc, const char *argv[])
-{
-#ifdef CONFIG_USE_JEMALLOC_DFX_INIF
-    mallopt(M_DELAYED_FREE, M_DELAYED_FREE_DISABLE);
-    mallopt(M_SET_THREAD_CACHE, M_THREAD_CACHE_DISABLE);
-#endif
-#ifndef UPDATER_MODE
-    string developerMode;
-    SystemDepend::GetDevItem("const.security.developermode.state", developerMode);
-    if (developerMode != "true") {
-        WRITE_LOG(LOG_FATAL, "non developer mode, hdcd does not start");
-        return -1;
-    }
-#endif
-    // check property
-    if (argc == CMD_ARG1_COUNT && !strcmp(argv[1], "-h")) {
-        string usage = DaemonUsage();
-        fprintf(stderr, "%s", usage.c_str());
-        return 0;
-    }
-    if (argc == CMD_ARG1_COUNT && !strcmp(argv[1], "-v")) {
-        string ver = Hdc::Base::GetVersion();
-        fprintf(stderr, "%s\n", ver.c_str());
-        return 0;
-    }
-    if (argc == 1 || (argc == CMD_ARG1_COUNT && (!strcmp(argv[1], "-forkchild") || !strcmp(argv[1], "-b")))) {
-        ForkChildCheck(argc, argv);
-    } else {
-        GetDaemonCommandlineOptions(argc, argv);
-    }
-    if (!g_enableTcp && !g_enableUsb) {
-#ifdef HDC_EMULATOR
-#ifdef HDC_SUPPORT_UART
-        if (!g_enableBridge && !g_enableUart) {
-            Base::PrintMessage("TCP, USB, Bridge and Uart are disable, cannot run continue\n");
-            return -1;
-        }
-#else
-        if (!g_enableBridge) {
-            Base::PrintMessage("Both TCP, Bridge and USB are disable, cannot run continue\n");
-            return -1;
-        }
-#endif
-#else
-#ifdef HDC_SUPPORT_UART
-        if (!g_enableUart) {
-            Base::PrintMessage("TCP, USB and Uart are disable, cannot run continue\n");
-            return -1;
-        }
-#else
-        Base::PrintMessage("Both TCP and USB are disable, cannot run continue\n");
-        return -1;
-#endif
-#endif
-    }
-    if (g_backgroundRun) {
-        return BackgroundRun();
-    }
-    string debugMode;
-    SystemDepend::GetDevItem("const.debuggable", debugMode);
-    if (debugMode == "1") {
-        if (!NeedDropRootPrivileges()) {
-            Base::PrintMessage("DropRootPrivileges fail, EXITING...\n");
-            return -1;
-        }
-        WRITE_LOG(LOG_INFO, "HdcDaemon run as root mode.");
-    } else {
-        WRITE_LOG(LOG_INFO, "HdcDaemon run as user mode.");
-    }
-
-    Base::InitProcess();
-    WRITE_LOG(LOG_DEBUG, "HdcDaemon main run");
-    HdcDaemon daemon(false, CheckUvThreadConfig());
-
-#ifdef HDC_EMULATOR
-#ifdef HDC_SUPPORT_UART
-    daemon.InitMod(g_enableTcp, g_enableUsb, g_enableBridge, g_enableUart);
-#else
-    daemon.InitMod(g_enableTcp, g_enableUsb, g_enableBridge);
-#endif
-#else
-#ifdef HDC_SUPPORT_UART
-    daemon.InitMod(g_enableTcp, g_enableUsb, g_enableUart);
-#else
-    daemon.InitMod(g_enableTcp, g_enableUsb);
-#endif
-#endif
-    daemon.ClearKnownHosts();
-    daemon.WorkerPendding();
-    bool wantRestart = daemon.WantRestart();
-    WRITE_LOG(LOG_DEBUG, "Daemon finish wantRestart %d", wantRestart);
-    // There is no daemon, we can only restart myself.
-    if (wantRestart) {
-        // just root can self restart, low privilege will be exit and start by service(root)
-        WRITE_LOG(LOG_INFO, "Daemon restart");
-        RestartDaemon(false);
-    }
-#ifdef HDC_SUPPORT_UART
-    // when no usb insert , device will hung here , we don't know why.
-    // Test the command "smode -r" in uart mode, then execute shell
-    // hdcd will not really exit until usb plug in
-    // so we use abort here
-    _exit(0);
-#endif
-    return 0;
-}
-#endif
diff --git a/hdc/src/daemon/shell.cpp b/hdc/src/daemon/shell.cpp
deleted file mode 100644
index 5b4ed4c..0000000
--- a/hdc/src/daemon/shell.cpp
+++ /dev/null
@@ -1,323 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "shell.h"
-#include <sys/wait.h>
-#include <cerrno>
-#include <csignal>
-#include <cstdlib>
-#include <string>
-#include "fcntl.h"
-#include "functional"
-#include "new"
-#include <pthread.h>
-#include "unistd.h"
-#include "base.h"
-#include "file_descriptor.h"
-#include "system_depend.h"
-#if defined(SURPPORT_SELINUX)
-#include "selinux/selinux.h"
-#endif
-
-namespace Hdc {
-std::mutex HdcShell::mutexPty;
-
-HdcShell::HdcShell(HTaskInfo hTaskInfo)
-    : HdcTaskBase(hTaskInfo)
-{
-    childShell = nullptr;
-    fdPTY = 0;
-}
-
-HdcShell::~HdcShell()
-{
-    WRITE_LOG(LOG_DEBUG, "~HdcShell channelId:%u", taskInfo->channelId);
-};
-
-bool HdcShell::ReadyForRelease()
-{
-    if (!HdcTaskBase::ReadyForRelease()) {
-        WRITE_LOG(LOG_WARN, "not ready for release channelId:%u", taskInfo->channelId);
-        return false;
-    }
-    if (!childReady) {
-        WRITE_LOG(LOG_WARN, "childReady false channelId:%u", taskInfo->channelId);
-        return true;
-    }
-    if (!childShell->ReadyForRelease()) {
-        WRITE_LOG(LOG_WARN, "childShell not ready for release channelId:%u", taskInfo->channelId);
-        return false;
-    }
-    delete childShell;
-    childShell = nullptr;
-    WRITE_LOG(LOG_DEBUG, "ReadyForRelease close fdPTY:%d", fdPTY);
-    Base::CloseFd(fdPTY);
-    return true;
-}
-
-void HdcShell::StopTask()
-{
-    singalStop = true;
-    WRITE_LOG(LOG_DEBUG, "StopTask pidShell:%d childReady:%d", pidShell, childReady);
-    if (!childReady) {
-        return;
-    }
-    if (childShell) {
-        childShell->StopWorkOnThread(false, nullptr);
-    }
-
-    if (pidShell > 1) {
-        kill(pidShell, SIGKILL);
-        int status;
-        waitpid(pidShell, &status, 0);
-        WRITE_LOG(LOG_DEBUG, "StopTask, kill pidshell:%d", pidShell);
-    }
-};
-
-bool HdcShell::SpecialSignal(uint8_t ch)
-{
-    const uint8_t TXT_SIGNAL_ETX = 0x3;
-    bool ret = true;
-    switch (ch) {
-        case TXT_SIGNAL_ETX: {  // Ctrl+C
-            if (fdPTY <= 0) {
-                break;
-            }
-            pid_t tpgid = tcgetpgrp(fdPTY);
-            if (tpgid > 1) {
-                kill(tpgid, SIGINT);
-            }
-            break;
-        }
-        default:
-            ret = false;
-            break;
-    }
-    return ret;
-}
-
-bool HdcShell::CommandDispatch(const uint16_t command, uint8_t *payload, const int payloadSize)
-{
-    switch (command) {
-        case CMD_SHELL_INIT: {  // initial
-            if (StartShell()) {
-                LogMsg(MSG_FAIL, "Shell initialize failed");
-            }
-            break;
-        }
-        case CMD_SHELL_DATA:
-            if (!childReady) {
-                WRITE_LOG(LOG_DEBUG, "Shell not running");
-                return false;
-            }
-            if (payloadSize == 1 && SpecialSignal(payload[0])) {
-            } else {
-                int ret = childShell->Write(payload, payloadSize);
-                if (ret < 0) {
-                    return false;
-                }
-            }
-            break;
-        default:
-            break;
-    }
-    return true;
-}
-
-int HdcShell::ChildForkDo(int pts, const char *cmd, const char *arg0, const char *arg1)
-{
-    dup2(pts, STDIN_FILENO);
-    dup2(pts, STDOUT_FILENO);
-    dup2(pts, STDERR_FILENO);
-    close(pts);
-    string text = "/proc/self/oom_score_adj";
-    int fd = 0;
-    if ((fd = open(text.c_str(), O_WRONLY)) >= 0) {
-        write(fd, "0", 1);
-        close(fd);
-    }
-    char *env = nullptr;
-    if (((env = getenv("HOME")) && chdir(env) < 0) || chdir("/")) {
-    }
-    execl(cmd, cmd, arg0, arg1, nullptr);
-    return 0;
-}
-
-static void SetSelinuxLabel()
-{
-#if defined(SURPPORT_SELINUX)
-    char *con = nullptr;
-    if (getcon(&con) != 0) {
-        return;
-    }
-    if ((strcmp(con, "u:r:hdcd:s0") != 0) && (strcmp(con, "u:r:updater:s0") != 0)) {
-        freecon(con);
-        return;
-    }
-    string debugMode = "";
-    SystemDepend::GetDevItem("const.debuggable", debugMode);
-    if (debugMode != "1") {
-        setcon("u:r:sh:s0");
-    } else {
-        string rootMode = "";
-        string flashdMode = "";
-        SystemDepend::GetDevItem("persist.hdc.root", rootMode);
-        SystemDepend::GetDevItem("updater.flashd.configfs", flashdMode);
-        if ((debugMode == "1" && rootMode == "1") || (debugMode == "1" && flashdMode == "1")) {
-            setcon("u:r:su:s0");
-        } else {
-            setcon("u:r:sh:s0");
-        }
-    }
-    freecon(con);
-#endif
-}
-
-int HdcShell::ThreadFork(const char *cmd, const char *arg0, const char *arg1)
-{
-    ShellParams params = ShellParams(cmd, arg0, arg1, ptm, devname);
-    pthread_t threadId;
-    void *shellRes;
-    int ret = pthread_create(&threadId, nullptr, reinterpret_cast<void *(*)(void *)>(ShellFork), &params);
-    if (ret != 0) {
-        constexpr int bufSize = 1024;
-        char buf[bufSize] = { 0 };
-        strerror_r(errno, buf, bufSize);
-        WRITE_LOG(LOG_DEBUG, "fork Thread create failed:%s", buf);
-        return ERR_GENERIC;
-    }
-    pthread_join(threadId, &shellRes);
-    return static_cast<int>(reinterpret_cast<size_t>(shellRes));
-}
-
-void *HdcShell::ShellFork(void *arg)
-{
-    int ret = pthread_setname_np(pthread_self(), "hdcd_shellfork");
-    if (ret != 0) {
-        WRITE_LOG(LOG_DEBUG, "set Thread name failed.");
-    }
-    ShellParams params = *reinterpret_cast<ShellParams *>(arg);
-    const char *cmd = params.cmdParam;
-    const char *arg0 = params.arg0Param;
-    const char *arg1 = params.arg1Param;
-    int ptmParam = params.ptmParam;
-    char *devParam = params.devParam;
-    pid_t pid = 0;
-    pid = fork();
-    if (pid < 0) {
-        constexpr int bufSize = 1024;
-        char buf[bufSize] = { 0 };
-        strerror_r(errno, buf, bufSize);
-        WRITE_LOG(LOG_DEBUG, "Fork shell failed:%s", buf);
-        return reinterpret_cast<void *>(ERR_GENERIC);
-    }
-    if (pid == 0) {
-        WRITE_LOG(LOG_DEBUG, "ShellFork close ptmParam:%d", ptmParam);
-        Base::DeInitProcess();
-        HdcShell::mutexPty.unlock();
-        setsid();
-        SetSelinuxLabel();
-        close(ptmParam);
-        int pts = 0;
-        if ((pts = open(devParam, O_RDWR | O_CLOEXEC)) < 0) {
-            return reinterpret_cast<void *>(-1);
-        }
-        ChildForkDo(pts, cmd, arg0, arg1);
-        // proc finish
-    } else {
-        return reinterpret_cast<void *>(pid);
-    }
-    return reinterpret_cast<void *>(0);
-}
-
-int HdcShell::CreateSubProcessPTY(const char *cmd, const char *arg0, const char *arg1, pid_t *pid)
-{
-    ptm = open(devPTMX.c_str(), O_RDWR | O_CLOEXEC);
-    if (ptm < 0) {
-        constexpr int bufSize = 1024;
-        char buf[bufSize] = { 0 };
-        strerror_r(errno, buf, bufSize);
-        WRITE_LOG(LOG_DEBUG, "Cannot open ptmx, error:%s", buf);
-        return ERR_FILE_OPEN;
-    }
-    if (grantpt(ptm) || unlockpt(ptm)) {
-        constexpr int bufSize = 1024;
-        char buf[bufSize] = { 0 };
-        strerror_r(errno, buf, bufSize);
-        WRITE_LOG(LOG_DEBUG, "Cannot open2 ptmx, error:%s", buf);
-        Base::CloseFd(ptm);
-        return ERR_API_FAIL;
-    }
-    if (ptsname_r(ptm, devname, sizeof(devname)) != 0) {
-        constexpr int bufSize = 1024;
-        char buf[bufSize] = { 0 };
-        strerror_r(errno, buf, bufSize);
-        WRITE_LOG(LOG_DEBUG, "Trouble with  ptmx, error:%s", buf);
-        Base::CloseFd(ptm);
-        return ERR_API_FAIL;
-    }
-    *pid = ThreadFork(cmd, arg0, arg1);
-    return ptm;
-}
-
-bool HdcShell::FinishShellProc(const void *context, const bool result, const string exitMsg)
-{
-    WRITE_LOG(LOG_DEBUG, "FinishShellProc finish");
-    HdcShell *thisClass = reinterpret_cast<HdcShell *>(const_cast<void *>(context));
-    thisClass->TaskFinish();
-    --thisClass->refCount;
-    return true;
-};
-
-bool HdcShell::ChildReadCallback(const void *context, uint8_t *buf, const int size)
-{
-    HdcShell *thisClass = reinterpret_cast<HdcShell *>(const_cast<void *>(context));
-    return thisClass->SendToAnother(CMD_KERNEL_ECHO_RAW, reinterpret_cast<uint8_t *>(buf), size);
-};
-
-int HdcShell::StartShell()
-{
-    int ret = 0;
-    HdcShell::mutexPty.lock();
-    do {
-        if ((fdPTY = CreateSubProcessPTY(Base::GetShellPath().c_str(), "-", 0, &pidShell)) < 0) {
-            ret = ERR_PROCESS_SUB_FAIL;
-            break;
-        }
-        childShell = new(std::nothrow) HdcFileDescriptor(loopTask, fdPTY, this, ChildReadCallback,
-                                                         FinishShellProc, true);
-        if (childShell == nullptr) {
-            WRITE_LOG(LOG_FATAL, "StartShell new childShell failed");
-            ret = ERR_GENERIC;
-            break;
-        }
-        if (!childShell->StartWorkOnThread()) {
-            WRITE_LOG(LOG_FATAL, "StartShell childShell->StartWorkOnThread false");
-            ret = ERR_API_FAIL;
-            break;
-        }
-        childReady = true;
-        ++refCount;
-    } while (false);
-    WRITE_LOG(LOG_DEBUG, "StartShell pid:%d channelId:%u ret:%d", pidShell, taskInfo->channelId, ret);
-    if (ret != RET_SUCCESS) {
-        if (pidShell > 0) {
-            kill(pidShell, SIGKILL);
-        }
-        // fdPTY close by ~clase
-    }
-    HdcShell::mutexPty.unlock();
-    return ret;
-}
-}  // namespace Hdc
diff --git a/hdc/src/daemon/shell.h b/hdc/src/daemon/shell.h
deleted file mode 100644
index cf57b6e..0000000
--- a/hdc/src/daemon/shell.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_SHELL_H
-#define HDC_SHELL_H
-#include "task.h"
-
-namespace Hdc {
-class HdcShell : public HdcTaskBase {
-public:
-    HdcShell(HTaskInfo hTaskInfo);
-    virtual ~HdcShell();
-    bool CommandDispatch(const uint16_t command, uint8_t *payload, const int payloadSize) override;
-    void StopTask() override;
-    bool ReadyForRelease() override;
-
-private:
-    static bool FinishShellProc(const void *context, const bool result, const string exitMsg);
-    static bool ChildReadCallback(const void *context, uint8_t *buf, const int size);
-    int StartShell();
-    int CreateSubProcessPTY(const char *cmd, const char *arg0, const char *arg1, pid_t *pid);
-    static int ChildForkDo(int pts, const char *cmd, const char *arg0, const char *arg1);
-    bool SpecialSignal(uint8_t ch);
-    int ThreadFork(const char *cmd, const char *arg0, const char *arg1);
-    static void *ShellFork(void *arg);
-
-    HdcFileDescriptor *childShell;
-    pid_t pidShell = 0;
-    int fdPTY;
-    int ptm = 0;
-    const string devPTMX = "/dev/ptmx";
-    static std::mutex mutexPty;
-    char devname[BUF_SIZE_SMALL] = "";
-};
-
-struct ShellParams {
-    const char *cmdParam;
-    const char *arg0Param;
-    const char *arg1Param;
-    int ptmParam;
-    char *devParam;
-
-    ShellParams(const char *cmdParam, const char *arg0Param, const char *arg1Param, int ptmParam, char *devParam)
-        :cmdParam(cmdParam), arg0Param(arg0Param), arg1Param(arg1Param), ptmParam(ptmParam), devParam(devParam) {};
-};
-}  // namespace Hdc
-#endif
\ No newline at end of file
diff --git a/hdc/src/daemon/system_depend.cpp b/hdc/src/daemon/system_depend.cpp
deleted file mode 100644
index 8041981..0000000
--- a/hdc/src/daemon/system_depend.cpp
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-/*
-############
-This file is used to support compatibility between platforms, differences between old and new projects and
-compilation platforms
-
-defined HARMONY_PROJECT
-With openharmony toolchains support. If not defined, it should be [device]buildroot or [PC]msys64(...)/ubuntu-apt(...)
-envirments
-############
-*/
-#include "system_depend.h"
-#include "base.h"
-#if defined(HARMONY_PROJECT)
-extern "C" {
-#include "init_reboot.h"
-#include "parameter.h"
-}
-#endif
-
-namespace Hdc {
-namespace SystemDepend {
-    bool SetDevItem(const char *key, const char *value)
-    {
-        bool ret = true;
-#ifdef HARMONY_PROJECT
-        ret = SetParameter(key, value) == 0;
-#else
-        char outBuf[256] = "";
-        string stringBuf = Base::StringFormat("param set %s %s", key, value);
-        Base::RunPipeComand(stringBuf.c_str(), outBuf, sizeof(outBuf), true);
-#endif  // HARMONY_PROJECT
-        return ret;
-    }
-
-    bool GetDevItem(const char *key, string &out, const char *preDefine)
-    {
-        bool ret = true;
-        char tmpStringBuf[BUF_SIZE_MEDIUM] = "";
-#ifdef HARMONY_PROJECT
-        auto res = GetParameter(key, preDefine, tmpStringBuf, BUF_SIZE_MEDIUM);
-        if (res <= 0) {
-            return false;
-        }
-#else
-        string sFailString = Base::StringFormat("Get parameter \"%s\" fail", key);
-        string stringBuf = "param get " + string(key);
-        Base::RunPipeComand(stringBuf.c_str(), tmpStringBuf, BUF_SIZE_MEDIUM - 1, true);
-        if (!strcmp(sFailString.c_str(), tmpStringBuf)) {
-            // failed
-            ret = false;
-            Base::ZeroBuf(tmpStringBuf, BUF_SIZE_MEDIUM);
-        }
-#endif
-        out = tmpStringBuf;
-        return ret;
-    }
-
-    uint32_t GetDevUint(const char *key, uint32_t defaultValue)
-    {
-        return GetUintParameter(key, defaultValue);
-    }
-
-    bool CallDoReboot(const char *reason)
-    {
-        string rebootCtrl = "ohos.startup.powerctrl";
-#ifdef HARMONY_PROJECT
-        return SetDevItem(rebootCtrl.c_str(), reason);
-#else
-        return false;
-#endif
-    }
-
-    bool RebootDevice(const string &cmd)
-    {
-        string reason = "reboot";
-        if (cmd != "") {
-            reason += ",";
-            reason += cmd;
-        }
-        WRITE_LOG(LOG_DEBUG, "DoReboot with args:[%s] for cmd:[%s]", reason.c_str(), cmd.c_str());
-        return CallDoReboot(reason.c_str());
-    }
-}
-}  // namespace Hdc
diff --git a/hdc/src/daemon/system_depend.h b/hdc/src/daemon/system_depend.h
deleted file mode 100644
index 1a4fa4f..0000000
--- a/hdc/src/daemon/system_depend.h
+++ /dev/null
@@ -1,40 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_SYSTEM_DEPEND_H
-#define HDC_SYSTEM_DEPEND_H
-#include "daemon_common.h"
-
-namespace Hdc {
-namespace SystemDepend {
-#ifdef HDC_SUPPORT_FLASHD
-    // deprecated, remove later
-    inline bool GetDevItem(const char *key, string value)
-    {
-        return false;
-    };
-    inline bool SetDevItem(const char *key, const char *value)
-    {
-        return false;
-    };
-#else
-    bool GetDevItem(const char *key, string &out, const char *preDefine = nullptr);
-    bool SetDevItem(const char *key, const char *value);
-    uint32_t GetDevUint(const char *key, uint32_t defaultValue);
-#endif
-    bool RebootDevice(const string &cmd);
-}  // namespace SystemDepend
-}  // namespace Hdc
-
-#endif  // HDC_BASE_H
diff --git a/hdc/src/daemon/usb_ffs.h b/hdc/src/daemon/usb_ffs.h
deleted file mode 100644
index 7f96156..0000000
--- a/hdc/src/daemon/usb_ffs.h
+++ /dev/null
@@ -1,242 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_USBFFS_H
-#define HDC_USBFFS_H
-// clang-format off
-#include <linux/usb/functionfs.h>
-#include "daemon_common.h"
-// clang-format on
-
-namespace Hdc {
-constexpr auto HDC_USBDR_SND = 0x0;
-constexpr auto HDC_USBDR_RCV = 0x80;
-constexpr auto HDC_USBMD_BLK = 0X02;
-constexpr auto HDC_USBMD_RCV = 0X03;
-constexpr auto HDC_CLASS = 0xff;
-constexpr auto HDC_SUBCLASS = 0x50;
-constexpr auto HDC_FSPKT_SIZE_MAX = 64;
-constexpr auto HDC_HSPKT_SIZE_MAX = 512;
-constexpr uint16_t HDC_SSPKT_SIZE_MAX = 1024;
-constexpr auto USB_FFS_BASE = "/dev/usb-ffs/";
-constexpr auto HDC_USBTF_DEV = 0x01;
-constexpr auto HDC_USBTF_CFG = 0x02;
-constexpr auto HDC_USBTF_STR = 0x03;
-constexpr auto HDC_USBTF_ITF = 0x04;
-constexpr auto HDC_USBTF_EPS = 0x05;
-constexpr auto PROPERTY_NAME_LENGTH = 20;
-constexpr auto PROPERTY_DATA_LENGTH = 39;
-
-#define SHORT_LE(x) htole16(x)
-#define LONG_LE(x) htole32(x)
-#define HDC_INTERFACE_NAME "HDC Interface"
-
-struct UsbFunctionDesc {
-    struct usb_interface_descriptor ifDesc;
-    struct usb_endpoint_descriptor_no_audio from;
-    struct usb_endpoint_descriptor_no_audio to;
-} __attribute__((packed));
-
-static const struct {
-    struct usb_functionfs_strings_head head;
-    struct {
-        __le16 code;
-        const char name[sizeof(HDC_INTERFACE_NAME)];
-    } __attribute__((packed)) firstItem;
-} __attribute__((packed)) USB_FFS_VALUE = {
-    .head =
-        {
-            .magic = LONG_LE(FUNCTIONFS_STRINGS_MAGIC),
-            .length = LONG_LE(sizeof(USB_FFS_VALUE)),
-            .str_count = LONG_LE(1),
-            .lang_count = LONG_LE(1),
-        },
-    .firstItem =
-        {
-            SHORT_LE(0x0409),
-            HDC_INTERFACE_NAME,
-        },
-};
-
-struct UsbFunctionfsDescsHeadOld {
-    __le32 magic;
-    __le32 length;
-    __le32 config1Count;
-    __le32 config2Count;
-} __attribute__((packed));
-
-struct UsbFuncConfig {
-    struct usb_interface_descriptor ifDesc;
-    struct usb_endpoint_descriptor_no_audio from;
-    struct usb_ss_ep_comp_descriptor pairFrom;
-    struct usb_endpoint_descriptor_no_audio to;
-    struct usb_ss_ep_comp_descriptor pairTo;
-} __attribute__((packed));
-
-static struct UsbFuncConfig config3 = {
-    .ifDesc = {
-        .bLength = sizeof(config3.ifDesc),
-        .bDescriptorType = USB_DT_INTERFACE,
-        .bInterfaceNumber = 0,
-        .bNumEndpoints = 2,
-        .bInterfaceClass = HDC_CLASS,
-        .bInterfaceSubClass = HDC_SUBCLASS,
-        .bInterfaceProtocol = VER_PROTOCOL,
-        .iInterface = 1
-    },
-    .from = {
-        .bLength = sizeof(config3.from),
-        .bDescriptorType = USB_DT_ENDPOINT,
-        .bEndpointAddress = 1 | USB_DIR_OUT,
-        .bmAttributes = USB_ENDPOINT_XFER_BULK,
-        .wMaxPacketSize = HDC_SSPKT_SIZE_MAX,
-    },
-    .pairFrom = {
-        .bLength = sizeof(config3.pairFrom),
-        .bDescriptorType = USB_DT_SS_ENDPOINT_COMP,
-        .bMaxBurst = 4,
-    },
-    .to = {
-        .bLength = sizeof(config3.to),
-        .bDescriptorType = USB_DT_ENDPOINT,
-        .bEndpointAddress = 2 | USB_DIR_IN,
-        .bmAttributes = USB_ENDPOINT_XFER_BULK,
-        .wMaxPacketSize = HDC_SSPKT_SIZE_MAX,
-    },
-    .pairTo = {
-        .bLength = sizeof(config3.pairTo),
-        .bDescriptorType = USB_DT_SS_ENDPOINT_COMP,
-        .bMaxBurst = 4,
-    },
-};
-
-static struct UsbFunctionDesc config1 = {
-    .ifDesc = {
-        .bLength = sizeof(config1.ifDesc),
-        .bDescriptorType = USB_DT_INTERFACE,
-        .bInterfaceNumber = 0,
-        .bNumEndpoints = 2,
-        .bInterfaceClass = HDC_CLASS,
-        .bInterfaceSubClass = HDC_SUBCLASS,
-        .bInterfaceProtocol = VER_PROTOCOL,
-        .iInterface = 1
-    },
-    .from = {
-        .bLength = sizeof(config1.from),
-        .bDescriptorType = USB_DT_ENDPOINT,
-        .bEndpointAddress = 1 | USB_DIR_OUT,
-        .bmAttributes = USB_ENDPOINT_XFER_BULK,
-        .wMaxPacketSize = HDC_FSPKT_SIZE_MAX,
-    },
-    .to = {
-        .bLength = sizeof(config1.to),
-        .bDescriptorType = USB_DT_ENDPOINT,
-        .bEndpointAddress = 2 | USB_DIR_IN,
-        .bmAttributes = USB_ENDPOINT_XFER_BULK,
-        .wMaxPacketSize = HDC_FSPKT_SIZE_MAX,
-    },
-};
-
-static struct UsbFunctionDesc config2 = {
-    .ifDesc = {
-        .bLength = sizeof(config2.ifDesc),
-        .bDescriptorType = USB_DT_INTERFACE,
-        .bInterfaceNumber = 0,
-        .bNumEndpoints = 2,
-        .bInterfaceClass = HDC_CLASS,
-        .bInterfaceSubClass = HDC_SUBCLASS,
-        .bInterfaceProtocol = VER_PROTOCOL,
-        .iInterface = 1
-    },
-    .from = {
-        .bLength = sizeof(config2.from),
-        .bDescriptorType = USB_DT_ENDPOINT,
-        .bEndpointAddress = 1 | USB_DIR_OUT,
-        .bmAttributes = USB_ENDPOINT_XFER_BULK,
-        .wMaxPacketSize = HDC_HSPKT_SIZE_MAX,
-    },
-    .to = {
-        .bLength = sizeof(config2.to),
-        .bDescriptorType = USB_DT_ENDPOINT,
-        .bEndpointAddress = 2 | USB_DIR_IN,
-        .bmAttributes = USB_ENDPOINT_XFER_BULK,
-        .wMaxPacketSize = HDC_HSPKT_SIZE_MAX,
-    },
-};
-
-template <size_t PropertyNameLength, size_t PropertyDataLength>
-struct UsbOsDescExtProp {
-    uint32_t size = sizeof(*this);
-    uint32_t propertyDataTypen = LONG_LE(1);
-    uint16_t propertyNameLength = SHORT_LE(PropertyNameLength);
-    char propertyName [PropertyNameLength];
-    uint32_t propertyDataLength = LONG_LE(PropertyDataLength);
-    char property [PropertyDataLength];
-} __attribute__((packed));
-
-using UsbOsDescGuid = UsbOsDescExtProp<PROPERTY_NAME_LENGTH, PROPERTY_DATA_LENGTH>;
-UsbOsDescGuid g_osDescGuid = {
-    .propertyName = "DeviceInterfaceGUID",
-    .property = "{f21cc96b-063d-52e1-e3fd-f39cc7a34c40}",
-};
-
-struct UsbExtPropValues {
-    UsbOsDescGuid guid;
-} __attribute__((packed));
-
-UsbExtPropValues g_osPropValues = {
-    .guid = g_osDescGuid,
-};
-
-struct usb_ext_compat_desc g_wosDesc = {
-    .bFirstInterfaceNumber = 0,
-    .Reserved1 = LONG_LE(1),
-    .CompatibleID = {'W', 'I', 'N', 'U', 'S', 'B', '\0', '\0'},
-    .SubCompatibleID = { 0 },
-    .Reserved2 = { 0 },
-};
-
-struct usb_os_desc_header g_wosHead = {
-    .interface = LONG_LE(0),
-    .dwLength = LONG_LE(sizeof(g_wosHead) + sizeof(g_wosDesc)),
-    .bcdVersion = LONG_LE(1),
-    .wIndex = LONG_LE(4),
-    .bCount = LONG_LE(1),
-    .Reserved = LONG_LE(0),
-};
-
-struct usb_os_desc_header g_osPropHead = {
-    .interface = LONG_LE(0),
-    .dwLength = LONG_LE(sizeof(g_wosHead) + sizeof(g_osPropValues)),
-    .bcdVersion = LONG_LE(1),
-    .wIndex = LONG_LE(5),
-    .wCount = SHORT_LE(1),
-};
-
-struct UsbFunctionfsDescV2 {
-    struct usb_functionfs_descs_head_v2 head;
-    __le32 config1Count;
-    __le32 config2Count;
-    __le32 config3Count;
-    __le32 configWosCount;
-    struct UsbFunctionDesc config1Desc, config2Desc;
-    struct UsbFuncConfig config3Desc;
-    struct usb_os_desc_header wosHead;
-    struct usb_ext_compat_desc wosDesc;
-    struct usb_os_desc_header osPropHead;
-    struct UsbExtPropValues osPropValues;
-} __attribute__((packed));
-
-}  // namespace Hdc
-#endif
diff --git a/hdc/src/host/CMakeLists.txt b/hdc/src/host/CMakeLists.txt
deleted file mode 100644
index eb2995e..0000000
--- a/hdc/src/host/CMakeLists.txt
+++ /dev/null
@@ -1,15 +0,0 @@
-add_definitions(-DUSE_CONFIG_UV_THREADS -DSIZE_THREAD_POOL=128 -DHDC_HOST -DHOST_LINUX -DHARMONY_PROJECT -DTEST_HASH -DHDC_MSG_HASH="TEST")
-
-AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_LIST_DIR} HOST_SRCS)
-AUX_SOURCE_DIRECTORY(${CMAKE_CURRENT_LIST_DIR}/../common COMMON_SRCS)
-
-get_filename_component(MY_RESULT_ABSOLUTE_PATH_VAR
-                       "${CMAKE_CURRENT_LIST_DIR}/${MY_RELATIVE_PATH_VAR}"
-                       ABSOLUTE)
-
-include_directories(${ohos_top}/third_party/libusb/include)
-link_libraries(uv crypto lz4
-    ${ohos_top}/out/sdk/clang_x64/obj/third_party/bounds_checking_function/libsec_static.a
-    ${ohos_top}/out/sdk/clang_x64/common/common/libusb_shared.so)
-
-add_executable(hdc ${COMMON_SRCS} ${HOST_SRCS})
diff --git a/hdc/src/host/client.cpp b/src/host/client.cpp
index e66eb1d..824ca85 100755
--- a/hdc/src/host/client.cpp
+++ b/src/host/client.cpp
@@ -16,7 +16,7 @@
 #ifndef TEST_HASH
 #include "hdc_hash_gen.h"
 #endif
-#include "host_updater.h"
+// #include "host_updater.h"
 #include "server.h"
 #include "file.h"
 
@@ -429,30 +429,30 @@ void HdcClient::CommandWorker(uv_timer_t *handle)
     }
     uv_timer_stop(handle);
     WRITE_LOG(LOG_DEBUG, "Connect server successful");
-    bool closeInput = false;
-    if (!HostUpdater::ConfirmCommand(thisClass->command, closeInput)) {
-        uv_timer_stop(handle);
-        uv_stop(thisClass->loopMain);
-        WRITE_LOG(LOG_DEBUG, "Cmd \'%s\' has been canceld", thisClass->command.c_str());
-        return;
-    }
-    while (closeInput) {
-#ifndef _WIN32
-        if (tcgetattr(STDIN_FILENO, &thisClass->terminalState)) {
-            break;
-        }
-        termios tio;
-        if (tcgetattr(STDIN_FILENO, &tio)) {
-            break;
-        }
-        cfmakeraw(&tio);
-        tio.c_cc[VTIME] = 0;
-        tio.c_cc[VMIN] = 1;
-        tcsetattr(STDIN_FILENO, TCSAFLUSH, &tio);
-        g_terminalStateChange = true;
-#endif
-        break;
-    }
+//     bool closeInput = false;
+//     if (!HostUpdater::ConfirmCommand(thisClass->command, closeInput)) {
+//         uv_timer_stop(handle);
+//         uv_stop(thisClass->loopMain);
+//         WRITE_LOG(LOG_DEBUG, "Cmd \'%s\' has been canceld", thisClass->command.c_str());
+//         return;
+//     }
+//     while (closeInput) {
+// #ifndef _WIN32
+//         if (tcgetattr(STDIN_FILENO, &thisClass->terminalState)) {
+//             break;
+//         }
+//         termios tio;
+//         if (tcgetattr(STDIN_FILENO, &tio)) {
+//             break;
+//         }
+//         cfmakeraw(&tio);
+//         tio.c_cc[VTIME] = 0;
+//         tio.c_cc[VMIN] = 1;
+//         tcsetattr(STDIN_FILENO, TCSAFLUSH, &tio);
+//         g_terminalStateChange = true;
+// #endif
+//         break;
+//     }
     thisClass->Send(thisClass->channel->channelId,
                     const_cast<uint8_t *>(reinterpret_cast<const uint8_t *>(thisClass->command.c_str())),
                     thisClass->command.size() + 1);
diff --git a/hdc/src/host/host_app.cpp b/src/host/host_app.cpp
index 354efa9..32938c6 100644
--- a/hdc/src/host/host_app.cpp
+++ b/src/host/host_app.cpp
@@ -103,15 +103,15 @@ Finish:
     return ret;
 }
 
-bool HdcHostApp::BeginSideload(CtxFile *context, const char *localPath)
-{
-    bool ret = false;
-    context->transferConfig.functionName = CMDSTR_APP_SIDELOAD;
-    context->taskQueue.push_back(localPath);
-    RunQueue(context);
-    ret = true;
-    return ret;
-}
+// bool HdcHostApp::BeginSideload(CtxFile *context, const char *localPath)
+// {
+//     bool ret = false;
+//     context->transferConfig.functionName = CMDSTR_APP_SIDELOAD;
+//     context->taskQueue.push_back(localPath);
+//     RunQueue(context);
+//     ret = true;
+//     return ret;
+// }
 
 void HdcHostApp::RunQueue(CtxFile *context)
 {
@@ -208,10 +208,10 @@ bool HdcHostApp::CommandDispatch(const uint16_t command, uint8_t *payload, const
             ctxNow.taskQueue.push_back(reinterpret_cast<char *>(payload));  // just compatible
             break;
         }
-        case CMD_APP_SIDELOAD: {
-            BeginSideload(&ctxNow, (const char *)payload);
-            break;
-        }
+        // case CMD_APP_SIDELOAD: {
+        //     BeginSideload(&ctxNow, (const char *)payload);
+        //     break;
+        // }
         default:
             break;
     }
diff --git a/hdc/src/host/host_app.h b/src/host/host_app.h
index a64b352..3d648ca 100644
--- a/hdc/src/host/host_app.h
+++ b/src/host/host_app.h
@@ -28,7 +28,7 @@ private:
     void CheckMaster(CtxFile *context) override;
     bool CheckInstallContinue(AppModType mode, bool lastResult, const char *msg);
     void RunQueue(CtxFile *context);
-    bool BeginSideload(CtxFile *context, const char *localPath);
+    // bool BeginSideload(CtxFile *context, const char *localPath);
     string Dir2Tar(const char *dir);
     size_t printedMsgLen = 0;
     string originLocalDir = "";
diff --git a/hdc/src/host/host_common.h b/src/host/host_common.h
index 7a361f6..5683f85 100644
--- a/hdc/src/host/host_common.h
+++ b/src/host/host_common.h
@@ -24,9 +24,9 @@
 #include "serial_struct.h"
 
 #include "host_tcp.h"
-#include "host_usb.h"
+// #include "host_usb.h"
 #ifdef HDC_SUPPORT_UART
-#include "host_uart.h"
+// #include "host_uart.h"
 #endif
 #include "translate.h"
 #include "server_for_client.h"
diff --git a/hdc/src/host/host_uart.cpp b/hdc/src/host/host_uart.cpp
deleted file mode 100644
index 93b1fb4..0000000
--- a/hdc/src/host/host_uart.cpp
+++ /dev/null
@@ -1,795 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifdef HDC_SUPPORT_UART
-
-#include "host_uart.h"
-
-#include <mutex>
-#include <thread>
-
-#include "server.h"
-
-using namespace std::chrono_literals;
-namespace Hdc {
-HdcHostUART::HdcHostUART(HdcServer &serverIn, ExternInterface &externInterface)
-    : HdcUARTBase(serverIn, externInterface), server(serverIn)
-{
-    uv_timer_init(&server.loopMain, &devUartWatcher);
-}
-
-HdcHostUART::~HdcHostUART()
-{
-    Stop();
-}
-
-int HdcHostUART::Initial()
-{
-    uartOpened = false; // modRunning
-    return StartupUARTWork();
-}
-
-bool HdcHostUART::NeedStop(const HSession hSession)
-{
-    return (!uartOpened or (hSession->isDead and hSession->ref == 0));
-}
-
-bool HdcHostUART::IsDeviceOpened(const HdcUART &uart)
-{
-    // review why not use uartOpened?
-#ifdef HOST_MINGW
-    return uart.devUartHandle != INVALID_HANDLE_VALUE;
-#else
-    return uart.devUartHandle >= 0;
-#endif
-}
-
-void HdcHostUART::UartWriteThread()
-{
-    // this thread don't care session.
-    while (true) {
-        WRITE_LOG(LOG_DEBUG, "%s wait sendLock.", __FUNCTION__);
-        transfer.Wait();
-        // it almost in wait , so we check stop after wait.
-        if (stopped) {
-            break;
-        }
-        SendPkgInUARTOutMap();
-    }
-    WRITE_LOG(LOG_INFO, "Leave %s", __FUNCTION__);
-    return;
-}
-
-void HdcHostUART::UartReadThread(HSession hSession)
-{
-    HUART hUART = hSession->hUART;
-    vector<uint8_t> dataReadBuf; // each thread/session have it own data buff
-    // If something unexpected happens , max buffer size we allow
-    WRITE_LOG(LOG_DEBUG, "%s devUartHandle:%d", __FUNCTION__, hUART->devUartHandle);
-    size_t expectedSize = 0;
-    while (dataReadBuf.size() < MAX_READ_BUFFER) {
-        if (NeedStop(hSession)) {
-            WRITE_LOG(LOG_FATAL, "%s stop ", __FUNCTION__);
-            break;
-        }
-        ssize_t bytesRead = ReadUartDev(dataReadBuf, expectedSize, *hUART);
-        if (bytesRead < 0) {
-            WRITE_LOG(LOG_INFO, "%s read got fail , free the session", __FUNCTION__);
-            OnTransferError(hSession);
-        } else if (bytesRead == 0) {
-            WRITE_LOG(LOG_DEBUG, "%s read %zd, clean the data try read again.", __FUNCTION__,
-                      bytesRead);
-            // drop current cache
-            expectedSize = 0;
-            dataReadBuf.clear();
-            continue;
-        }
-
-        WRITE_LOG(LOG_DEBUG, "%s bytesRead:%d, dataReadBuf.size():%d.", __FUNCTION__, bytesRead,
-                  dataReadBuf.size());
-
-        if (dataReadBuf.size() < sizeof(UartHead)) {
-            continue; // no enough ,read again
-        }
-        WRITE_LOG(LOG_DEBUG, "%s PackageProcess dataReadBuf.size():%d.", __FUNCTION__,
-                  dataReadBuf.size());
-        expectedSize = PackageProcess(dataReadBuf, hSession);
-    }
-    WRITE_LOG(LOG_INFO, "Leave %s", __FUNCTION__);
-    return;
-}
-
-// review why not use QueryDosDevice ?
-bool HdcHostUART::EnumSerialPort(bool &portChange)
-{
-    std::vector<string> newPortInfo;
-    serialPortRemoved.clear();
-    bool bRet = true;
-
-#ifdef HOST_MINGW
-    constexpr int MAX_KEY_LENGTH = 255;
-    constexpr int MAX_VALUE_NAME = 16383;
-    HKEY hKey;
-    TCHAR achValue[MAX_VALUE_NAME];    // buffer for subkey name
-    DWORD cchValue = MAX_VALUE_NAME;   // size of name string
-    TCHAR achClass[MAX_PATH] = _T(""); // buffer for class name
-    DWORD cchClassName = MAX_PATH;     // size of class string
-    DWORD cSubKeys = 0;                // number of subkeys
-    DWORD cbMaxSubKey;                 // longest subkey size
-    DWORD cchMaxClass;                 // longest class string
-    DWORD cKeyNum;                     // number of values for key
-    DWORD cchMaxValue;                 // longest value name
-    DWORD cbMaxValueData;              // longest value data
-    DWORD cbSecurityDescriptor;        // size of security descriptor
-    FILETIME ftLastWriteTime;          // last write time
-    LSTATUS iRet = -1;
-    std::string port;
-    TCHAR strDSName[MAX_VALUE_NAME];
-    if (memset_s(strDSName, sizeof(TCHAR) * MAX_VALUE_NAME, 0, sizeof(TCHAR) * MAX_VALUE_NAME) !=
-        EOK) {
-        return false;
-    }
-    DWORD nValueType = 0;
-    DWORD nBuffLen = 10;
-    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T("HARDWARE\\DEVICEMAP\\SERIALCOMM"), 0,
-                                      KEY_READ, &hKey)) {
-        // Get the class name and the value count.
-        iRet = RegQueryInfoKey(hKey, achClass, &cchClassName, NULL, &cSubKeys, &cbMaxSubKey,
-                               &cchMaxClass, &cKeyNum, &cchMaxValue, &cbMaxValueData,
-                               &cbSecurityDescriptor, &ftLastWriteTime);
-        // Enumerate the key values.
-        if (ERROR_SUCCESS == iRet) {
-            for (DWORD i = 0; i < cKeyNum; i++) {
-                cchValue = MAX_VALUE_NAME;
-                achValue[0] = '\0';
-                nBuffLen = MAX_KEY_LENGTH;
-                if (ERROR_SUCCESS == RegEnumValue(hKey, i, achValue, &cchValue, NULL, NULL,
-                                                  (LPBYTE)strDSName, &nBuffLen)) {
-#ifdef UNICODE
-                    strPortName = WstringToString(strDSName);
-#else
-                    port = std::string(strDSName);
-#endif
-                    newPortInfo.push_back(port);
-                    auto it = std::find(serialPortInfo.begin(), serialPortInfo.end(), port);
-                    if (it == serialPortInfo.end()) {
-                        portChange = true;
-                        WRITE_LOG(LOG_DEBUG, "%s:new port %s", __FUNCTION__, port.c_str());
-                    }
-                } else {
-                    bRet = false;
-                    WRITE_LOG(LOG_DEBUG, "%s RegEnumValue fail. %d", __FUNCTION__, GetLastError());
-                }
-            }
-        } else {
-            bRet = false;
-            WRITE_LOG(LOG_DEBUG, "%s RegQueryInfoKey failed %d", __FUNCTION__, GetLastError());
-        }
-    } else {
-        bRet = false;
-        WRITE_LOG(LOG_DEBUG, "%s RegOpenKeyEx fail %d", __FUNCTION__, GetLastError());
-    }
-    RegCloseKey(hKey);
-#endif
-#if defined(HOST_LINUX)||defined(HOST_MAC)
-    DIR *dir = opendir("/dev");
-    dirent *p = NULL;
-
-    while (dir != nullptr && ((p = readdir(dir)) != nullptr)) {
-#ifdef HOST_LINUX
-        if (p->d_name[0] != '.' && string(p->d_name).find("tty") != std::string::npos) {
-#else
-        if (p->d_name[0] != '.' && string(p->d_name).find("serial") != std::string::npos) {
-#endif
-            string port = "/dev/" + string(p->d_name);
-            if (port.find("/dev/ttyUSB") == 0 || port.find("/dev/ttySerial") == 0 || port.find("/dev/cu.") == 0) {
-                newPortInfo.push_back(port);
-                auto it = std::find(serialPortInfo.begin(), serialPortInfo.end(), port);
-                if (it == serialPortInfo.end()) {
-                    portChange = true;
-                    WRITE_LOG(LOG_DEBUG, "new port:%s", port.c_str());
-                }
-            }
-        }
-    }
-    if (dir != nullptr) {
-        closedir(dir);
-    }
-#endif
-    for (auto &oldPort : serialPortInfo) {
-        auto it = std::find(newPortInfo.begin(), newPortInfo.end(), oldPort);
-        if (it == newPortInfo.end()) {
-            // not found in new port list
-            // we need remove the connect info
-            serialPortRemoved.emplace_back(oldPort);
-        }
-    }
-
-    if (!portChange) {
-        // new scan empty , same as port changed
-        if (serialPortInfo.size() != newPortInfo.size()) {
-            portChange = true;
-        }
-    }
-    if (portChange) {
-        serialPortInfo.swap(newPortInfo);
-    }
-    return bRet;
-}
-
-#ifdef HOST_MINGW
-std::string WstringToString(const std::wstring &wstr)
-{
-    if (wstr.empty()) {
-        return std::string();
-    }
-    int size = WideCharToMultiByte(CP_ACP, 0, &wstr[0], (int)wstr.size(), NULL, 0, NULL, NULL);
-    std::string ret = std::string(size, 0);
-    WideCharToMultiByte(CP_ACP, 0, &wstr[0], (int)wstr.size(), &ret[0], size, NULL,
-                        NULL); // CP_UTF8
-    return ret;
-}
-
-// review rename for same func from linux
-int HdcHostUART::WinSetSerial(HUART hUART, string serialPort, int byteSize, int eqBaudRate)
-{
-    int winRet = RET_SUCCESS;
-    COMMTIMEOUTS timeouts;
-    GetCommTimeouts(hUART->devUartHandle, &timeouts);
-    int interTimeout = 5;
-    timeouts.ReadIntervalTimeout = interTimeout;
-    timeouts.ReadTotalTimeoutMultiplier = 0;
-    timeouts.ReadTotalTimeoutConstant = 0;
-    timeouts.WriteTotalTimeoutMultiplier = 0;
-    timeouts.WriteTotalTimeoutConstant = 0;
-    SetCommTimeouts(hUART->devUartHandle, &timeouts);
-    constexpr int max = DEFAULT_BAUD_RATE_VALUE / 8 * 2; // 2 second buffer size
-    do {
-        if (!SetupComm(hUART->devUartHandle, max, max)) {
-            WRITE_LOG(LOG_WARN, "SetupComm %s fail, err:%d.", serialPort.c_str(), GetLastError());
-            winRet = ERR_GENERIC;
-            break;
-        }
-        DCB dcb;
-        if (!GetCommState(hUART->devUartHandle, &dcb)) {
-            WRITE_LOG(LOG_WARN, "GetCommState %s fail, err:%d.", serialPort.c_str(),
-                      GetLastError());
-            winRet = ERR_GENERIC;
-        }
-        dcb.DCBlength = sizeof(DCB);
-        dcb.BaudRate = eqBaudRate;
-        dcb.Parity = 0;
-        dcb.ByteSize = byteSize;
-        dcb.StopBits = ONESTOPBIT;
-        if (!SetCommState(hUART->devUartHandle, &dcb)) {
-            WRITE_LOG(LOG_WARN, "SetCommState %s fail, err:%d.", serialPort.c_str(),
-                      GetLastError());
-            winRet = ERR_GENERIC;
-            break;
-        }
-        if (!PurgeComm(hUART->devUartHandle,
-                       PURGE_RXCLEAR | PURGE_TXCLEAR | PURGE_RXABORT | PURGE_TXABORT)) {
-            WRITE_LOG(LOG_WARN, "PurgeComm  %s fail, err:%d.", serialPort.c_str(), GetLastError());
-            winRet = ERR_GENERIC;
-            break;
-        }
-        DWORD dwError;
-        COMSTAT cs;
-        if (!ClearCommError(hUART->devUartHandle, &dwError, &cs)) {
-            WRITE_LOG(LOG_WARN, "ClearCommError %s fail, err:%d.", serialPort.c_str(),
-                      GetLastError());
-            winRet = ERR_GENERIC;
-            break;
-        }
-    } while (false);
-    if (winRet != RET_SUCCESS) {
-        CloseSerialPort(hUART);
-    }
-    return winRet;
-}
-#endif // HOST_MINGW
-
-bool HdcHostUART::WaitUartIdle(HdcUART &uart, bool retry)
-{
-    std::vector<uint8_t> readBuf;
-    WRITE_LOG(LOG_DEBUG, "%s clear read", __FUNCTION__);
-    ssize_t ret = ReadUartDev(readBuf, 1, uart);
-    if (ret == 0) {
-        WRITE_LOG(LOG_DEBUG, "%s port read timeout", __FUNCTION__);
-        return true;
-    } else {
-        WRITE_LOG(LOG_WARN, "%s port read something %zd", __FUNCTION__, ret);
-        if (retry) {
-            // we will read again , but only retry one time
-            return WaitUartIdle(uart, false);
-        } else {
-            return false;
-        }
-    }
-    return false;
-}
-
-int HdcHostUART::OpenSerialPort(const std::string &connectKey)
-{
-    HdcUART uart;
-    std::string portName;
-    uint32_t baudRate;
-    static int ret = 0;
-
-    if (memset_s(&uart, sizeof(HdcUART), 0, sizeof(HdcUART)) != EOK) {
-        return -1;
-    }
-
-    if (!GetPortFromKey(connectKey, portName, baudRate)) {
-        WRITE_LOG(LOG_ALL, "%s unknown format %s", __FUNCTION__, Hdc::MaskString(connectKey).c_str());
-        return -1;
-    }
-    do {
-        ret = 0;
-        WRITE_LOG(LOG_ALL, "%s try to open %s with rate %u", __FUNCTION__, portName.c_str(),
-                  baudRate);
-
-#ifdef HOST_MINGW
-        constexpr int numTmp = 2;
-        // review change to wstring ?
-        TCHAR apiBuf[PORT_NAME_LEN * numTmp];
-#ifdef UNICODE
-        int cnt = _stprintf_s(apiBuf, sizeof(apiBuf), _T("\\\\.\\%S"), port.c_str());
-#else
-        int cnt = _stprintf_s(apiBuf, sizeof(apiBuf), _T("\\\\.\\%s"), portName.c_str());
-#endif
-        if (cnt < 0) {
-            ret = ERR_GENERIC;
-            break;
-        }
-        DWORD dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED;
-        uart.devUartHandle = CreateFile(apiBuf, GENERIC_READ | GENERIC_WRITE, 0, NULL,
-                                        OPEN_EXISTING, dwFlagsAndAttributes, NULL);
-        if (uart.devUartHandle == INVALID_HANDLE_VALUE) {
-            ret = ERR_GENERIC;
-            WRITE_LOG(LOG_DEBUG, "%s CreateFile %s err:%d.", __FUNCTION__, portName.c_str(),
-                      GetLastError());
-            break; // review for onethan one uart , here we need change to continue?
-        } else {
-            uart.serialPort = portName;
-        }
-        ret = WinSetSerial(&uart, uart.serialPort, UART_BIT2, baudRate);
-        if (ret != RET_SUCCESS) {
-            WRITE_LOG(LOG_WARN, "%s WinSetSerial:%s fail.", __FUNCTION__, uart.serialPort.c_str());
-            break;
-        }
-#endif
-
-#if defined(HOST_LINUX)||defined(HOST_MAC)
-        string uartName = Base::CanonicalizeSpecPath(portName);
-        uart.devUartHandle = open(uartName.c_str(), O_RDWR | O_NOCTTY | O_NONBLOCK);
-        if (uart.devUartHandle < 0) {
-            constexpr int bufSize = 1024;
-            char buf[bufSize] = { 0 };
-            strerror_r(errno, buf, bufSize);
-            WRITE_LOG(LOG_WARN, "Linux open serial port failed, serialPort:%s, Message : %s",
-                      uart.serialPort.c_str(), buf);
-            ret = ERR_GENERIC;
-            break;
-        }
-        {
-            uart.serialPort = portName;
-        }
-        SetSerial(uart.devUartHandle, baudRate, UART_BIT2, 'N', 1);
-#endif
-        // if the dev is idle
-        if (!WaitUartIdle(uart)) {
-            ret = ERR_GENERIC;
-            WRITE_LOG(LOG_INFO, "This is not a Idle UART port: %s", uart.serialPort.c_str());
-            break;
-        }
-        if (!ConnectMyNeed(&uart, connectKey)) {
-            WRITE_LOG(LOG_WARN, "ConnectMyNeed failed");
-            ret = ERR_GENERIC;
-            break;
-        } else {
-            uartOpened = true;
-            WRITE_LOG(LOG_INFO,
-                      "Serial Open Successfully! uart.serialPort:%s "
-                      "devUartHandle:%d",
-                      uart.serialPort.c_str(), uart.devUartHandle);
-        }
-        break;
-    } while (false);
-    if (ret != RET_SUCCESS) {
-        CloseSerialPort(&uart);
-    }
-    return ret;
-}
-
-void HdcHostUART::UpdateUARTDaemonInfo(const std::string &connectKey, HSession hSession,
-                                       ConnStatus connStatus)
-{
-    // add to list
-    HdcDaemonInformation diNew;
-    HDaemonInfo diNewPtr = &diNew;
-    diNew.connectKey = connectKey;
-    diNew.connType = CONN_SERIAL;
-    diNew.connStatus = connStatus;
-    diNew.hSession = hSession;
-    WRITE_LOG(LOG_DEBUG, "%s uart connectKey :%s session %s change to %d", __FUNCTION__,
-              connectKey.c_str(),
-              hSession == nullptr ? "<null>" : hSession->ToDebugString().c_str(), connStatus);
-    if (connStatus == STATUS_UNKNOW) {
-        server.AdminDaemonMap(OP_REMOVE, connectKey, diNewPtr);
-        if (hSession != nullptr and hSession->hUART != nullptr) {
-            connectedPorts.erase(hSession->hUART->serialPort);
-        }
-    } else {
-        if (connStatus == STATUS_CONNECTED) {
-            if (hSession != nullptr and hSession->hUART != nullptr) {
-                connectedPorts.emplace(hSession->hUART->serialPort);
-            }
-        }
-        HDaemonInfo diOldPtr = nullptr;
-        server.AdminDaemonMap(OP_QUERY, connectKey, diOldPtr);
-        if (diOldPtr == nullptr) {
-            WRITE_LOG(LOG_DEBUG, "%s add new di", __FUNCTION__);
-            server.AdminDaemonMap(OP_ADD, connectKey, diNewPtr);
-        } else {
-            server.AdminDaemonMap(OP_UPDATE, connectKey, diNewPtr);
-        }
-    }
-}
-
-bool HdcHostUART::StartUartReadThread(HSession hSession)
-{
-    try {
-        HUART hUART = hSession->hUART;
-        hUART->readThread = std::thread([this, hSession]() { this->UartReadThread(hSession); });
-    } catch (...) {
-        server.FreeSession(hSession->sessionId);
-        UpdateUARTDaemonInfo(hSession->connectKey, hSession, STATUS_UNKNOW);
-        WRITE_LOG(LOG_WARN, "%s failed err", __FUNCTION__);
-        return false;
-    }
-
-    WRITE_LOG(LOG_INFO, "%s success.", __FUNCTION__);
-    return true;
-}
-
-bool HdcHostUART::StartUartSendThread()
-{
-    WRITE_LOG(LOG_DEBUG, "%s.", __FUNCTION__);
-    try {
-        sendThread = std::thread([this]() { this->UartWriteThread(); });
-    } catch (...) {
-        WRITE_LOG(LOG_WARN, "%s sendThread create failed", __FUNCTION__);
-        return false;
-    }
-
-    WRITE_LOG(LOG_INFO, "%s success.", __FUNCTION__);
-    return true;
-}
-
-// Determines that daemonInfo must have the device
-HSession HdcHostUART::ConnectDaemonByUart(const HSession hSession, const HDaemonInfo)
-{
-    if (!uartOpened) {
-        WRITE_LOG(LOG_DEBUG, "%s non uart opened.", __FUNCTION__);
-        return nullptr;
-    }
-    HUART hUART = hSession->hUART;
-    UpdateUARTDaemonInfo(hSession->connectKey, hSession, STATUS_READY);
-    WRITE_LOG(LOG_DEBUG, "%s :%s", __FUNCTION__, hUART->serialPort.c_str());
-    if (!StartUartReadThread(hSession)) {
-        WRITE_LOG(LOG_DEBUG, "%s StartUartReadThread fail.", __FUNCTION__);
-        return nullptr;
-    }
-
-    externInterface.StartWorkThread(&server.loopMain, server.SessionWorkThread,
-                                    Base::FinishWorkThread, hSession);
-    // wait for thread up
-    while (hSession->childLoop.active_handles == 0) {
-        uv_sleep(1);
-    }
-    auto ctrl = server.BuildCtrlString(SP_START_SESSION, 0, nullptr, 0);
-    externInterface.SendToPollFd(hSession->ctrlFd[STREAM_MAIN], ctrl.data(), ctrl.size());
-    return hSession;
-}
-
-RetErrCode HdcHostUART::StartupUARTWork()
-{
-    WRITE_LOG(LOG_DEBUG, "%s", __FUNCTION__);
-    devUartWatcher.data = this;
-    constexpr int interval = 3000;
-    constexpr int delay = 1000;
-    if (externInterface.UvTimerStart(&devUartWatcher, UvWatchUartDevPlugin, delay, interval) != 0) {
-        WRITE_LOG(LOG_FATAL, "devUartWatcher start fail");
-        return ERR_GENERIC;
-    }
-    if (!StartUartSendThread()) {
-        WRITE_LOG(LOG_DEBUG, "%s StartUartSendThread fail.", __FUNCTION__);
-        return ERR_GENERIC;
-    }
-    return RET_SUCCESS;
-}
-
-HSession HdcHostUART::ConnectDaemon(const std::string &connectKey)
-{
-    WRITE_LOG(LOG_DEBUG, "%s", __FUNCTION__);
-    OpenSerialPort(connectKey);
-    return nullptr;
-}
-
-/*
-This function does the following:
-1. Existing serial device, check whether a session is established, if not, go to establish
-2. The connection is established but the serial device does not exist, delete the session
-*/
-void HdcHostUART::WatchUartDevPlugin()
-{
-    std::lock_guard<std::mutex> lock(semUartDevCheck);
-    bool portChange = false;
-
-    if (!EnumSerialPort(portChange)) {
-        WRITE_LOG(LOG_WARN, "%s enumDetailsSerialPorts fail.", __FUNCTION__);
-    } else if (portChange) {
-        for (const auto &port : serialPortInfo) {
-            WRITE_LOG(LOG_INFO, "%s found uart port :%s", __FUNCTION__, port.c_str());
-            // check port have session
-            HDaemonInfo hdi = nullptr;
-            server.AdminDaemonMap(OP_QUERY, port, hdi);
-            if (hdi == nullptr and connectedPorts.find(port) == connectedPorts.end()) {
-                UpdateUARTDaemonInfo(port, nullptr, STATUS_READY);
-            }
-        }
-        for (const auto &port : serialPortRemoved) {
-            WRITE_LOG(LOG_INFO, "%s remove uart port :%s", __FUNCTION__, port.c_str());
-            // check port have session
-            HDaemonInfo hdi = nullptr;
-            server.AdminDaemonMap(OP_QUERY, port, hdi);
-            if (hdi != nullptr and hdi->hSession == nullptr) {
-                // we only remove the empty port
-                UpdateUARTDaemonInfo(port, nullptr, STATUS_UNKNOW);
-            }
-        }
-    }
-}
-
-bool HdcHostUART::ConnectMyNeed(HUART hUART, std::string connectKey)
-{
-    // we never use port to connect, we use connect key
-    if (connectKey.empty()) {
-        connectKey = hUART->serialPort;
-    }
-    if (connectKey != hUART->serialPort) {
-        UpdateUARTDaemonInfo(hUART->serialPort, nullptr, STATUS_UNKNOW);
-    }
-    UpdateUARTDaemonInfo(connectKey, nullptr, STATUS_READY);
-
-    HSession hSession = server.MallocSession(true, CONN_SERIAL, this);
-    if (!hSession) {
-        WRITE_LOG(LOG_FATAL, "malloc serial session failed for %s", Hdc::MaskString(connectKey).c_str());
-        return false;
-    }
-    hSession->connectKey = connectKey;
-#if defined(HOST_LINUX)||defined(HOST_MAC)
-    hSession->hUART->devUartHandle = hUART->devUartHandle;
-#elif defined(HOST_MINGW)
-    hSession->hUART->devUartHandle = hUART->devUartHandle;
-#endif
-
-    hSession->isCheck = isCheck;
-    hSession->hUART->serialPort = hUART->serialPort;
-    WRITE_LOG(LOG_DEBUG, "%s connectkey:%s,port:%s", __FUNCTION__, Hdc::MaskString(hSession->connectKey).c_str(),
-              hUART->serialPort.c_str());
-    uv_timer_t *waitTimeDoCmd = new(std::nothrow) uv_timer_t;
-    if (waitTimeDoCmd == nullptr) {
-        WRITE_LOG(LOG_FATAL, "ConnectMyNeed new waitTimeDoCmd failed");
-        server.FreeSession(hSession->sessionId);
-        return false;
-    }
-    uv_timer_init(&server.loopMain, waitTimeDoCmd);
-    waitTimeDoCmd->data = hSession;
-    if (externInterface.UvTimerStart(waitTimeDoCmd, server.UartPreConnect, UV_TIMEOUT, UV_REPEAT) !=
-        RET_SUCCESS) {
-        WRITE_LOG(LOG_DEBUG, "%s for %s:%s fail.", __FUNCTION__, Hdc::MaskString(hSession->connectKey).c_str(),
-                  hUART->serialPort.c_str());
-        server.FreeSession(hSession->sessionId);
-        return false;
-    }
-    WRITE_LOG(LOG_DEBUG, "%s %s register a session", __FUNCTION__, hUART->serialPort.c_str());
-
-    return true;
-}
-
-void HdcHostUART::KickoutZombie(HSession hSession)
-{
-    if (hSession == nullptr or hSession->hUART == nullptr or hSession->isDead) {
-        return;
-    }
-#ifdef _WIN32
-    if (hSession->hUART->devUartHandle == INVALID_HANDLE_VALUE) {
-        return;
-    }
-#else
-    if (hSession->hUART->devUartHandle < 0) {
-        return;
-    }
-#endif
-    WRITE_LOG(LOG_DEBUG, "%s FreeSession %s", __FUNCTION__, hSession->ToDebugString().c_str());
-    server.FreeSession(hSession->sessionId);
-}
-
-HSession HdcHostUART::GetSession(const uint32_t sessionId, bool)
-{
-    return server.AdminSession(OP_QUERY, sessionId, nullptr);
-}
-void HdcHostUART::CloseSerialPort(const HUART hUART)
-{
-    WRITE_LOG(LOG_DEBUG, "%s try to close dev handle %d", __FUNCTION__, hUART->devUartHandle);
-
-#ifdef _WIN32
-    if (hUART->devUartHandle != INVALID_HANDLE_VALUE) {
-        CloseHandle(hUART->devUartHandle);
-        hUART->devUartHandle = INVALID_HANDLE_VALUE;
-    }
-#else
-    if (hUART->devUartHandle != -1) {
-        Base::CloseFd(hUART->devUartHandle);
-        hUART->devUartHandle = -1;
-    }
-#endif
-}
-
-void HdcHostUART::OnTransferError(const HSession session)
-{
-    if (session != nullptr) {
-        WRITE_LOG(LOG_FATAL, "%s:%s", __FUNCTION__, session->ToDebugString().c_str());
-        if (session->hUART != nullptr) {
-            if (IsDeviceOpened(*session->hUART)) {
-                // same device dont echo twice to client
-                string echoStr = "ERR: uart link layer transmission error.\n";
-                server.EchoToClientsForSession(session->sessionId, echoStr);
-            }
-            // 1. dev opened by other application
-            // 2. dev is plug out
-            // 3. dev line is broken ?
-            // we set the status to empty
-            // watcher will reopen it if it can find this again
-            CloseSerialPort(session->hUART);
-            UpdateUARTDaemonInfo(session->connectKey, session, STATUS_OFFLINE);
-        }
-
-        server.FreeSession(session->sessionId);
-        ClearUARTOutMap(session->sessionId);
-    }
-}
-
-// review what about merge Restartession with OnTransferError ?
-void HdcHostUART::Restartession(const HSession session)
-{
-    HdcUARTBase::Restartession(session);
-    // allow timer watcher make a new session.
-    if (session != nullptr and session->hUART != nullptr) {
-        WRITE_LOG(LOG_FATAL, "%s reset serialPort:%s", __FUNCTION__,
-                  session->hUART->serialPort.c_str());
-        CloseSerialPort(session->hUART); // huart will free , so we must clost it here
-        server.EchoToClientsForSession(session->sessionId,
-                                       "uart link released by daemon. need connect again.");
-    }
-}
-
-void HdcHostUART::StopSession(HSession hSession)
-{
-    if (hSession == nullptr) {
-        WRITE_LOG(LOG_FATAL, "%s hSession is null", __FUNCTION__);
-        return;
-    }
-    WRITE_LOG(LOG_DEBUG, "%s hSession %s will be stop and free", __FUNCTION__,
-              hSession->ToDebugString().c_str());
-    HUART hUART = hSession->hUART;
-    if (hUART == nullptr) {
-        WRITE_LOG(LOG_FATAL, "%s hUART is null", __FUNCTION__);
-    } else {
-#ifdef _WIN32
-        CancelIoEx(hUART->devUartHandle, NULL);
-#endif
-        // we make select always have a timeout in linux
-        // also we make a mark here
-        // ReadUartDev will return for this flag
-        hUART->ioCancel = true;
-
-        if (hUART->readThread.joinable()) {
-            WRITE_LOG(LOG_DEBUG, "wait readThread Stop");
-            hUART->readThread.join();
-        } else {
-            WRITE_LOG(LOG_FATAL, "readThread is not joinable");
-        }
-    }
-
-    // call the base side
-    HdcUARTBase::StopSession(hSession);
-}
-
-std::vector<std::string> HdcHostUART::StringSplit(std::string source, std::string split)
-{
-    std::vector<std::string> result;
-
-    // find
-    if (!split.empty()) {
-        size_t pos = 0;
-        while ((pos = source.find(split)) != std::string::npos) {
-            // split
-            std::string token = source.substr(0, pos);
-            if (!token.empty()) {
-                result.push_back(token);
-            }
-            source.erase(0, pos + split.length());
-        }
-    }
-    // add last token
-    if (!source.empty()) {
-        result.push_back(source);
-    }
-    return result;
-}
-
-bool HdcHostUART::GetPortFromKey(const std::string &connectKey, std::string &portName,
-                                 uint32_t &baudRate)
-{
-    // we support UART_NAME:UART_RATE format
-    // like COM5:115200
-    constexpr size_t TWO_ARGS = 2;
-    std::vector<std::string> result = StringSplit(connectKey, ",");
-    if (result.size() == TWO_ARGS) {
-        portName = result[0];
-        try {
-            baudRate = static_cast<uint32_t>(std::stoul(result[1]));
-        } catch (...) {
-            return false;
-        }
-        return true;
-    } else if (result.size() == 1) {
-        portName = result[0];
-        baudRate = DEFAULT_BAUD_RATE_VALUE;
-        return true;
-    } else {
-        return false;
-    }
-}
-
-void HdcHostUART::SendUartSoftReset(HSession hSession, uint32_t sessionId)
-{
-    UartHead resetPackage(sessionId, PKG_OPTION_RESET);
-    resetPackage.dataSize = sizeof(UartHead);
-    RequestSendPackage(reinterpret_cast<uint8_t *>(&resetPackage), sizeof(UartHead), false);
-}
-
-void HdcHostUART::Stop()
-{
-    WRITE_LOG(LOG_DEBUG, "%s Stop!", __FUNCTION__);
-    if (!stopped) {
-        externInterface.TryCloseHandle((uv_handle_t *)&devUartWatcher);
-        uartOpened = false;
-        stopped = true;
-        // just click it for exit
-        NotifyTransfer();
-        if (sendThread.joinable()) {
-            WRITE_LOG(LOG_DEBUG, "%s wait sendThread Stop!", __FUNCTION__);
-            sendThread.join();
-        } else {
-            WRITE_LOG(LOG_FATAL, "%s sendThread is not joinable", __FUNCTION__);
-        }
-    }
-}
-} // namespace Hdc
-#endif // HDC_SUPPORT_UART
diff --git a/hdc/src/host/host_uart.h b/hdc/src/host/host_uart.h
deleted file mode 100644
index 23f361a..0000000
--- a/hdc/src/host/host_uart.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_HOST_UART_H
-#define HDC_HOST_UART_H
-#include <condition_variable>
-#include "host_common.h"
-#ifdef HOST_MINGW
-#include "tchar.h"
-#include "windows.h"
-#include <setupapi.h>
-#include <winnt.h>
-#elif defined(HOST_LINUX)||defined(HOST_MAC)
-#include <fcntl.h> // open close
-#include <pthread.h>
-#include <termios.h> // truct termios
-#endif
-
-namespace Hdc {
-class HdcServer;
-
-class HdcHostUART : public HdcUARTBase {
-public:
-    explicit HdcHostUART(HdcServer&, ExternInterface& = HdcUARTBase::defaultInterface);
-    ~HdcHostUART();
-    int Initial();
-    virtual void Stop();
-    HSession ConnectDaemonByUart(const HSession hSession,
-                                 [[maybe_unused]] const HDaemonInfo = nullptr);
-
-    // logic layer will free the session
-    // all the thread maybe need exit if needed.
-    void StopSession(HSession hSession) override;
-    HSession ConnectDaemon(const std::string &connectKey);
-    void SetCheckFlag(bool flag) { isCheck = flag; };
-
-protected:
-    virtual void OnTransferError(const HSession session) override;
-    virtual HSession GetSession(const uint32_t sessionId, bool create) override;
-    virtual void Restartession(const HSession session) override;
-
-private:
-    enum UartCheckStatus {
-        HOST_UART_EMPTY = 0, // default value
-        HOST_UART_IGNORE = 1,
-        HOST_UART_READY,
-        HOST_UART_REGISTER,
-    };
-    // review maybe merge to base ?
-    virtual bool StartUartSendThread();
-    virtual bool StartUartReadThread(HSession hSession);
-
-    size_t SendUARTDev(HSession hSession, uint8_t *data, const size_t length);
-    static inline void UvWatchUartDevPlugin(uv_timer_t *handle)
-    {
-        if (handle != nullptr) {
-            HdcHostUART *thisClass = static_cast<HdcHostUART *>(handle->data);
-            if (thisClass != nullptr) {
-                thisClass->WatchUartDevPlugin();
-                return;
-            }
-        }
-        WRITE_LOG(LOG_FATAL, "%s have not got correct class parameter", __FUNCTION__);
-    };
-    virtual void WatchUartDevPlugin();
-    void KickoutZombie(HSession hSession);
-    virtual void UpdateUARTDaemonInfo(const std::string &connectKey, HSession hSession, ConnStatus connStatus);
-    bool ConnectMyNeed(HUART hUART, std::string connectKey = "");
-    virtual int OpenSerialPort(const std::string &portName = "");
-    virtual void CloseSerialPort(const HUART hUART);
-    virtual RetErrCode StartupUARTWork();
-
-    // we use this function check if the uart read nothing in a timeout
-    // if not , that means this uart maybe not our daemon
-    // More importantly, the bootloader will output data. We use this to detect whether it is the
-    // bootloader stage.
-    virtual bool WaitUartIdle(HdcUART &uart, bool retry = true);
-    virtual void SendUartSoftReset(HSession hSession, uint32_t sessionId) override;
-
-    virtual bool EnumSerialPort(bool &portChange);
-    virtual bool IsDeviceOpened(const HdcUART &uart);
-    virtual bool NeedStop(const HSession hSession);
-    virtual void UartReadThread(HSession hSession);
-#ifdef HOST_MINGW
-    int WinSetSerial(HUART hUART, string serialPort, int byteSize, int eqBaudRate);
-    bool enumDetailsSerialPorts(bool *portChange);
-    static constexpr uint8_t PORT_NAME_LEN = 10;
-    static constexpr uint8_t PORT_NUM = 100;
-#elif defined(HOST_LINUX)||defined(HOST_MAC)
-    void EnumLinuxSerialPort(bool *PortStatusChange);
-#endif
-    virtual void UartWriteThread();
-
-    uv_timer_t devUartWatcher;
-    std::mutex semUartDevCheck;
-    uint32_t baudRate = 0;
-    const int intervalDevCheck = 3000;
-    std::map<string, UartCheckStatus> mapIgnoreDevice;
-    std::unordered_set<std::string> connectedPorts;
-    std::vector<string> serialPortInfo;
-    std::vector<string> serialPortRemoved;
-    bool uartOpened = false;
-    std::thread sendThread;
-    bool isCheck = false;
-
-    std::vector<std::string> StringSplit(std::string source, std::string split = ":");
-    bool GetPortFromKey(const std::string &connectKey, std::string &portName, uint32_t &baudRate);
-    HdcServer &server;
-};
-} // namespace Hdc
-#endif
diff --git a/hdc/src/host/host_updater.cpp b/hdc/src/host/host_updater.cpp
deleted file mode 100755
index 11aefc7..0000000
--- a/hdc/src/host/host_updater.cpp
+++ /dev/null
@@ -1,328 +0,0 @@
-/*
- * Copyright (C) 2022 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "host_updater.h"
-
-#include <algorithm>
-#include <unordered_map>
-
-#include "common.h"
-#include "define.h"
-#include "serial_struct.h"
-
-namespace Hdc {
-namespace {
-constexpr uint8_t PERCENT_FINISH = 100;
-constexpr uint8_t PERCENT_CLEAR = UINT8_MAX;
-constexpr int MAX_RETRY_COUNT = 3;
-constexpr size_t FLASH_PARAM_MIN_COUNT = 2;
-constexpr size_t FLASH_FILE_INDEX = 1;
-constexpr size_t UPDATE_PARAM_MIN_COUNT = 1;
-constexpr size_t UPDATE_FILE_INDEX = 0;
-constexpr size_t FORMAT_PARAM_MIN_COUNT = 2;
-constexpr size_t ERASE_PARAM_MIN_COUNT = 2;
-
-const std::string CMD_STR_UPDATE = "update ";
-const std::string CMD_STR_FLASH = "flash ";
-const std::string CMD_STR_ERASE = "erase ";
-const std::string CMD_STR_FORMAT = "format ";
-
-const std::unordered_map<std::string, uint16_t> FLASHD_CMD = {
-    {CMD_STR_UPDATE, CMD_FLASHD_UPDATE_INIT},
-    {CMD_STR_FLASH, CMD_FLASHD_FLASH_INIT},
-    {CMD_STR_ERASE, CMD_FLASHD_ERASE},
-    {CMD_STR_FORMAT, CMD_FLASHD_FORMAT},
-};
-
-std::vector<std::string> Split(const std::string &src, const std::vector<std::string> &filter)
-{
-    std::vector<std::string> result;
-    if (src.empty()) {
-        return result;
-    }
-    const auto len = src.size() + 1;
-    auto buffer = std::vector<char>(len, 0);
-    buffer.assign(src.begin(), src.end());
-    const char delimit[] = "\t\r\n ";
-    char *nextToken = nullptr;
-    char *token = strtok_s(buffer.data(), delimit, &nextToken);
-    while (token != nullptr) {
-        if (std::find(filter.cbegin(), filter.cend(), token) == filter.cend()) {
-            result.push_back(token);
-        }
-        token = strtok_s(nullptr, delimit, &nextToken);
-    }
-    return result;
-}
-}
-
-HostUpdater::HostUpdater(HTaskInfo hTaskInfo) : HdcTransferBase(hTaskInfo)
-{
-    commandBegin = CMD_FLASHD_BEGIN;
-    commandData = CMD_FLASHD_DATA;
-}
-
-HostUpdater::~HostUpdater() {}
-
-void HostUpdater::RunQueue(CtxFile &context)
-{
-    refCount++;
-    context.localPath = context.taskQueue.back();
-    uv_fs_open(loopTask, &context.fsOpenReq, context.localPath.c_str(), O_RDONLY, 0, OnFileOpen);
-    context.master = true;
-}
-
-bool HostUpdater::BeginTransfer(const std::string &function, const uint8_t *payload, int payloadSize, size_t minParam,
-                                size_t fileIndex)
-{
-    if (payload[payloadSize - 1] != '\0') {
-        WRITE_LOG(LOG_FATAL, "payload is invalid");
-        return false;
-    }
-    std::string cmdParam(reinterpret_cast<const char *>(payload));
-    auto params = Split(cmdParam, {});
-    auto count = minParam;
-    auto index = fileIndex;
-    if (std::find(params.cbegin(), params.cend(), "-f") != params.cend()) {
-        count++;
-        index++;
-    }
-    if (params.size() != count || params.size() <= index) {
-        WRITE_LOG(LOG_FATAL, "param count is invalid");
-        return false;
-    }
-
-    std::string localPath = params[index];
-    if (!Base::CheckDirectoryOrPath(localPath.c_str(), true, true)) {
-        WRITE_LOG(LOG_FATAL, "localPath is invalid");
-        return false;
-    }
-
-    if (MatchPackageExtendName(localPath, ".img") || MatchPackageExtendName(localPath, ".bin") ||
-        MatchPackageExtendName(localPath, ".fd") || MatchPackageExtendName(localPath, ".cpio")) {
-        ctxNow.transferConfig.compressType = COMPRESS_NONE;
-    } else if (MatchPackageExtendName(localPath, ".zip")) {
-        WRITE_LOG(LOG_INFO, "file type is zip");
-    } else {
-        WRITE_LOG(LOG_FATAL, "file type is invalid");
-        return false;
-    }
-    ctxNow.transferConfig.functionName = function;
-    ctxNow.transferConfig.options = cmdParam;
-    ctxNow.localPath = localPath;
-    ctxNow.taskQueue.push_back(localPath);
-    RunQueue(ctxNow);
-    return true;
-}
-
-void HostUpdater::CheckMaster(CtxFile *context)
-{
-    uv_fs_t fs;
-    Base::ZeroStruct(fs.statbuf);
-    uv_fs_fstat(nullptr, &fs, context->fsOpenReq.result, nullptr);
-    context->transferConfig.fileSize = fs.statbuf.st_size;
-    uv_fs_req_cleanup(&fs);
-    context->transferConfig.optionalName = Base::GetFileNameAny(context->localPath);
-    std::string bufString = SerialStruct::SerializeToString(context->transferConfig);
-
-    WRITE_LOG(LOG_DEBUG, "functionName = %s, fileSize = %llu", context->transferConfig.functionName.c_str(),
-        context->transferConfig.fileSize);
-
-    std::vector<uint8_t> buffer(sizeof(uint64_t) / sizeof(uint8_t), 0);
-    buffer.insert(buffer.end(), bufString.begin(), bufString.end());
-    SendToAnother(CMD_FLASHD_CHECK, (uint8_t *)buffer.data(), buffer.size());
-}
-
-bool HostUpdater::CheckCmd(HdcCommand command, uint8_t *payload, int payloadSize, size_t paramCount)
-{
-    if (payloadSize < 1 || payload[payloadSize - 1] != '\0') {
-        WRITE_LOG(LOG_FATAL, "payload is invalid");
-        return false;
-    }
-    std::string cmdParam(reinterpret_cast<char *>(payload));
-    WRITE_LOG(LOG_INFO, "cmdParam = %s, paramCount = %u", cmdParam.c_str(), paramCount);
-
-    auto result = Split(cmdParam, {});
-    auto iter = std::find(result.cbegin(), result.cend(), "-f");
-    bool ret = (iter != result.cend()) ? (result.size() == (paramCount + 1)) : (result.size() == paramCount);
-    if (!ret) {
-        WRITE_LOG(LOG_FATAL, "CheckCmd failed");
-        return false;
-    }
-
-    SendToAnother(command, payload, payloadSize);
-    ctxNow.taskQueue.push_back(cmdParam);
-    return true;
-}
-
-bool HostUpdater::CommandDispatch(const uint16_t command, uint8_t *payload, const int payloadSize)
-{
-    if (command == CMD_FLASHD_BEGIN) {
-        if (!HdcTransferBase::CommandDispatch(command, payload, payloadSize)) {
-            return false;
-        }
-        std::string tip("Processing:    0%");
-        sendProgress_ = true;
-        SendRawData(tip);
-        return true;
-    }
-
-    if (payload == nullptr || payloadSize <= 0) {
-        WRITE_LOG(LOG_FATAL, "payload or payloadSize is invalid");
-        return false;
-    }
-    if (!HdcTransferBase::CommandDispatch(command, payload, payloadSize)) {
-        return false;
-    }
-    bool ret = true;
-    switch (command) {
-        case CMD_FLASHD_UPDATE_INIT:
-            ret = BeginTransfer(CMDSTR_FLASHD_UPDATE, payload, payloadSize, UPDATE_PARAM_MIN_COUNT, UPDATE_FILE_INDEX);
-            break;
-        case CMD_FLASHD_FLASH_INIT:
-            ret = BeginTransfer(CMDSTR_FLASHD_FLASH, payload, payloadSize, FLASH_PARAM_MIN_COUNT, FLASH_FILE_INDEX);
-            break;
-        case CMD_FLASHD_FINISH:
-            ret = CheckUpdateContinue(command, payload, payloadSize);
-            break;
-        case CMD_FLASHD_ERASE:
-            ret = CheckCmd(CMD_FLASHD_ERASE, payload, payloadSize, ERASE_PARAM_MIN_COUNT);
-            break;
-        case CMD_FLASHD_FORMAT:
-            ret = CheckCmd(CMD_FLASHD_FORMAT, payload, payloadSize, FORMAT_PARAM_MIN_COUNT);
-            break;
-        case CMD_FLASHD_PROGRESS:
-            ProcessProgress(*payload);
-            break;
-        default:
-            break;
-    }
-    return ret;
-}
-
-void HostUpdater::ProcessProgress(uint8_t percentage)
-{
-    if (!sendProgress_) {
-        return;
-    }
-    if (percentage == PERCENT_CLEAR) {
-        SendRawData("\n");
-        sendProgress_ = false;
-        return;
-    }
-    std::string plrogress = "\rProcessing:    " + std::to_string(percentage) + "%";
-    SendRawData(plrogress);
-    if (percentage == PERCENT_FINISH) {
-        SendRawData("\n");
-        sendProgress_ = false;
-    }
-}
-
-bool HostUpdater::CheckUpdateContinue(const uint16_t command, const uint8_t *payload, int payloadSize)
-{
-    if (static_cast<size_t>(payloadSize) < sizeof(uint16_t)) {
-        return false;
-    }
-
-    MessageLevel level = static_cast<MessageLevel>(payload[1]);
-    if ((level == MSG_OK) && sendProgress_) {
-        ProcessProgress(PERCENT_FINISH);
-    }
-    std::string info(reinterpret_cast<char *>(const_cast<uint8_t *>(payload + sizeof(uint16_t))),
-                     payloadSize - sizeof(uint16_t));
-    if (!info.empty()) {
-        LogMsg(level, "%s", info.c_str());
-    }
-    WRITE_LOG(LOG_DEBUG, "CheckUpdateContinue payloadSize %d %d %s", payloadSize, level, info.c_str());
-    if (ctxNow.taskQueue.size() != 0) {
-        ctxNow.taskQueue.pop_back();
-    }
-    if (singalStop || !ctxNow.taskQueue.size()) {
-        return false;
-    }
-    RunQueue(ctxNow);
-    return true;
-}
-
-bool HostUpdater::CheckMatchUpdate(const std::string &input, TranslateCommand::FormatCommand &outCmd)
-{
-    WRITE_LOG(LOG_DEBUG, "CheckMatchUpdate command:%s", input.c_str());
-    for (const auto &iter : FLASHD_CMD) {
-        if ((input.find(iter.first) == 0) && (input.size() > iter.first.size())) {
-            outCmd.cmdFlag = iter.second;
-            return true;
-        }
-    }
-    return false;
-}
-
-bool HostUpdater::ConfirmCommand(const string &commandIn, bool &closeInput)
-{
-    std::string tip = "";
-    if (!strncmp(commandIn.c_str(), CMD_STR_UPDATE.c_str(), CMD_STR_UPDATE.size())) {
-        closeInput = true;
-    } else if (!strncmp(commandIn.c_str(), CMD_STR_FLASH.c_str(), CMD_STR_FLASH.size())) {
-        tip = "Confirm flash partition";
-        closeInput = true;
-    } else if (!strncmp(commandIn.c_str(), CMD_STR_ERASE.c_str(), CMD_STR_ERASE.size())) {
-        tip = "Confirm erase partition";
-    } else if (!strncmp(commandIn.c_str(), CMD_STR_FORMAT.c_str(), CMD_STR_FORMAT.size())) {
-        tip = "Confirm format partition";
-    }
-    if (tip.empty() || strstr(commandIn.c_str(), " -f") != nullptr) {
-        return true;
-    }
-    const size_t minLen = strlen("yes");
-    int retryCount = 0;
-    do {
-        printf("%s ? (Yes/No) ", tip.c_str());
-        fflush(stdin);
-        std::string info = {};
-        size_t i = 0;
-        while (1) {
-            char c = getchar();
-            if (c == '\r' || c == '\n') {
-                break;
-            }
-            if (c == ' ') {
-                continue;
-            }
-            if (i < minLen && isprint(c)) {
-                info.append(1, std::tolower(c));
-                i++;
-            }
-        }
-        if (info == "n" || info == "no") {
-            return false;
-        }
-        if (info == "y" || info == "yes") {
-            return true;
-        }
-        retryCount++;
-    } while (retryCount < MAX_RETRY_COUNT);
-    return (retryCount >= MAX_RETRY_COUNT) ? false : true;
-}
-
-void HostUpdater::SendRawData(std::string rawData) const
-{
-    HdcSessionBase *sessionBase = (HdcSessionBase *)clsSession;
-    if (sessionBase == nullptr) {
-        WRITE_LOG(LOG_FATAL, "sessionBase is null");
-        return;
-    }
-    sessionBase->ServerCommand(taskInfo->sessionId, taskInfo->channelId, CMD_KERNEL_ECHO_RAW,
-        reinterpret_cast<uint8_t *>(rawData.data()), rawData.size());
-}
-} // namespace Hdc
\ No newline at end of file
diff --git a/hdc/src/host/host_updater.h b/hdc/src/host/host_updater.h
deleted file mode 100755
index d14e9d2..0000000
--- a/hdc/src/host/host_updater.h
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (C) 2022 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HDC_HOST_UPDATER_H
-#define HDC_HOST_UPDATER_H
-
-#include "transfer.h"
-#include "translate.h"
-
-namespace Hdc {
-class HostUpdater : public HdcTransferBase {
-public:
-    explicit HostUpdater(HTaskInfo hTaskInfo);
-    virtual ~HostUpdater();
-    bool CommandDispatch(const uint16_t command, uint8_t *payload, const int payloadSize) override;
-    static bool CheckMatchUpdate(const std::string &input, TranslateCommand::FormatCommand &outCmd);
-    static bool ConfirmCommand(const string &commandIn, bool &closeInput);
-
-protected:
-    void CheckMaster(CtxFile *context) override;
-
-private:
-    bool BeginTransfer(const std::string &function, const uint8_t *payload, int payloadSize, size_t minParam,
-    size_t fileIndex);
-    bool CheckUpdateContinue(const uint16_t command, const uint8_t *payload, int payloadSize);
-    void RunQueue(CtxFile &context);
-    void ProcessProgress(uint8_t percentage);
-    void SendRawData(std::string rawData) const;
-    bool CheckCmd(HdcCommand command, uint8_t *payload, int payloadSize, size_t paramCount);
-
-private:
-    bool sendProgress_ = false;
-};
-}
-#endif
\ No newline at end of file
diff --git a/hdc/src/host/host_usb.cpp b/hdc/src/host/host_usb.cpp
deleted file mode 100644
index d46e6cd..0000000
--- a/hdc/src/host/host_usb.cpp
+++ /dev/null
@@ -1,788 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "host_usb.h"
-#include <stdlib.h>
-#include <thread>
-
-#include "server.h"
-namespace Hdc {
-HdcHostUSB::HdcHostUSB(const bool serverOrDaemonIn, void *ptrMainBase, void *ctxUSBin)
-    : HdcUSBBase(serverOrDaemonIn, ptrMainBase)
-{
-    modRunning = false;
-    HdcServer *pServer = (HdcServer *)ptrMainBase;
-    ctxUSB = (libusb_context *)ctxUSBin;
-    uv_timer_init(&pServer->loopMain, &devListWatcher);
-}
-
-HdcHostUSB::~HdcHostUSB()
-{
-    if (modRunning) {
-        Stop();
-    }
-    WRITE_LOG(LOG_DEBUG, "~HdcHostUSB");
-}
-
-void HdcHostUSB::Stop()
-{
-    if (!ctxUSB) {
-        return;
-    }
-    Base::TryCloseHandle((uv_handle_t *)&devListWatcher);
-    modRunning = false;
-}
-
-int HdcHostUSB::Initial()
-{
-    if (!ctxUSB) {
-        WRITE_LOG(LOG_FATAL, "USB mod ctxUSB is nullptr, recompile please");
-        return -1;
-    }
-    WRITE_LOG(LOG_DEBUG, "HdcHostUSB init");
-    modRunning = true;
-    StartupUSBWork();  // Main thread registration, IO in sub-thread
-    return 0;
-}
-
-static void UsbLogHandler(libusb_context* ctx, enum libusb_log_level level, const char* str)
-{
-    int l = -1;
-    switch (level) {
-        case LIBUSB_LOG_LEVEL_ERROR:
-            l = LOG_FATAL;
-            break;
-        case LIBUSB_LOG_LEVEL_WARNING:
-            l = LOG_WARN;
-            break;
-        case LIBUSB_LOG_LEVEL_INFO:
-            l = LOG_INFO;
-            break;
-        case LIBUSB_LOG_LEVEL_DEBUG:
-            l = LOG_DEBUG;
-            break;
-        default:
-            break;
-    }
-    if (l >= 0) {
-        char *newStr = strdup(str);
-        if (!newStr) {
-            return;
-        }
-        char *p = strstr(newStr, "libusb:");
-        if (!p) {
-            p = newStr;
-        }
-        char *q = strrchr(newStr, '\n');
-        if (q) {
-            *q = '\0';
-        }
-        WRITE_LOG(l, "%s", p);
-        free(newStr);
-    }
-}
-void HdcHostUSB::InitLogging(void *ctxUSB)
-{
-    if (ctxUSB == nullptr) {
-        WRITE_LOG(LOG_FATAL, "InitLogging failed ctxUSB is nullptr");
-        return;
-    }
-    std::string debugEnv = "LIBUSB_DEBUG";
-    libusb_log_level debugLevel;
-
-    switch (static_cast<Hdc::HdcLogLevel>(Base::GetLogLevel())) {
-        case LOG_WARN:
-            debugLevel = LIBUSB_LOG_LEVEL_ERROR;
-            break;
-        case LOG_INFO:
-            debugLevel = LIBUSB_LOG_LEVEL_WARNING;
-            break;
-        case LOG_DEBUG:
-            debugLevel = LIBUSB_LOG_LEVEL_INFO;
-            break;
-        case LOG_VERBOSE:
-            debugLevel = LIBUSB_LOG_LEVEL_DEBUG;
-            break;
-        case LOG_FATAL:
-            // pass through to no libusb logging
-        default:
-            debugLevel = LIBUSB_LOG_LEVEL_NONE;
-            break;
-    }
-
-    libusb_set_option((libusb_context *)ctxUSB, LIBUSB_OPTION_LOG_LEVEL, debugLevel);
-    libusb_set_log_cb((libusb_context *)ctxUSB, UsbLogHandler,
-                      LIBUSB_LOG_CB_CONTEXT | LIBUSB_LOG_CB_GLOBAL);
-
-#ifdef _WIN32
-    debugEnv += "=";
-    debugEnv += std::to_string(debugLevel);
-    _putenv(debugEnv.c_str());
-#else
-    setenv(debugEnv.c_str(), std::to_string(debugLevel).c_str(), 1);
-#endif
-}
-
-bool HdcHostUSB::DetectMyNeed(libusb_device *device, string &sn)
-{
-    HUSB hUSB = new(std::nothrow) HdcUSB();
-    if (hUSB == nullptr) {
-        WRITE_LOG(LOG_FATAL, "DetectMyNeed new hUSB failed");
-        return false;
-    }
-    hUSB->device = device;
-    // just get usb SN, close handle immediately
-    int childRet = OpenDeviceMyNeed(hUSB);
-    if (childRet < 0) {
-        WRITE_LOG(LOG_FATAL, "DetectMyNeed OpenDeviceMyNeed childRet:%d", childRet);
-        delete hUSB;
-        return false;
-    }
-    libusb_release_interface(hUSB->devHandle, hUSB->interfaceNumber);
-    libusb_close(hUSB->devHandle);
-    hUSB->devHandle = nullptr;
-
-    WRITE_LOG(LOG_INFO, "Needed device found, busid:%d devid:%d connectkey:%s", hUSB->busId, hUSB->devId,
-              Hdc::MaskString(hUSB->serialNumber).c_str());
-    // USB device is automatically connected after recognition, auto connect USB
-    UpdateUSBDaemonInfo(hUSB, nullptr, STATUS_READY);
-    HdcServer *hdcServer = (HdcServer *)clsMainBase;
-    HSession hSession = hdcServer->MallocSession(true, CONN_USB, this);
-    if (!hSession) {
-        WRITE_LOG(LOG_FATAL, "malloc usb session failed sn:%s", Hdc::MaskString(sn).c_str());
-        return false;
-    }
-    hSession->connectKey = hUSB->serialNumber;
-    uv_timer_t *waitTimeDoCmd = new(std::nothrow) uv_timer_t;
-    if (waitTimeDoCmd == nullptr) {
-        WRITE_LOG(LOG_FATAL, "DetectMyNeed new waitTimeDoCmd failed");
-        delete hUSB;
-        hdcServer->FreeSession(hSession->sessionId);
-        return false;
-    }
-    uv_timer_init(&hdcServer->loopMain, waitTimeDoCmd);
-    waitTimeDoCmd->data = hSession;
-    uv_timer_start(waitTimeDoCmd, hdcServer->UsbPreConnect, 0, DEVICE_CHECK_INTERVAL);
-    mapIgnoreDevice[sn] = HOST_USB_REGISTER;
-    delete hUSB;
-    return true;
-}
-
-void HdcHostUSB::KickoutZombie(HSession hSession)
-{
-    HdcServer *ptrConnect = (HdcServer *)hSession->classInstance;
-    HUSB hUSB = hSession->hUSB;
-    if (!hUSB->devHandle) {
-        WRITE_LOG(LOG_WARN, "KickoutZombie devHandle:%p isDead:%d", hUSB->devHandle, hSession->isDead);
-        return;
-    }
-    if (LIBUSB_ERROR_NO_DEVICE != libusb_kernel_driver_active(hUSB->devHandle, hUSB->interfaceNumber)) {
-        return;
-    }
-    WRITE_LOG(LOG_WARN, "KickoutZombie LIBUSB_ERROR_NO_DEVICE serialNumber:%s",
-              Hdc::MaskString(hUSB->serialNumber).c_str());
-    ptrConnect->FreeSession(hSession->sessionId);
-}
-
-void HdcHostUSB::RemoveIgnoreDevice(string &mountInfo)
-{
-    if (mapIgnoreDevice.count(mountInfo)) {
-        mapIgnoreDevice.erase(mountInfo);
-    }
-}
-
-void HdcHostUSB::ReviewUsbNodeLater(string &nodeKey)
-{
-    HdcServer *hdcServer = (HdcServer *)clsMainBase;
-    // add to ignore list
-    mapIgnoreDevice[nodeKey] = HOST_USB_IGNORE;
-    int delayRemoveFromList = DEVICE_CHECK_INTERVAL * MINOR_TIMEOUT;  // wait little time for daemon reinit
-    Base::DelayDo(&hdcServer->loopMain, delayRemoveFromList, 0, nodeKey, nullptr,
-                  [this](const uint8_t flag, string &msg, const void *) -> void { RemoveIgnoreDevice(msg); });
-}
-
-void HdcHostUSB::WatchUsbNodeChange(uv_timer_t *handle)
-{
-    HdcHostUSB *thisClass = static_cast<HdcHostUSB *>(handle->data);
-    HdcServer *ptrConnect = static_cast<HdcServer *>(thisClass->clsMainBase);
-    libusb_device **devs = nullptr;
-    libusb_device *dev = nullptr;
-    // kick zombie
-    ptrConnect->EnumUSBDeviceRegister(KickoutZombie);
-    // find new
-    ssize_t cnt = libusb_get_device_list(thisClass->ctxUSB, &devs);
-    if (cnt < 0) {
-        WRITE_LOG(LOG_FATAL, "Failed to get device list");
-        return;
-    }
-    int i = 0;
-    // linux replug devid increment，windows will be not
-    while ((dev = devs[i++]) != nullptr) {  // must postfix++
-        string szTmpKey = Base::StringFormat("%d-%d", libusb_get_bus_number(dev), libusb_get_device_address(dev));
-        // check is in ignore list
-        UsbCheckStatus statusCheck = thisClass->mapIgnoreDevice[szTmpKey];
-        if (statusCheck == HOST_USB_IGNORE || statusCheck == HOST_USB_REGISTER) {
-            continue;
-        }
-        string sn = szTmpKey;
-        if (thisClass->HasValidDevice(dev) && !thisClass->DetectMyNeed(dev, sn)) {
-            thisClass->ReviewUsbNodeLater(szTmpKey);
-        }
-    }
-    libusb_free_device_list(devs, 1);
-}
-
-bool HdcHostUSB::HasValidDevice(libusb_device *device)
-{
-    struct libusb_config_descriptor *descConfig = nullptr;
-    int ret = libusb_get_active_config_descriptor(device, &descConfig);
-    if (ret != 0) {
-        WRITE_LOG(LOG_WARN, "get active config des fail, errno is %d.", errno);
-        return false;
-    }
-    bool hasValid = false;
-    for (unsigned int j = 0; j < descConfig->bNumInterfaces; ++j) {
-        const struct libusb_interface *interface = &descConfig->interface[j];
-        if (interface->num_altsetting < 1) {
-            continue;
-        }
-        const struct libusb_interface_descriptor *ifDescriptor = &interface->altsetting[0];
-        if (!IsDebuggableDev(ifDescriptor)) {
-            continue;
-        }
-        hasValid = true;
-        break;
-    }
-    return hasValid;
-}
-
-// Main thread USB operates in this thread
-void HdcHostUSB::UsbWorkThread(void *arg)
-{
-    HdcHostUSB *thisClass = (HdcHostUSB *)arg;
-    constexpr uint8_t usbHandleTimeout = 30;  // second
-    while (thisClass->modRunning) {
-        struct timeval zerotime;
-        zerotime.tv_sec = usbHandleTimeout;
-        zerotime.tv_usec = 0;  // if == 0,windows will be high CPU load
-        libusb_handle_events_timeout(thisClass->ctxUSB, &zerotime);
-    }
-    WRITE_LOG(LOG_DEBUG, "Host Sessionbase usb workthread finish");
-}
-
-int HdcHostUSB::StartupUSBWork()
-{
-    // Because libusb(winusb backend) does not support hotplug under win32, we use list mode for all platforms
-    WRITE_LOG(LOG_DEBUG, "USBHost loopfind mode");
-    devListWatcher.data = this;
-    uv_timer_start(&devListWatcher, WatchUsbNodeChange, 0, DEVICE_CHECK_INTERVAL);
-    // Running pendding in independent threads does not significantly improve the efficiency
-    uv_thread_create(&threadUsbWork, UsbWorkThread, this);
-    return 0;
-}
-
-int HdcHostUSB::CheckDescriptor(HUSB hUSB, libusb_device_descriptor& desc)
-{
-    char serialNum[BUF_SIZE_MEDIUM] = "";
-    int childRet = 0;
-    uint8_t curBus = libusb_get_bus_number(hUSB->device);
-    uint8_t curDev = libusb_get_device_address(hUSB->device);
-    hUSB->busId = curBus;
-    hUSB->devId = curDev;
-    if (libusb_get_device_descriptor(hUSB->device, &desc)) {
-        WRITE_LOG(LOG_WARN, "CheckDescriptor libusb_get_device_descriptor failed %d-%d", curBus, curDev);
-        return -1;
-    }
-    // Get the serial number of the device, if there is no serial number, use the ID number to replace
-    // If the device is not in time, occasionally can't get it, this is determined by the external factor, cannot be
-    // changed. LIBUSB_SUCCESS
-    childRet = libusb_get_string_descriptor_ascii(hUSB->devHandle, desc.iSerialNumber, (uint8_t *)serialNum,
-                                                  sizeof(serialNum));
-    if (childRet < 0) {
-        WRITE_LOG(LOG_WARN, "CheckDescriptor libusb_get_string_descriptor_ascii failed %d-%d", curBus, curDev);
-        return -1;
-    } else {
-        hUSB->serialNumber = serialNum;
-    }
-    WRITE_LOG(LOG_DEBUG, "CheckDescriptor busId-devId:%d-%d serialNum:%s", curBus, curDev,
-              Hdc::MaskString(serialNum).c_str());
-    return 0;
-}
-
-// hSession can be null
-void HdcHostUSB::UpdateUSBDaemonInfo(HUSB hUSB, HSession hSession, uint8_t connStatus)
-{
-    // add to list
-    HdcServer *pServer = (HdcServer *)clsMainBase;
-    HdcDaemonInformation di;
-    di.connectKey = hUSB->serialNumber;
-    di.connType = CONN_USB;
-    di.connStatus = connStatus;
-    di.hSession = hSession;
-    di.usbMountPoint = "";
-    di.usbMountPoint = Base::StringFormat("%d-%d", hUSB->busId, hUSB->devId);
-
-    HDaemonInfo pDi = nullptr;
-    HDaemonInfo hdiNew = &di;
-    pServer->AdminDaemonMap(OP_QUERY, hUSB->serialNumber, pDi);
-    if (!pDi) {
-        pServer->AdminDaemonMap(OP_ADD, hUSB->serialNumber, hdiNew);
-    } else {
-        pServer->AdminDaemonMap(OP_UPDATE, hUSB->serialNumber, hdiNew);
-    }
-}
-
-bool HdcHostUSB::IsDebuggableDev(const struct libusb_interface_descriptor *ifDescriptor)
-{
-    constexpr uint8_t harmonyEpNum = 2;
-    constexpr uint8_t harmonyClass = 0xff;
-    constexpr uint8_t harmonySubClass = 0x50;
-    constexpr uint8_t harmonyProtocol = 0x01;
-
-    if (ifDescriptor->bInterfaceClass != harmonyClass || ifDescriptor->bInterfaceSubClass != harmonySubClass ||
-        ifDescriptor->bInterfaceProtocol != harmonyProtocol) {
-        return false;
-    }
-    if (ifDescriptor->bNumEndpoints != harmonyEpNum) {
-        return false;
-    }
-    return true;
-}
-
-int HdcHostUSB::CheckActiveConfig(libusb_device *device, HUSB hUSB, libusb_device_descriptor& desc)
-{
-    struct libusb_config_descriptor *descConfig = nullptr;
-    int ret = libusb_get_active_config_descriptor(device, &descConfig);
-    if (ret != 0) {
-#ifdef HOST_MAC
-        if ((desc.bDeviceClass == 0xFF)
-            && (desc.bDeviceSubClass == 0xFF)
-            && (desc.bDeviceProtocol == 0xFF)) {
-            ret = libusb_set_configuration(hUSB->devHandle, 1);
-            if (ret != 0) {
-                WRITE_LOG(LOG_WARN, "set config failed ret:%d", ret);
-                return -1;
-            }
-        }
-
-        ret = libusb_get_active_config_descriptor(device, &descConfig);
-        if (ret != 0) {
-#endif
-            WRITE_LOG(LOG_WARN, "get active config descriptor failed ret:%d", ret);
-            return -1;
-        }
-#ifdef HOST_MAC
-    }
-#endif
-
-    ret = -1;
-    CheckUsbEndpoint(ret, hUSB, descConfig);
-    libusb_free_config_descriptor(descConfig);
-    return ret;
-}
-
-void HdcHostUSB::CheckUsbEndpoint(int& ret, HUSB hUSB, libusb_config_descriptor *descConfig)
-{
-    unsigned int j = 0;
-    for (j = 0; j < descConfig->bNumInterfaces; ++j) {
-        const struct libusb_interface *interface = &descConfig->interface[j];
-        if (interface->num_altsetting < 1) {
-            WRITE_LOG(LOG_DEBUG, "interface->num_altsetting = 0, j = %d", j);
-            continue;
-        }
-        const struct libusb_interface_descriptor *ifDescriptor = &interface->altsetting[0];
-        if (!IsDebuggableDev(ifDescriptor)) {
-            WRITE_LOG(LOG_DEBUG, "IsDebuggableDev fail, j = %d", j);
-            continue;
-        }
-        WRITE_LOG(LOG_DEBUG, "CheckActiveConfig IsDebuggableDev passed and then check endpoint attr");
-        hUSB->interfaceNumber = ifDescriptor->bInterfaceNumber;
-        unsigned int k = 0;
-        for (k = 0; k < ifDescriptor->bNumEndpoints; ++k) {
-            const struct libusb_endpoint_descriptor *ep_desc = &ifDescriptor->endpoint[k];
-            if ((ep_desc->bmAttributes & 0x03) != LIBUSB_TRANSFER_TYPE_BULK) {
-                WRITE_LOG(LOG_DEBUG, "check ep_desc->bmAttributes fail, all %d k = %d, bmAttributes %d",
-                    ifDescriptor->bNumEndpoints, k, ep_desc->bmAttributes);
-                continue;
-            }
-            if (ep_desc->bEndpointAddress & LIBUSB_ENDPOINT_IN) {
-                hUSB->hostBulkIn.endpoint = ep_desc->bEndpointAddress;
-                hUSB->hostBulkIn.bulkInOut = true;
-            } else {
-                hUSB->hostBulkOut.endpoint = ep_desc->bEndpointAddress;
-                hUSB->wMaxPacketSizeSend = ep_desc->wMaxPacketSize;
-                hUSB->hostBulkOut.bulkInOut = false;
-            }
-        }
-        if (hUSB->hostBulkIn.endpoint == 0 || hUSB->hostBulkOut.endpoint == 0) {
-            WRITE_LOG(LOG_DEBUG, "hostBulkIn.endpoint %d hUSB->hostBulkOut.endpoint %d",
-                hUSB->hostBulkIn.endpoint, hUSB->hostBulkOut.endpoint);
-            break;
-        }
-        ret = 0;
-    }
-}
-
-// multi-thread calll
-void HdcHostUSB::CancelUsbIo(HSession hSession)
-{
-    WRITE_LOG(LOG_INFO, "HostUSB CancelUsbIo, sid:%u ref:%u", hSession->sessionId, uint32_t(hSession->ref));
-    HUSB hUSB = hSession->hUSB;
-    std::unique_lock<std::mutex> lock(hUSB->lockDeviceHandle);
-    if (!hUSB->hostBulkIn.isShutdown) {
-        if (!hUSB->hostBulkIn.isComplete) {
-            libusb_cancel_transfer(hUSB->hostBulkIn.transfer);
-            hUSB->hostBulkIn.cv.notify_one();
-        } else {
-            hUSB->hostBulkIn.isShutdown = true;
-        }
-    }
-    if (!hUSB->hostBulkOut.isShutdown) {
-        if (!hUSB->hostBulkOut.isComplete) {
-            libusb_cancel_transfer(hUSB->hostBulkOut.transfer);
-            hUSB->hostBulkOut.cv.notify_one();
-        } else {
-            hUSB->hostBulkOut.isShutdown = true;
-        }
-    }
-}
-
-// 3rd write child-hdc-workthread
-// no use uvwrite, raw write to socketpair's fd
-int HdcHostUSB::UsbToHdcProtocol(uv_stream_t *stream, uint8_t *appendData, int dataSize)
-{
-    HSession hSession = (HSession)stream->data;
-    unsigned int fd = hSession->dataFd[STREAM_MAIN];
-    int index = 0;
-    int childRet = 0;
-    int retryTimes = 0;
-    const int maxRetryTimes = 3;
-    const int oneSecond = 1;
-
-    while (index < dataSize) {
-        fd_set fdSet;
-        FD_ZERO(&fdSet);
-        FD_SET(fd, &fdSet);
-        struct timeval timeout = { 3, 0 };
-        childRet = select(fd + 1, nullptr, &fdSet, nullptr, &timeout);
-        if (childRet <= 0) {
-            hdc_strerrno(buf);
-            WRITE_LOG(LOG_FATAL, "select error:%d [%s][%d] retry times %d alread send %d bytes, total %d bytes",
-                errno, buf, childRet, retryTimes, index, dataSize);
-            Base::DispUvStreamInfo(stream, "hostusb select failed");
-            if (retryTimes >= maxRetryTimes) {
-                break;
-            }
-            retryTimes++;
-            sleep(oneSecond);
-            continue;
-        }
-        childRet = send(fd, reinterpret_cast<const char *>(appendData) + index, dataSize - index, 0);
-        if (childRet < 0) {
-            hdc_strerrno(buf);
-            WRITE_LOG(LOG_FATAL, "UsbToHdcProtocol senddata err:%d [%s]", errno, buf);
-            Base::DispUvStreamInfo(stream, "hostusb send failed");
-            break;
-        }
-        index += childRet;
-    }
-    hSession->stat.dataSendBytes += index;
-    if (index != dataSize) {
-        WRITE_LOG(LOG_FATAL, "UsbToHdcProtocol partialsenddata err:%d [%d]", index, dataSize);
-        return ERR_IO_FAIL;
-    }
-    return index;
-}
-
-void LIBUSB_CALL HdcHostUSB::USBBulkCallback(struct libusb_transfer *transfer)
-{
-    auto *ep = reinterpret_cast<HostUSBEndpoint *>(transfer->user_data);
-    std::unique_lock<std::mutex> lock(ep->mutexIo);
-    bool retrySumit = false;
-    int childRet = 0;
-    do {
-        if (transfer->status != LIBUSB_TRANSFER_COMPLETED) {
-            WRITE_LOG(LOG_FATAL, "USBBulkCallback1 failed, ret:%d", transfer->status);
-            break;
-        }
-        if (!ep->bulkInOut && transfer->actual_length != transfer->length) {
-            transfer->length -= transfer->actual_length;
-            transfer->buffer += transfer->actual_length;
-            retrySumit = true;
-            break;
-        }
-    } while (false);
-    while (retrySumit) {
-        childRet = libusb_submit_transfer(transfer);
-        if (childRet != 0) {
-            WRITE_LOG(LOG_FATAL, "USBBulkCallback2 failed, ret:%d", childRet);
-            transfer->status = LIBUSB_TRANSFER_ERROR;
-            break;
-        }
-        return;
-    }
-    ep->isComplete = true;
-    ep->cv.notify_one();
-}
-
-int HdcHostUSB::SubmitUsbBio(HSession hSession, bool sendOrRecv, uint8_t *buf, int bufSize)
-{
-    HUSB hUSB = hSession->hUSB;
-    int timeout = 0;
-    int childRet = 0;
-    int ret = ERR_IO_FAIL;
-    HostUSBEndpoint *ep = nullptr;
-
-    if (sendOrRecv) {
-        timeout = GLOBAL_TIMEOUT * TIME_BASE;
-        ep = &hUSB->hostBulkOut;
-    } else {
-        timeout = 0;  // infinity
-        ep = &hUSB->hostBulkIn;
-    }
-    hUSB->lockDeviceHandle.lock();
-    ep->isComplete = false;
-    do {
-        std::unique_lock<std::mutex> lock(ep->mutexIo);
-        libusb_fill_bulk_transfer(ep->transfer, hUSB->devHandle, ep->endpoint, buf, bufSize, USBBulkCallback, ep,
-                                  timeout);
-        childRet = libusb_submit_transfer(ep->transfer);
-        hUSB->lockDeviceHandle.unlock();
-        if (childRet < 0) {
-            WRITE_LOG(LOG_FATAL, "SubmitUsbBio libusb_submit_transfer failed, sid:%u ret:%d",
-                hSession->sessionId, childRet);
-            break;
-        }
-        ep->cv.wait(lock, [ep]() { return ep->isComplete; });
-        if (ep->transfer->status != 0) {
-            WRITE_LOG(LOG_FATAL, "SubmitUsbBio transfer failed, sid:%u status:%d",
-                hSession->sessionId, ep->transfer->status);
-            break;
-        }
-        ret = ep->transfer->actual_length;
-    } while (false);
-    return ret;
-}
-
-void HdcHostUSB::BeginUsbRead(HSession hSession)
-{
-    HUSB hUSB = hSession->hUSB;
-    hUSB->hostBulkIn.isShutdown = false;
-    hUSB->hostBulkOut.isShutdown = false;
-    ++hSession->ref;
-    // loop read
-    std::thread([this, hSession, hUSB]() {
-        int childRet = 0;
-        int nextReadSize = 0;
-        int bulkInSize = hUSB->hostBulkIn.sizeEpBuf;
-        while (!hSession->isDead) {
-            // if readIO < wMaxPacketSizeSend, libusb report overflow
-            nextReadSize = (childRet < hUSB->wMaxPacketSizeSend ?
-                                       hUSB->wMaxPacketSizeSend : std::min(childRet, bulkInSize));
-            childRet = SubmitUsbBio(hSession, false, hUSB->hostBulkIn.buf, nextReadSize);
-            if (childRet < 0) {
-                WRITE_LOG(LOG_FATAL, "Read usb failed, sid:%u ret:%d", hSession->sessionId, childRet);
-                break;
-            }
-
-            // when a session is set up for a period of time, the read data is discarded to empty the USB channel.
-            if (hSession->isNeedDropData) {
-                hSession->dropBytes += childRet;
-                childRet = 0;
-                continue;
-            }
-            if (childRet == 0) {
-                WRITE_LOG(LOG_WARN, "Read usb return 0, continue read, sid:%u", hSession->sessionId);
-                childRet = nextReadSize;
-                continue;
-            }
-            childRet = SendToHdcStream(hSession, reinterpret_cast<uv_stream_t *>(&hSession->dataPipe[STREAM_MAIN]),
-                                       hUSB->hostBulkIn.buf, childRet);
-            if (childRet < 0) {
-                WRITE_LOG(LOG_FATAL, "SendToHdcStream failed, sid:%u ret:%d", hSession->sessionId, childRet);
-                break;
-            }
-        }
-        --hSession->ref;
-        auto server = reinterpret_cast<HdcServer *>(clsMainBase);
-        hUSB->hostBulkIn.isShutdown = true;
-        server->FreeSession(hSession->sessionId);
-        RemoveIgnoreDevice(hUSB->usbMountPoint);
-        WRITE_LOG(LOG_INFO, "Usb loop read finish sid:%u", hSession->sessionId);
-    }).detach();
-}
-
-// ==0 Represents new equipment and is what we need,<0  my need
-int HdcHostUSB::OpenDeviceMyNeed(HUSB hUSB)
-{
-    libusb_device *device = hUSB->device;
-    int ret = -1;
-    int OpenRet = libusb_open(device, &hUSB->devHandle);
-    if (OpenRet != LIBUSB_SUCCESS) {
-        WRITE_LOG(LOG_DEBUG, "libusb_open fail xret %d", OpenRet);
-        return ERR_LIBUSB_OPEN;
-    }
-    while (modRunning) {
-        libusb_device_handle *handle = hUSB->devHandle;
-        struct libusb_device_descriptor desc;
-        if (CheckDescriptor(hUSB, desc)) {
-            break;
-        }
-        if (CheckActiveConfig(device, hUSB, desc)) {
-            break;
-        }
-        // USB filter rules are set according to specific device pedding device
-        ret = libusb_claim_interface(handle, hUSB->interfaceNumber);
-        WRITE_LOG(LOG_DEBUG, "libusb_claim_interface ret %d, interfaceNumber %d",
-            ret, hUSB->interfaceNumber);
-        break;
-    }
-    if (ret) {
-        // not my need device, release the device
-        libusb_close(hUSB->devHandle);
-        hUSB->devHandle = nullptr;
-    }
-    return ret;
-}
-
-int HdcHostUSB::SendUSBRaw(HSession hSession, uint8_t *data, const int length)
-{
-    int ret = ERR_GENERIC;
-    HdcSessionBase *server = reinterpret_cast<HdcSessionBase *>(hSession->classInstance);
-    ++hSession->ref;
-    ret = SubmitUsbBio(hSession, true, data, length);
-    if (ret < 0) {
-        WRITE_LOG(LOG_FATAL, "Send usb failed, sid:%u ret:%d", hSession->sessionId, ret);
-        CancelUsbIo(hSession);
-        hSession->hUSB->hostBulkOut.isShutdown = true;
-        server->FreeSession(hSession->sessionId);
-    }
-    --hSession->ref;
-    return ret;
-}
-
-bool HdcHostUSB::FindDeviceByID(HUSB hUSB, const char *usbMountPoint, libusb_context *ctxUSB)
-{
-    libusb_device **listDevices = nullptr;
-    bool ret = false;
-    char tmpStr[BUF_SIZE_TINY] = "";
-    int busNum = 0;
-    int devNum = 0;
-    int curBus = 0;
-    int curDev = 0;
-
-    int device_num = libusb_get_device_list(ctxUSB, &listDevices);
-    WRITE_LOG(LOG_DEBUG, "device_num:%d", device_num);
-    if (device_num <= 0) {
-        libusb_free_device_list(listDevices, 1);
-        return false;
-    }
-    WRITE_LOG(LOG_DEBUG, "usbMountPoint:%s", usbMountPoint);
-    if (strchr(usbMountPoint, '-') && EOK == strcpy_s(tmpStr, sizeof(tmpStr), usbMountPoint)) {
-        *strchr(tmpStr, '-') = '\0';
-        busNum = atoi(tmpStr);
-        devNum = atoi(tmpStr + strlen(tmpStr) + 1);
-    } else {
-        return false;
-    }
-    WRITE_LOG(LOG_DEBUG, "busNum:%d devNum:%d", busNum, devNum);
-
-    int i = 0;
-    for (i = 0; i < device_num; ++i) {
-        struct libusb_device_descriptor desc;
-        if (LIBUSB_SUCCESS != libusb_get_device_descriptor(listDevices[i], &desc)) {
-            WRITE_LOG(LOG_DEBUG, "libusb_get_device_descriptor failed i:%d", i);
-            continue;
-        }
-        curBus = libusb_get_bus_number(listDevices[i]);
-        curDev = libusb_get_device_address(listDevices[i]);
-        WRITE_LOG(LOG_DEBUG, "curBus:%d curDev:%d", curBus, curDev);
-        if ((curBus == busNum && curDev == devNum)) {
-            hUSB->device = listDevices[i];
-            int childRet = OpenDeviceMyNeed(hUSB);
-            WRITE_LOG(LOG_DEBUG, "OpenDeviceMyNeed childRet:%d", childRet);
-            if (!childRet) {
-                ret = true;
-            } else {
-                string key = string(usbMountPoint);
-                RemoveIgnoreDevice(key);
-            }
-            break;
-        }
-    }
-    libusb_free_device_list(listDevices, 1);
-    return ret;
-}
-
-bool HdcHostUSB::ReadyForWorkThread(HSession hSession)
-{
-    HdcUSBBase::ReadyForWorkThread(hSession);
-    return true;
-};
-
-// Determines that daemonInfo must have the device
-HSession HdcHostUSB::ConnectDetectDaemon(const HSession hSession, const HDaemonInfo pdi)
-{
-    HdcServer *pServer = (HdcServer *)clsMainBase;
-    HUSB hUSB = hSession->hUSB;
-    hUSB->usbMountPoint = pdi->usbMountPoint;
-    hUSB->ctxUSB = ctxUSB;
-    if (!FindDeviceByID(hUSB, hUSB->usbMountPoint.c_str(), hUSB->ctxUSB)) {
-        pServer->FreeSession(hSession->sessionId);
-        RemoveIgnoreDevice(hUSB->usbMountPoint);
-        WRITE_LOG(LOG_WARN, "FindDeviceByID fail");
-        return nullptr;
-    }
-    UpdateUSBDaemonInfo(hUSB, hSession, STATUS_CONNECTED);
-    hSession->isNeedDropData = true;
-    hSession->dropBytes = 0;
-    WRITE_LOG(LOG_INFO, "ConnectDetectDaemon set isNeedDropData true, sid:%u", hSession->sessionId);
-    BeginUsbRead(hSession);
-    hUSB->usbMountPoint = pdi->usbMountPoint;
-    WRITE_LOG(LOG_DEBUG, "HSession HdcHostUSB::ConnectDaemon, sid:%u", hSession->sessionId);
-
-    Base::StartWorkThread(&pServer->loopMain, pServer->SessionWorkThread, Base::FinishWorkThread, hSession);
-    // wait for thread up
-    while (hSession->childLoop.active_handles == 0) {
-        uv_sleep(1);
-    }
-
-    auto funcDelayStartSessionNotify = [hSession](const uint8_t flag, string &msg, const void *p) -> void {
-        HdcServer *pServer = (HdcServer *)hSession->classInstance;
-        auto ctrl = pServer->BuildCtrlString(SP_START_SESSION, 0, nullptr, 0);
-        hSession->isNeedDropData = false;
-        WRITE_LOG(LOG_INFO, "funcDelayStartSessionNotify set isNeedDropData false, sid:%u drop %llu bytes data",
-            hSession->sessionId, uint64_t(hSession->dropBytes));
-        Base::SendToPollFd(hSession->ctrlFd[STREAM_MAIN], ctrl.data(), ctrl.size());
-    };
-
-    // delay NEW_SESSION_DROP_USB_DATA_TIME_MS to start session
-    SendSoftResetToDaemon(hSession, 0);
-    Base::DelayDoSimple(&(pServer->loopMain), NEW_SESSION_DROP_USB_DATA_TIME_MS, funcDelayStartSessionNotify);
-    return hSession;
-}
-
-void HdcHostUSB::SendSoftResetToDaemon(HSession hSession, uint32_t sessionIdOld)
-{
-    HUSB hUSB = hSession->hUSB;
-    hUSB->lockSendUsbBlock.lock();
-    WRITE_LOG(LOG_INFO, "SendSoftResetToDaemon sid:%u sidOld:%u", hSession->sessionId, sessionIdOld);
-    auto header = BuildPacketHeader(sessionIdOld, USB_OPTION_RESET, 0);
-    if (SendUSBRaw(hSession, header.data(), header.size()) <= 0) {
-        WRITE_LOG(LOG_FATAL, "SendSoftResetToDaemon send failed");
-    }
-    hUSB->lockSendUsbBlock.unlock();
-    WRITE_LOG(LOG_INFO, "SendSoftResetToDaemon sid:%u finished", hSession->sessionId);
-}
-}  // namespace Hdc
diff --git a/hdc/src/host/host_usb.h b/hdc/src/host/host_usb.h
deleted file mode 100644
index fb836d9..0000000
--- a/hdc/src/host/host_usb.h
+++ /dev/null
@@ -1,70 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_HOST_USB_H
-#define HDC_HOST_USB_H
-#include "host_common.h"
-
-namespace Hdc {
-class HdcHostUSB : public HdcUSBBase {
-public:
-    HdcHostUSB(const bool serverOrDaemonIn, void *ptrMainBase, void *ctxUSBin);
-    virtual ~HdcHostUSB();
-    int Initial();
-    void InitLogging(void *ctxUSB);
-    int SendUSBRaw(HSession hSession, uint8_t *data, const int length) override;
-    HSession ConnectDetectDaemon(const HSession hSession, const HDaemonInfo pdi);
-    void Stop();
-    void RemoveIgnoreDevice(string &mountInfo);
-
-private:
-    enum UsbCheckStatus {
-        HOST_USB_IGNORE = 1,
-        HOST_USB_READY,
-        HOST_USB_REGISTER,
-    };
-    static int LIBUSB_CALL HotplugHostUSBCallback(libusb_context *ctx, libusb_device *device,
-                                                  libusb_hotplug_event event, void *userData);
-    static void UsbWorkThread(void *arg);  // 3rd thread
-    static void WatchUsbNodeChange(uv_timer_t *handle);
-    static void KickoutZombie(HSession hSession);
-    static void LIBUSB_CALL USBBulkCallback(struct libusb_transfer *transfer);
-    int StartupUSBWork();
-    void CheckUsbEndpoint(int& ret, HUSB hUSB, libusb_config_descriptor *descConfig);
-    int CheckActiveConfig(libusb_device *device, HUSB hUSB, libusb_device_descriptor& desc);
-    int OpenDeviceMyNeed(HUSB hUSB);
-    bool HasValidDevice(libusb_device *device);
-    int CheckDescriptor(HUSB hUSB, libusb_device_descriptor& desc);
-    bool IsDebuggableDev(const struct libusb_interface_descriptor *ifDescriptor);
-    bool ReadyForWorkThread(HSession hSession) override;
-    bool FindDeviceByID(HUSB hUSB, const char *usbMountPoint, libusb_context *ctxUSB);
-    bool DetectMyNeed(libusb_device *device, string &sn);
-    void RestoreHdcProtocol(HUSB hUsb, const uint8_t *buf, int bufSize);
-    void UpdateUSBDaemonInfo(HUSB hUSB, HSession hSession, uint8_t connStatus);
-    void BeginUsbRead(HSession hSession);
-    void ReviewUsbNodeLater(string &nodeKey);
-    void CancelUsbIo(HSession hSession) override;
-    int UsbToHdcProtocol(uv_stream_t *stream, uint8_t *appendData, int dataSize) override;
-    int SubmitUsbBio(HSession hSession, bool sendOrRecv, uint8_t *buf, int bufSize);
-    void SendSoftResetToDaemon(HSession hSession, uint32_t sessionIdOld);
-
-    libusb_context *ctxUSB;
-    uv_timer_t devListWatcher;
-    map<string, UsbCheckStatus> mapIgnoreDevice;
-
-private:
-    uv_thread_t threadUsbWork;
-};
-}  // namespace Hdc
-#endif
diff --git a/hdc/src/host/main.cpp b/src/host/main.cpp
index de4679c..7d70c1b 100644
--- a/hdc/src/host/main.cpp
+++ b/src/host/main.cpp
@@ -73,14 +73,14 @@ int IsRegisterCommand(string &outCommand, const char *cmd, const char *cmdnext)
     registerCommand.push_back(CMDSTR_STARTUP_MODE);
     registerCommand.push_back(CMDSTR_BUGREPORT);
     registerCommand.push_back(CMDSTR_TARGET_MODE);
-    registerCommand.push_back(CMDSTR_APP_SIDELOAD);
+    // registerCommand.push_back(CMDSTR_APP_SIDELOAD);
     registerCommand.push_back(CMDSTR_TARGET_REBOOT);
     registerCommand.push_back(CMDSTR_LIST_JDWP);
     registerCommand.push_back(CMDSTR_TRACK_JDWP);
-    registerCommand.push_back(CMDSTR_FLASHD_UPDATE);
-    registerCommand.push_back(CMDSTR_FLASHD_FLASH);
-    registerCommand.push_back(CMDSTR_FLASHD_ERASE);
-    registerCommand.push_back(CMDSTR_FLASHD_FORMAT);
+    // registerCommand.push_back(CMDSTR_FLASHD_UPDATE);
+    // registerCommand.push_back(CMDSTR_FLASHD_FLASH);
+    // registerCommand.push_back(CMDSTR_FLASHD_ERASE);
+    // registerCommand.push_back(CMDSTR_FLASHD_FORMAT);
 
     for (string v : registerCommand) {
         if (doubleCommand == v) {
@@ -97,8 +97,7 @@ int IsRegisterCommand(string &outCommand, const char *cmd, const char *cmdnext)
 
 void AppendCwdWhenTransfer(string &outCommand)
 {
-    if (outCommand != CMDSTR_FILE_SEND && outCommand != CMDSTR_FILE_RECV && outCommand != CMDSTR_APP_INSTALL &&
-        outCommand != CMDSTR_APP_SIDELOAD) {
+    if (outCommand != CMDSTR_FILE_SEND && outCommand != CMDSTR_FILE_RECV && outCommand != CMDSTR_APP_INSTALL) {
         return;
     }
     int value = -1;
diff --git a/hdc/src/host/server.cpp b/src/host/server.cpp
index dcae3a6..6928738 100644
--- a/hdc/src/host/server.cpp
+++ b/src/host/server.cpp
@@ -13,7 +13,7 @@
  * limitations under the License.
  */
 #include "server.h"
-#include "host_updater.h"
+// #include "host_updater.h"
 
 
 namespace Hdc {
@@ -21,10 +21,10 @@ HdcServer::HdcServer(bool serverOrDaemonIn)
     : HdcSessionBase(serverOrDaemonIn)
 {
     clsTCPClt = nullptr;
-    clsUSBClt = nullptr;
-#ifdef HDC_SUPPORT_UART
-    clsUARTClt = nullptr;
-#endif
+    // clsUSBClt = nullptr;
+// #ifdef HDC_SUPPORT_UART
+//     clsUARTClt = nullptr;
+// #endif
     clsServerForClient = nullptr;
     uv_rwlock_init(&daemonAdmin);
     uv_rwlock_init(&forwardAdmin);
@@ -44,14 +44,14 @@ void HdcServer::ClearInstanceResource()
     if (clsTCPClt) {
         delete clsTCPClt;
     }
-    if (clsUSBClt) {
-        delete clsUSBClt;
-    }
-#ifdef HDC_SUPPORT_UART
-    if (clsUARTClt) {
-        delete clsUARTClt;
-    }
-#endif
+    // if (clsUSBClt) {
+    //     delete clsUSBClt;
+    // }
+// #ifdef HDC_SUPPORT_UART
+//     if (clsUARTClt) {
+//         delete clsUARTClt;
+//     }
+// #endif
     if (clsServerForClient) {
         delete (static_cast<HdcServerForClient *>(clsServerForClient));
     }
@@ -63,14 +63,14 @@ void HdcServer::TryStopInstance()
     if (clsTCPClt) {
         clsTCPClt->Stop();
     }
-    if (clsUSBClt) {
-        clsUSBClt->Stop();
-    }
-#ifdef HDC_SUPPORT_UART
-    if (clsUARTClt) {
-        clsUARTClt->Stop();
-    }
-#endif
+    // if (clsUSBClt) {
+    //     clsUSBClt->Stop();
+    // }
+// #ifdef HDC_SUPPORT_UART
+//     if (clsUARTClt) {
+//         clsUARTClt->Stop();
+//     }
+// #endif
     if (clsServerForClient) {
         ((HdcServerForClient *)clsServerForClient)->Stop();
     }
@@ -91,29 +91,29 @@ bool HdcServer::Initial(const char *listenString)
         WRITE_LOG(LOG_FATAL, "clsServerForClient Initial failed");
         return false;
     }
-    clsUSBClt->InitLogging(ctxUSB);
+    // clsUSBClt->InitLogging(ctxUSB);
     clsTCPClt = new HdcHostTCP(true, this);
-    clsUSBClt = new HdcHostUSB(true, this, ctxUSB);
-    if (clsUSBClt->Initial() != RET_SUCCESS) {
-        WRITE_LOG(LOG_FATAL, "clsUSBClt Initial failed");
-        return false;
-    }
-    if (!clsServerForClient || !clsTCPClt || !clsUSBClt) {
+    // clsUSBClt = new HdcHostUSB(true, this, ctxUSB);
+    // if (clsUSBClt->Initial() != RET_SUCCESS) {
+    //     WRITE_LOG(LOG_FATAL, "clsUSBClt Initial failed");
+    //     return false;
+    // }
+    if (!clsServerForClient || !clsTCPClt) {
         WRITE_LOG(LOG_FATAL, "Class init failed");
         return false;
     }
 
-#ifdef HDC_SUPPORT_UART
-    clsUARTClt = new HdcHostUART(*this);
-    if (!clsUARTClt) {
-        WRITE_LOG(LOG_FATAL, "Class init failed");
-        return false;
-    }
-    if (clsUARTClt->Initial() != RET_SUCCESS) {
-        WRITE_LOG(LOG_FATAL, "clsUARTClt Class init failed.");
-        return false;
-    }
-#endif
+// #ifdef HDC_SUPPORT_UART
+//     clsUARTClt = new HdcHostUART(*this);
+//     if (!clsUARTClt) {
+//         WRITE_LOG(LOG_FATAL, "Class init failed");
+//         return false;
+//     }
+//     if (clsUARTClt->Initial() != RET_SUCCESS) {
+//         WRITE_LOG(LOG_FATAL, "clsUARTClt Class init failed.");
+//         return false;
+//     }
+// #endif
     return true;
 }
 
@@ -405,20 +405,20 @@ void HdcServer::NotifyInstanceSessionFree(HSession hSession, bool freeOrClear)
         HDaemonInfo hdiNew = &diNew;
         AdminDaemonMap(OP_UPDATE, hSession->connectKey, hdiNew);
         CleanForwardMap(hSession->sessionId);
-    } else {  // step2
-        string usbMountPoint = hdiOld->usbMountPoint;
-        // The waiting time must be longer than DEVICE_CHECK_INTERVAL. Wait the method WatchUsbNodeChange
-        // to finish execution. Otherwise, the main thread and the session worker thread will conflict
-        constexpr int waitDaemonReconnect = DEVICE_CHECK_INTERVAL + DEVICE_CHECK_INTERVAL;
-        auto funcDelayUsbNotify = [this, usbMountPoint](const uint8_t flag, string &msg, const void *) -> void {
-            string s = usbMountPoint;
-            clsUSBClt->RemoveIgnoreDevice(s);
-        };
-        if (usbMountPoint.size() > 0) {
-            // wait time for daemon reconnect
-            // If removed from maplist, the USB module will be reconnected, so it needs to wait for a while
-            Base::DelayDoSimple(&loopMain, waitDaemonReconnect, funcDelayUsbNotify);
-        }
+    // } else {  // step2
+    //     string usbMountPoint = hdiOld->usbMountPoint;
+    //     // The waiting time must be longer than DEVICE_CHECK_INTERVAL. Wait the method WatchUsbNodeChange
+    //     // to finish execution. Otherwise, the main thread and the session worker thread will conflict
+    //     constexpr int waitDaemonReconnect = DEVICE_CHECK_INTERVAL + DEVICE_CHECK_INTERVAL;
+    //     auto funcDelayUsbNotify = [this, usbMountPoint](const uint8_t flag, string &msg, const void *) -> void {
+    //         string s = usbMountPoint;
+    //         clsUSBClt->RemoveIgnoreDevice(s);
+    //     };
+    //     if (usbMountPoint.size() > 0) {
+    //         // wait time for daemon reconnect
+    //         // If removed from maplist, the USB module will be reconnected, so it needs to wait for a while
+    //         Base::DelayDoSimple(&loopMain, waitDaemonReconnect, funcDelayUsbNotify);
+    //     }
     }
 }
 
@@ -740,80 +740,80 @@ void HdcServer::CleanForwardMap(uint32_t sessionId)
     uv_rwlock_rdunlock(&forwardAdmin);
 }
 
-void HdcServer::UsbPreConnect(uv_timer_t *handle)
-{
-    HSession hSession = (HSession)handle->data;
-    bool stopLoop = false;
-    HdcServer *hdcServer = (HdcServer *)hSession->classInstance;
-    while (true) {
-        WRITE_LOG(LOG_DEBUG, "HdcServer::UsbPreConnect");
-        HDaemonInfo pDi = nullptr;
-        if (hSession->connectKey == "any") {
-            hdcServer->AdminDaemonMap(OP_GET_ANY, hSession->connectKey, pDi);
-        } else {
-            hdcServer->AdminDaemonMap(OP_QUERY, hSession->connectKey, pDi);
-        }
-        if (!pDi || !pDi->usbMountPoint.size()) {
-            break;
-        }
-        HdcHostUSB *hdcHostUSB = (HdcHostUSB *)hSession->classModule;
-        hdcHostUSB->ConnectDetectDaemon(hSession, pDi);
-        stopLoop = true;
-        break;
-    }
-    if (stopLoop && !uv_is_closing((const uv_handle_t *)handle)) {
-        uv_close((uv_handle_t *)handle, Base::CloseTimerCallback);
-    }
-}
-#ifdef HDC_SUPPORT_UART
-void HdcServer::UartPreConnect(uv_timer_t *handle)
-{
-    WRITE_LOG(LOG_DEBUG, "%s", __FUNCTION__);
-    HSession hSession = (HSession)handle->data;
-    bool stopLoop = false;
-    HdcServer *hdcServer = (HdcServer *)hSession->classInstance;
-    const int uartConnectRetryMax = 100; // max 6s
-    while (true) {
-        if (hSession->hUART->retryCount > uartConnectRetryMax) {
-            WRITE_LOG(LOG_DEBUG, "%s failed because max retry limit %d", __FUNCTION__,
-                      hSession->hUART->retryCount);
-            hdcServer->FreeSession(hSession->sessionId);
-            stopLoop = true;
-            break;
-        }
-        hSession->hUART->retryCount++;
-        HDaemonInfo pDi = nullptr;
+// void HdcServer::UsbPreConnect(uv_timer_t *handle)
+// {
+//     // HSession hSession = (HSession)handle->data;
+//     // bool stopLoop = false;
+//     // HdcServer *hdcServer = (HdcServer *)hSession->classInstance;
+//     // while (true) {
+//     //     WRITE_LOG(LOG_DEBUG, "HdcServer::UsbPreConnect");
+//     //     HDaemonInfo pDi = nullptr;
+//     //     if (hSession->connectKey == "any") {
+//     //         hdcServer->AdminDaemonMap(OP_GET_ANY, hSession->connectKey, pDi);
+//     //     } else {
+//     //         hdcServer->AdminDaemonMap(OP_QUERY, hSession->connectKey, pDi);
+//     //     }
+//     //     if (!pDi || !pDi->usbMountPoint.size()) {
+//     //         break;
+//     //     }
+//     //     HdcHostUSB *hdcHostUSB = (HdcHostUSB *)hSession->classModule;
+//     //     hdcHostUSB->ConnectDetectDaemon(hSession, pDi);
+//     //     stopLoop = true;
+//     //     break;
+//     // }
+//     // if (stopLoop && !uv_is_closing((const uv_handle_t *)handle)) {
+//     //     uv_close((uv_handle_t *)handle, Base::CloseTimerCallback);
+//     // }
+// }
+// #ifdef HDC_SUPPORT_UART
+// void HdcServer::UartPreConnect(uv_timer_t *handle)
+// {
+//     WRITE_LOG(LOG_DEBUG, "%s", __FUNCTION__);
+//     HSession hSession = (HSession)handle->data;
+//     bool stopLoop = false;
+//     HdcServer *hdcServer = (HdcServer *)hSession->classInstance;
+//     const int uartConnectRetryMax = 100; // max 6s
+//     while (true) {
+//         if (hSession->hUART->retryCount > uartConnectRetryMax) {
+//             WRITE_LOG(LOG_DEBUG, "%s failed because max retry limit %d", __FUNCTION__,
+//                       hSession->hUART->retryCount);
+//             hdcServer->FreeSession(hSession->sessionId);
+//             stopLoop = true;
+//             break;
+//         }
+//         hSession->hUART->retryCount++;
+//         HDaemonInfo pDi = nullptr;
 
-        WRITE_LOG(LOG_DEBUG, "%s query %s", __FUNCTION__, hSession->ToDebugString().c_str());
-        hdcServer->AdminDaemonMap(OP_QUERY, hSession->connectKey, pDi);
-        if (!pDi) {
-            WRITE_LOG(LOG_DEBUG, "%s not found", __FUNCTION__);
-            break;
-        }
-        HdcHostUART *hdcHostUART = (HdcHostUART *)hSession->classModule;
-        hdcHostUART->ConnectDaemonByUart(hSession, pDi);
-        WRITE_LOG(LOG_DEBUG, "%s ConnectDaemonByUart done", __FUNCTION__);
+//         WRITE_LOG(LOG_DEBUG, "%s query %s", __FUNCTION__, hSession->ToDebugString().c_str());
+//         hdcServer->AdminDaemonMap(OP_QUERY, hSession->connectKey, pDi);
+//         if (!pDi) {
+//             WRITE_LOG(LOG_DEBUG, "%s not found", __FUNCTION__);
+//             break;
+//         }
+//         HdcHostUART *hdcHostUART = (HdcHostUART *)hSession->classModule;
+//         hdcHostUART->ConnectDaemonByUart(hSession, pDi);
+//         WRITE_LOG(LOG_DEBUG, "%s ConnectDaemonByUart done", __FUNCTION__);
 
-        stopLoop = true;
-        break;
-    }
-    if (stopLoop) {
-        uv_close((uv_handle_t *)handle, Base::CloseTimerCallback);
-    }
-}
+//         stopLoop = true;
+//         break;
+//     }
+//     if (stopLoop) {
+//         uv_close((uv_handle_t *)handle, Base::CloseTimerCallback);
+//     }
+// }
 
-void HdcServer::CreatConnectUart(HSession hSession)
-{
-    uv_timer_t *waitTimeDoCmd = new(std::nothrow) uv_timer_t;
-    if (waitTimeDoCmd == nullptr) {
-        WRITE_LOG(LOG_FATAL, "CreatConnectUart new waitTimeDoCmd failed");
-        return;
-    }
-    uv_timer_init(&loopMain, waitTimeDoCmd);
-    waitTimeDoCmd->data = hSession;
-    uv_timer_start(waitTimeDoCmd, UartPreConnect, UV_TIMEOUT, UV_REPEAT);
-}
-#endif
+// void HdcServer::CreatConnectUart(HSession hSession)
+// {
+//     uv_timer_t *waitTimeDoCmd = new(std::nothrow) uv_timer_t;
+//     if (waitTimeDoCmd == nullptr) {
+//         WRITE_LOG(LOG_FATAL, "CreatConnectUart new waitTimeDoCmd failed");
+//         return;
+//     }
+//     uv_timer_init(&loopMain, waitTimeDoCmd);
+//     waitTimeDoCmd->data = hSession;
+//     uv_timer_start(waitTimeDoCmd, UartPreConnect, UV_TIMEOUT, UV_REPEAT);
+// }
+// #endif
 // -1,has old,-2 error
 int HdcServer::CreateConnect(const string &connectKey, bool isCheck)
 {
@@ -821,15 +821,16 @@ int HdcServer::CreateConnect(const string &connectKey, bool isCheck)
     if (connectKey.find(":") != std::string::npos) { // TCP
         connType = CONN_TCP;
     }
-#ifdef HDC_SUPPORT_UART
-    else if (connectKey.find("COM") == 0 ||
-             connectKey.find("/dev/ttyUSB") == 0 ||
-             connectKey.find("/dev/cu.") == 0) { // UART
-        connType = CONN_SERIAL;
-    }
-#endif
+// #ifdef HDC_SUPPORT_UART
+//     else if (connectKey.find("COM") == 0 ||
+//              connectKey.find("/dev/ttyUSB") == 0 ||
+//              connectKey.find("/dev/cu.") == 0) { // UART
+//         connType = CONN_SERIAL;
+//     }
+// #endif
     else { // USB
-        connType = CONN_USB;
+        WRITE_LOG(LOG_WARN, "USB connection is not supported in this streamlined build.");
+        return ERR_NO_SUPPORT;
     }
     HDaemonInfo hdi = nullptr;
     if (connectKey == "any") {
@@ -852,31 +853,38 @@ int HdcServer::CreateConnect(const string &connectKey, bool isCheck)
     HSession hSession = nullptr;
     if (connType == CONN_TCP) {
         hSession = clsTCPClt->ConnectDaemon(connectKey, isCheck);
-    } else if (connType == CONN_SERIAL) {
-#ifdef HDC_SUPPORT_UART
-        clsUARTClt->SetCheckFlag(isCheck);
-        hSession = clsUARTClt->ConnectDaemon(connectKey);
-#endif
-    } else {
-        hSession = MallocSession(true, CONN_USB, clsUSBClt);
-        if (!hSession) {
-            WRITE_LOG(LOG_FATAL, "CreateConnect malloc usb session failed %s", Hdc::MaskString(connectKey).c_str());
-            return ERR_BUF_ALLOC;
-        }
-        hSession->connectKey = connectKey;
-        uv_timer_t *waitTimeDoCmd = new(std::nothrow) uv_timer_t;
-        if (waitTimeDoCmd == nullptr) {
-            WRITE_LOG(LOG_FATAL, "CreateConnect new waitTimeDoCmd failed");
-            FreeSession(hSession->sessionId);
-            return ERR_GENERIC;
-        }
-        uv_timer_init(&loopMain, waitTimeDoCmd);
-        waitTimeDoCmd->data = hSession;
-        uv_timer_start(waitTimeDoCmd, UsbPreConnect, UV_TIMEOUT, UV_REPEAT);
-    }
-    if (!hSession) {
+    }// else if (connType == CONN_SERIAL) {
+// #ifdef HDC_SUPPORT_UART
+//         clsUARTClt->SetCheckFlag(isCheck);
+//         hSession = clsUARTClt->ConnectDaemon(connectKey);
+// #endif
+//     }
+    // } else {
+    //     hSession = MallocSession(true, CONN_USB, clsUSBClt);
+    //     if (!hSession) {
+    //         WRITE_LOG(LOG_FATAL, "CreateConnect malloc usb session failed %s", Hdc::MaskString(connectKey).c_str());
+    //         return ERR_BUF_ALLOC;
+    //     }
+    //     hSession->connectKey = connectKey;
+    //     uv_timer_t *waitTimeDoCmd = new(std::nothrow) uv_timer_t;
+    //     if (waitTimeDoCmd == nullptr) {
+    //         WRITE_LOG(LOG_FATAL, "CreateConnect new waitTimeDoCmd failed");
+    //         FreeSession(hSession->sessionId);
+    //         return ERR_GENERIC;
+    //     }
+    //     uv_timer_init(&loopMain, waitTimeDoCmd);
+    //     waitTimeDoCmd->data = hSession;
+    //     uv_timer_start(waitTimeDoCmd, UsbPreConnect, UV_TIMEOUT, UV_REPEAT);
+    // }
+    // if (!hSession) {
+    //     WRITE_LOG(LOG_FATAL, "CreateConnect hSession nullptr");
+    //     return ERR_BUF_ALLOC;
+    // }
+    if (!hSession && connType != CONN_USB) {
         WRITE_LOG(LOG_FATAL, "CreateConnect hSession nullptr");
         return ERR_BUF_ALLOC;
+    } else if (connType == CONN_USB) {
+        return ERR_NO_SUPPORT;
     }
     HDaemonInfo hdiQuery = nullptr;
     AdminDaemonMap(OP_QUERY, connectKey, hdiQuery);
@@ -1004,17 +1012,17 @@ bool HdcServer::RedirectToTask(HTaskInfo hTaskInfo, HSession hSession, const uin
         case CMD_APP_UNINSTALL:
             ret = TaskCommandDispatch<HdcHostApp>(hTaskInfo, TASK_APP, command, payload, payloadSize);
             break;
-        case CMD_FLASHD_UPDATE_INIT:
-        case CMD_FLASHD_FLASH_INIT:
-        case CMD_FLASHD_CHECK:
-        case CMD_FLASHD_BEGIN:
-        case CMD_FLASHD_DATA:
-        case CMD_FLASHD_FINISH:
-        case CMD_FLASHD_ERASE:
-        case CMD_FLASHD_FORMAT:
-        case CMD_FLASHD_PROGRESS:
-            ret = TaskCommandDispatch<HostUpdater>(hTaskInfo, TASK_FLASHD, command, payload, payloadSize);
-            break;
+        // case CMD_FLASHD_UPDATE_INIT:
+        // case CMD_FLASHD_FLASH_INIT:
+        // case CMD_FLASHD_CHECK:
+        // case CMD_FLASHD_BEGIN:
+        // case CMD_FLASHD_DATA:
+        // case CMD_FLASHD_FINISH:
+        // case CMD_FLASHD_ERASE:
+        // case CMD_FLASHD_FORMAT:
+        // case CMD_FLASHD_PROGRESS:
+        //     ret = TaskCommandDispatch<HostUpdater>(hTaskInfo, TASK_FLASHD, command, payload, payloadSize);
+        //     break;
         default:
             // ignore unknown command
             break;
@@ -1041,9 +1049,9 @@ bool HdcServer::RemoveInstanceTask(const uint8_t op, HTaskInfo hTask)
         case TASK_APP:
             ret = DoTaskRemove<HdcHostApp>(hTask, op);
             break;
-        case TASK_FLASHD:
-            ret = DoTaskRemove<HostUpdater>(hTask, op);
-            break;
+        // case TASK_FLASHD:
+        //     ret = DoTaskRemove<HostUpdater>(hTask, op);
+        //     break;
         default:
             ret = false;
             break;
diff --git a/hdc/src/host/server.h b/src/host/server.h
index add836f..0635451 100755
--- a/hdc/src/host/server.h
+++ b/src/host/server.h
@@ -37,11 +37,11 @@ public:
     void NotifyInstanceSessionFree(HSession hSession, bool freeOrClear) override;
 
     HdcHostTCP *clsTCPClt;
-    HdcHostUSB *clsUSBClt;
+    // HdcHostUSB *clsUSBClt;
 #ifdef HDC_SUPPORT_UART
     void CreatConnectUart(HSession hSession);
     static void UartPreConnect(uv_timer_t *handle);
-    HdcHostUART *clsUARTClt = nullptr;
+    // HdcHostUART *clsUARTClt = nullptr;
 #endif
     void *clsServerForClient;
 
diff --git a/hdc/src/host/server_for_client.cpp b/src/host/server_for_client.cpp
index f342337..f44d219 100644
--- a/hdc/src/host/server_for_client.cpp
+++ b/src/host/server_for_client.cpp
@@ -572,15 +572,15 @@ bool HdcServerForClient::TaskCommand(HChannel hChannel, void *formatCommandInput
     } else if (formatCommand->cmdFlag == CMD_UNITY_BUGREPORT_INIT) {
         cmdFlag = "bugreport ";
         sizeCmdFlag = 10;  // 10: cmdFlag bugreport size
-    } else if (formatCommand->cmdFlag == CMD_APP_SIDELOAD) {
-        cmdFlag = "sideload ";
-        sizeCmdFlag = 9; // 9: cmdFlag sideload size
-    } else if (formatCommand->cmdFlag == CMD_FLASHD_UPDATE_INIT) {
-        cmdFlag = "update ";
-        sizeCmdFlag = 7; // 7: cmdFlag update size
-    } else if (formatCommand->cmdFlag == CMD_FLASHD_FLASH_INIT) {
-        cmdFlag = "flash ";
-        sizeCmdFlag = 6; // 6: cmdFlag flash size
+    // } else if (formatCommand->cmdFlag == CMD_APP_SIDELOAD) {
+    //     cmdFlag = "sideload ";
+    //     sizeCmdFlag = 9; // 9: cmdFlag sideload size
+    // } else if (formatCommand->cmdFlag == CMD_FLASHD_UPDATE_INIT) {
+    //     cmdFlag = "update ";
+    //     sizeCmdFlag = 7; // 7: cmdFlag update size
+    // } else if (formatCommand->cmdFlag == CMD_FLASHD_FLASH_INIT) {
+    //     cmdFlag = "flash ";
+    //     sizeCmdFlag = 6; // 6: cmdFlag flash size
     }
     int sizeSend = formatCommand->parameters.size();
     if (!strncmp(formatCommand->parameters.c_str(), cmdFlag.c_str(), sizeCmdFlag)) {  // local do
@@ -642,7 +642,13 @@ bool HdcServerForClient::DoCommandRemote(HChannel hChannel, void *formatCommandI
         case CMD_UNITY_EXECUTE:
         case CMD_UNITY_REMOUNT:
         case CMD_UNITY_REBOOT:
-        case CMD_UNITY_RUNMODE:
+        case CMD_UNITY_RUNMODE: {
+            if (formatCommand->parameters == CMDSTR_TMODE_USB) {
+                EchoClient(hChannel, MSG_FAIL, "tmode usb is disabled in this streamlined build.");
+                ret = true;
+                break;
+            }
+        }
         case CMD_UNITY_HILOG:
         case CMD_UNITY_ROOTRUN:
         case CMD_JDWP_TRACK:
@@ -663,11 +669,12 @@ bool HdcServerForClient::DoCommandRemote(HChannel hChannel, void *formatCommandI
         case CMD_APP_INIT:
         case CMD_APP_UNINSTALL:
         case CMD_UNITY_BUGREPORT_INIT:
-        case CMD_APP_SIDELOAD:
-        case CMD_FLASHD_UPDATE_INIT:
-        case CMD_FLASHD_FLASH_INIT:
-        case CMD_FLASHD_ERASE:
-        case CMD_FLASHD_FORMAT: {
+        // case CMD_APP_SIDELOAD:
+        // case CMD_FLASHD_UPDATE_INIT:
+        // case CMD_FLASHD_FLASH_INIT:
+        // case CMD_FLASHD_ERASE:
+        // case CMD_FLASHD_FORMAT: 
+        {
             TaskCommand(hChannel, formatCommandInput);
             ret = true;
             break;
diff --git a/hdc/src/host/translate.cpp b/src/host/translate.cpp
index f151022..915715e 100755
--- a/hdc/src/host/translate.cpp
+++ b/src/host/translate.cpp
@@ -4,7 +4,7 @@
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
  *
- *     http://www.apache.org/licenses/LICENSE-2.0
+ * http://www.apache.org/licenses/LICENSE-2.0
  *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
@@ -13,7 +13,7 @@
  * limitations under the License.
  */
 #include "translate.h"
-#include "host_updater.h"
+// #include "host_updater.h"
 
 namespace Hdc {
 namespace TranslateCommand {
@@ -35,11 +35,9 @@ namespace TranslateCommand {
               "service commands(on daemon):\n"
               " target mount                          - Set /system /vendor partition read-write\n"
               " wait                                  - Wait for the device to become available\n"
-              " target boot [-bootloader|-recovery]   - Reboot the device or boot into bootloader\\recovery.\n"
               " target boot [MODE]                    - Reboot the into MODE.\n"
               " smode [-r]                            - Restart daemon with root permissions, '-r' to cancel root\n"
               "                                         permissions\n"
-              " tmode usb                             - Reboot the device, listening on USB\n"
               " tmode port [port]                     - Reboot the device, listening on TCP port\n"
               "\n"
               "---------------------------------task commands:-------------------------------------\n"
@@ -109,27 +107,16 @@ namespace TranslateCommand {
             " list targets [-v]                     - List all devices status, -v for detail\n"
             " tconn key                             - Connect device via key, TCP use ip:port\n"
             "                                         example:192.168.0.100:10178/192.168.0.100\n"
-            "                                         USB connect automatic, TCP need to connect manually\n"
-#ifdef HDC_SUPPORT_UART
-            "\n"
-            "                                         UART connect need connect manually.\n"
-            "                                         Baud Rate can be specified with commas.\n"
-            "                                         key format: <Port Name>[,Baud Rate]\n"
-            "                                         example: tconn COM5,921600\n"
-            "                                         Default Baud Rate is 921600.\n"
-            "\n"
-#endif
+            "                                         TCP need to connect manually\n"
             " start [-r]                            - Start server. If with '-r', will be restart server\n"
             " kill [-r]                             - Kill server. If with '-r', will be restart server\n"
             " -s [ip:]port                          - Set hdc server listen config\n"
             "\n"
             "service commands(on daemon):\n"
             " target mount                          - Set /system /vendor partition read-write\n"
-            " target boot [-bootloader|-recovery]   - Reboot the device or boot into bootloader\\recovery.\n"
             " target boot [MODE]                    - Reboot the into MODE.\n"
             " smode [-r]                            - Restart daemon with root permissions, '-r' to cancel root\n"
             "                                         permissions\n"
-            " tmode usb                             - Reboot the device, listening on USB\n"
             " tmode port [port]                     - Reboot the device, listening on TCP port\n"
             "\n"
             "---------------------------------task commands:-------------------------------------\n"
@@ -172,17 +159,10 @@ namespace TranslateCommand {
             " bugreport [FILE]                      - Return all information from the device, stored in file if FILE "
             "is specified\n"
             " jpid                                  - List PIDs of processes hosting a JDWP transport\n"
-            " sideload [PATH]                       - Sideload the given full OTA package\n"
             "\n"
             "security commands:\n"
             " keygen FILE                           - Generate public/private key; key stored in FILE and FILE.pub\n"
             "\n"
-            "---------------------------------flash commands:------------------------------------\n"
-            "flash commands:\n"
-            " update packagename                    - Update system by package\n"
-            " flash [-f] partition imagename        - Flash partition by image\n"
-            " erase [-f] partition                  - Erase partition\n"
-            " format [-f] partition                 - Format partition\n"
             "---------------------------------external commands:------------------------------------\n"
             "extconn key                             - Connect external device via key, TCP use ip:port(remian)\n"
             "-S [ip:]port                            - Set hdc external server listen config\n"
@@ -224,6 +204,10 @@ namespace TranslateCommand {
                 stringError = "IP:Port incorrect";
                 outCmd->bJumpDo = true;
             }
+        } else {
+            // All wired modes (USB/UART) are removed, only TCP (ip:port) is allowed
+            stringError = "Only TCP (ip:port) connections are supported.";
+            outCmd->bJumpDo = true;
         }
         return stringError;
     }
@@ -260,40 +244,44 @@ namespace TranslateCommand {
         return stringError;
     }
 
-    string RunMode(const char *input, FormatCommand *outCmd)
+    string RunMode(const char *inputRaw, FormatCommand *outCmd)
     {
         string stringError;
         outCmd->cmdFlag = CMD_UNITY_RUNMODE;
-        outCmd->parameters = input + CMDSTR_TARGET_MODE.size() + 1;  // with  ' '
-        int portLength = 4;
-        int portSpaceLength = 5;
-        if (!strncmp(outCmd->parameters.c_str(), "port", portLength) &&
-            !strcmp(outCmd->parameters.c_str(), CMDSTR_TMODE_USB.c_str())) {
-            stringError = "Error tmode command";
-            outCmd->bJumpDo = true;
-        } else if (!strncmp(outCmd->parameters.c_str(), "port ", portSpaceLength)) {
-            const char *tmp = input + strlen("tmode port ");
-            // command is tmode port close
-            if (strcmp(tmp, "close") == 0) {
-                return stringError;
-            }
-            int port = atoi(tmp);
-            if (port > MAX_IP_PORT || port <= 0) {
-                stringError = "Incorrect port range";
-                outCmd->bJumpDo = true;
+        outCmd->parameters = inputRaw + CMDSTR_TARGET_MODE.size() + 1;  // with  ' '
+        
+        if (!strncmp(outCmd->parameters.c_str(), CMDSTR_TMODE_USB.c_str(), CMDSTR_TMODE_USB.size())) {
+             stringError = "tmode usb is disabled in wireless-only mode.";
+             outCmd->bJumpDo = true;
+        } else if (!strncmp(outCmd->parameters.c_str(), "port", 4)) { // 4:"port"
+            // 保留 tmode port 逻辑
+            if (!strncmp(outCmd->parameters.c_str(), "port ", 5)) { // 5:"port "
+                 const char *tmp = inputRaw + strlen("tmode port ");
+                 if (strcmp(tmp, "close") == 0) {
+                     return stringError;
+                 }
+                 int port = atoi(tmp);
+                 if (port > MAX_IP_PORT || port <= 0) {
+                     stringError = "Incorrect port range";
+                     outCmd->bJumpDo = true;
+                 }
             }
+        } else {
+             stringError = "Error tmode command";
+             outCmd->bJumpDo = true;
         }
         return stringError;
     }
 
-    void TargetReboot(const char *input, FormatCommand *outCmd)
+    void TargetReboot(const char *inputRaw, FormatCommand *outCmd)
     {
         outCmd->cmdFlag = CMD_UNITY_REBOOT;
-        if (strcmp(input, CMDSTR_TARGET_REBOOT.c_str())) {
-            outCmd->parameters = input + CMDSTR_TARGET_REBOOT.size() + 1;  // with  ' '
+        if (strcmp(inputRaw, CMDSTR_TARGET_REBOOT.c_str())) {
+            outCmd->parameters = inputRaw + CMDSTR_TARGET_REBOOT.size() + 1;  // with  ' '
             if (outCmd->parameters == "-bootloader" || outCmd->parameters == "-recovery" ||
                 outCmd->parameters == "-flashd") {
-                outCmd->parameters.erase(outCmd->parameters.begin());
+                // 阻止这些模式
+                outCmd->bJumpDo = true;
             }
         }
     }
@@ -370,9 +358,15 @@ namespace TranslateCommand {
                 outCmd->parameters = "a";
             }
         } else if (!strncmp(input.c_str(), CMDSTR_TARGET_REBOOT.c_str(), CMDSTR_TARGET_REBOOT.size())) {
-            TargetReboot(input.c_str(), outCmd);
+            TargetReboot(inputRaw, outCmd);
+            if (outCmd->bJumpDo) {
+                 stringError = "Booting to bootloader/recovery/flashd is disabled in wireless-only mode.";
+            }
+        } else if (!strncmp(input.c_str(), "sideload", 8)) {
+            stringError = "sideload is disabled in wireless-only mode.";
+            outCmd->bJumpDo = true;
         } else if (!strncmp(input.c_str(), CMDSTR_TARGET_MODE.c_str(), CMDSTR_TARGET_MODE.size())) {
-            stringError = RunMode(input.c_str(), outCmd);
+            stringError = RunMode(inputRaw, outCmd);
         } else if (!strncmp(input.c_str(), CMDSTR_HILOG.c_str(), CMDSTR_HILOG.size())) {
             outCmd->cmdFlag = CMD_UNITY_HILOG;
             if (strstr(input.c_str(), " -h")) {
@@ -383,13 +377,6 @@ namespace TranslateCommand {
             if (strstr(input.c_str(), " -r")) {
                 outCmd->parameters = "r";
             }
-        } else if (!strncmp(input.c_str(), CMDSTR_APP_SIDELOAD.c_str(), CMDSTR_APP_SIDELOAD.size())) {
-            if (strlen(input.c_str()) == CMDSTR_APP_SIDELOAD.size()) {
-                stringError = "Incorrect command, please with local path";
-                outCmd->bJumpDo = true;
-            }
-            outCmd->cmdFlag = CMD_APP_SIDELOAD;
-            outCmd->parameters = input;
         } else if (!strncmp(input.c_str(), CMDSTR_BUGREPORT.c_str(), CMDSTR_BUGREPORT.size())) {
             outCmd->cmdFlag = CMD_UNITY_BUGREPORT_INIT;
             outCmd->parameters = input;
@@ -400,9 +387,11 @@ namespace TranslateCommand {
         // Inner command, protocol uses only
         else if (!strncmp(input.c_str(), CMDSTR_INNER_ENABLE_KEEPALIVE.c_str(), CMDSTR_INNER_ENABLE_KEEPALIVE.size())) {
             outCmd->cmdFlag = CMD_KERNEL_ENABLE_KEEPALIVE;
-        } else if (HostUpdater::CheckMatchUpdate(input, *outCmd)) {
-            outCmd->parameters = input;
-        } else {
+        }
+        // } else if (HostUpdater::CheckMatchUpdate(input, *outCmd)) { // -- 移除刷机相关命令
+        //     outCmd->parameters = input;
+        // } 
+        else {
             stringError = "Unknown command...";
             outCmd->bJumpDo = true;
         }
@@ -416,4 +405,4 @@ namespace TranslateCommand {
         return stringError;
     };
 }
-}  // namespace Hdc
+}  // namespace Hdc
\ No newline at end of file
diff --git a/hdc/src/register/define_register.h b/hdc/src/register/define_register.h
deleted file mode 100644
index a620105..0000000
--- a/hdc/src/register/define_register.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef HDC_DEFINE_REGISTER_H
-#define HDC_DEFINE_REGISTER_H
-
-#include <cinttypes>
-#include <cstdint>
-#include <cstdio>
-#include <cstdlib>
-#include <cstring>
-#include <iostream>
-#include <string>
-#include <thread>
-
-#include <securec.h>
-#include <sys/un.h>
-#include <unistd.h>
-#include <uv.h>
-#ifdef HDC_HILOG
-#include "hilog/log.h"
-#ifdef LOG_DOMAIN
-#undef LOG_DOMAIN
-#endif // LOG_DOMAIN
-
-#define LOG_DOMAIN 0xD002D13
-#ifdef LOG_TAG
-#undef LOG_TAG
-#endif // LOG_TAG
-
-#define LOG_TAG "HDC_LOG"
-#endif // HDC_HILOG
-
-namespace Hdc {
-// str one of ark:pid@com.xxx.xxxx, ark:pid@Debugger, ark:pid@tid@Debugger
-using Callback = std::function<void(int fd, std::string str)>;
-}
-#endif // end HDC_DEFINE_REGISTER_H
diff --git a/hdc/src/register/hdc_connect.cpp b/hdc/src/register/hdc_connect.cpp
deleted file mode 100644
index 2799612..0000000
--- a/hdc/src/register/hdc_connect.cpp
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Copyright (c) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include "hdc_connect.h"
-#include "hdc_jdwp.h"
-#include "parameter.h"
-
-namespace Hdc {
-
-std::unique_ptr<ConnectManagement> g_connectManagement = nullptr;
-static HdcJdwpSimulator *g_clsHdcJdwpSimulator = nullptr;
-
-void ConnectManagement::SetProcessName(const std::string &processName)
-{
-    processName_ = processName;
-}
-
-std::string ConnectManagement::GetProcessName() const
-{
-    return processName_;
-}
-
-void ConnectManagement::SetPkgName(const std::string &pkgName)
-{
-    pkgName_ = pkgName;
-}
-
-std::string ConnectManagement::GetPkgName() const
-{
-    return pkgName_;
-}
-
-void ConnectManagement::SetDebug(bool isDebug)
-{
-    isDebug_ = isDebug;
-}
-
-bool ConnectManagement::GetDebug() const
-{
-    return isDebug_;
-}
-
-void ConnectManagement::SetCallback(Callback cb)
-{
-    cb_ = cb;
-}
-
-Callback ConnectManagement::GetCallback() const
-{
-    return cb_;
-}
-
-static void GetDevItem(const char *key, std::string &out, const char *preDefine = nullptr)
-{
-    constexpr int len = 512;
-    char buf[len] = "";
-    if (memset_s(buf, len, 0, len) != EOK) {
-        HILOG_WARN(LOG_CORE, "memset_s failed");
-        return;
-    }
-    auto res = GetParameter(key, preDefine, buf, len);
-    if (res <= 0) {
-        return;
-    }
-    out = buf;
-}
-
-static bool IsDeveloperMode()
-{
-    std::string developerMode;
-    GetDevItem("const.security.developermode.state", developerMode);
-    return developerMode == "true";
-}
-
-void FreeInstance()
-{
-    if (g_clsHdcJdwpSimulator == nullptr) {
-        return;
-    }
-    g_clsHdcJdwpSimulator->Disconnect();
-    delete g_clsHdcJdwpSimulator;
-    g_clsHdcJdwpSimulator = nullptr;
-}
-
-void Stop(int signo)
-{
-    FreeInstance();
-    _exit(0);
-}
-
-void StopConnect()
-{
-    if (!IsDeveloperMode()) {
-        HILOG_INFO(LOG_CORE, "non developer mode not to stop connect");
-        return;
-    }
-#ifdef JS_JDWP_CONNECT
-    FreeInstance();
-#endif // JS_JDWP_CONNECT
-}
-
-void* HdcConnectRun(void* pkgContent)
-{
-    if (signal(SIGINT, Stop) == SIG_ERR) {
-        HILOG_FATAL(LOG_CORE, "jdwp_process signal fail.");
-    }
-    int ret = pthread_setname_np(pthread_self(), "OS_hdcRegister");
-    if (ret != 0) {
-        HILOG_FATAL(LOG_CORE, "set Thread name failed.");
-    }
-    std::string processName = static_cast<ConnectManagement*>(pkgContent)->GetProcessName();
-    std::string pkgName = static_cast<ConnectManagement*>(pkgContent)->GetPkgName();
-    bool isDebug = static_cast<ConnectManagement*>(pkgContent)->GetDebug();
-    Callback cb = static_cast<ConnectManagement*>(pkgContent)->GetCallback();
-    g_clsHdcJdwpSimulator = new (std::nothrow) HdcJdwpSimulator(processName, pkgName, isDebug, cb);
-    if (!g_clsHdcJdwpSimulator->Connect()) {
-        HILOG_FATAL(LOG_CORE, "Connect fail.");
-        return nullptr;
-    }
-    return nullptr;
-}
-
-void StartConnect(const std::string& processName, const std::string& pkgName, bool isDebug, Callback cb)
-{
-    if (!IsDeveloperMode()) {
-        HILOG_INFO(LOG_CORE, "non developer mode not to start connect");
-        return;
-    }
-    if (g_clsHdcJdwpSimulator != nullptr) {
-        return;
-    }
-    pthread_t tid;
-    g_connectManagement = std::make_unique<ConnectManagement>();
-    g_connectManagement->SetProcessName(processName);
-    g_connectManagement->SetPkgName(pkgName);
-    g_connectManagement->SetDebug(isDebug);
-    g_connectManagement->SetCallback(cb);
-    if (pthread_create(&tid, nullptr, &HdcConnectRun, static_cast<void*>(g_connectManagement.get())) != 0) {
-        HILOG_FATAL(LOG_CORE, "pthread_create fail!");
-        return;
-    }
-}
-} // namespace Hdc
diff --git a/hdc/src/register/hdc_connect.h b/hdc/src/register/hdc_connect.h
deleted file mode 100644
index 4a23897..0000000
--- a/hdc/src/register/hdc_connect.h
+++ /dev/null
@@ -1,56 +0,0 @@
-/*
- * Copyright (c) 2021-2022 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#ifndef REGISTER_HDC_CONNECT_H
-#define REGISTER_HDC_CONNECT_H
-
-#include <string>
-#include "define_register.h"
-namespace Hdc {
-#ifdef __cplusplus
-#if __cplusplus
-extern "C" {
-#endif
-#endif /* End of #ifdef __cplusplus */
-void StartConnect(const std::string& processName, const std::string& pkgName, bool isDebug, Callback cb);
-void StopConnect();
-#ifdef __cplusplus
-#if __cplusplus
-}
-#endif
-#endif /* End of #ifdef __cplusplus */
-
-class ConnectManagement {
-public:
-    ConnectManagement() = default;
-    ~ConnectManagement() {}
-    void SetProcessName(const std::string& processName);
-    std::string GetProcessName() const;
-    void SetPkgName(const std::string& pkgName);
-    std::string GetPkgName() const;
-    void SetDebug(bool isDebug);
-    bool GetDebug() const;
-    void SetCallback(Callback cb);
-    Callback GetCallback() const;
-
-private:
-    std::string processName_;
-    std::string pkgName_;
-    bool isDebug_;
-    Callback cb_;
-};
-} // namespace Hdc
-
-#endif // REGISTER_HDC_CONNECT_H
diff --git a/hdc/src/register/hdc_jdwp.cpp b/hdc/src/register/hdc_jdwp.cpp
deleted file mode 100644
index 05fdeca..0000000
--- a/hdc/src/register/hdc_jdwp.cpp
+++ /dev/null
@@ -1,288 +0,0 @@
-/*
- * Copyright (C) 2021-2022 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-#include "hdc_jdwp.h"
-#include "parameter.h"
-#include <sys/epoll.h>
-#include <unistd.h>
-
-namespace Hdc {
-
-HdcJdwpSimulator::HdcJdwpSimulator(const std::string processName, const std::string pkgName, bool isDebug, Callback cb)
-{
-    processName_ = processName;
-    pkgName_ = pkgName;
-    isDebug_ = isDebug;
-    cb_ = cb;
-    cfd_ = -1;
-    disconnectFlag_ = false;
-    notified_ = false;
-    AddWatchHdcdJdwp();
-}
-
-void HdcJdwpSimulator::Disconnect()
-{
-    disconnectFlag_ = true;
-    cv_.notify_one();
-    if (cfd_ > -1) {
-        shutdown(cfd_, SHUT_RDWR);
-        close(cfd_);
-        cfd_ = -1;
-    }
-}
-
-HdcJdwpSimulator::~HdcJdwpSimulator()
-{
-    Disconnect();
-    DelWatchHdcdJdwp();
-}
-
-bool HdcJdwpSimulator::SendBuf(const uint8_t *buf, const int bufLen)
-{
-    ssize_t rc = write(cfd_, buf, bufLen);
-    if (rc < 0) {
-        HILOG_FATAL(LOG_CORE, "SendBuf failed errno:%{public}d", errno);
-        return false;
-    }
-    return true;
-}
-
-bool HdcJdwpSimulator::Connect2Jdwp()
-{
-    const char jdwp[] = { '\0', 'o', 'h', 'j', 'p', 'i', 'd', '-', 'c', 'o', 'n', 't', 'r', 'o', 'l', 0 };
-    struct sockaddr_un caddr;
-    if (memset_s(&caddr, sizeof(caddr), 0, sizeof(caddr)) != EOK) {
-        HILOG_FATAL(LOG_CORE, "memset_s failed");
-        return false;
-    }
-    caddr.sun_family = AF_UNIX;
-    for (size_t i = 0; i < sizeof(jdwp); i++) {
-        caddr.sun_path[i] = jdwp[i];
-    }
-    cfd_ = socket(AF_UNIX, SOCK_STREAM | SOCK_CLOEXEC, 0);
-    if (cfd_ < 0) {
-        HILOG_FATAL(LOG_CORE, "socket failed errno:%{public}d", errno);
-        return false;
-    }
-    struct timeval timeout;
-    timeout.tv_sec = 1;
-    timeout.tv_usec = 0;
-    setsockopt(cfd_, SOL_SOCKET, SO_SNDTIMEO, &timeout, sizeof(timeout));
-    size_t caddrLen = sizeof(caddr.sun_family) + sizeof(jdwp) - 1;
-    int retry = 3;
-    int rc = 0;
-    while (retry-- > 0) {
-        rc = connect(cfd_, reinterpret_cast<struct sockaddr *>(&caddr), caddrLen);
-        if (rc == 0) {
-            HILOG_INFO(LOG_CORE, "connect success cfd:%{public}d", cfd_);
-            break;
-        }
-        constexpr int to = 3;
-        sleep(to);
-    }
-    if (rc != 0) {
-        HILOG_INFO(LOG_CORE, "connect failed cfd_:%{public}d", cfd_);
-        close(cfd_);
-        cfd_ = -1;
-        return false;
-    }
-    return true;
-}
-
-bool HdcJdwpSimulator::Send2Jdwp()
-{
-#ifdef JS_JDWP_CONNECT
-    uint32_t pidCurr = static_cast<uint32_t>(getprocpid());
-    std::string processName = processName_;
-    std::string pkgName = pkgName_;
-    bool isDebug = isDebug_;
-    std::string pp = pkgName;
-    if (!processName.empty()) {
-        pp += "/" + processName;
-    }
-    uint32_t ppSize = pp.size() + sizeof(JsMsgHeader);
-    uint8_t* info = new (std::nothrow) uint8_t[ppSize]();
-    if (info == nullptr) {
-        HILOG_FATAL(LOG_CORE, "Send2Jdwp new info fail.");
-        return false;
-    }
-    if (memset_s(info, ppSize, 0, ppSize) != EOK) {
-        delete[] info;
-        info = nullptr;
-        return false;
-    }
-    JsMsgHeader *jsMsg = reinterpret_cast<JsMsgHeader *>(info);
-    jsMsg->msgLen = ppSize;
-    jsMsg->pid = pidCurr;
-    jsMsg->isDebug = isDebug;
-    HILOG_INFO(LOG_CORE,
-        "Send2Jdwp send pid:%{public}d, pp:%{public}s, isDebug:%{public}d, msglen:%{public}d",
-        jsMsg->pid, pp.c_str(), isDebug, jsMsg->msgLen);
-    bool ret = true;
-    if (memcpy_s(info + sizeof(JsMsgHeader), pp.size(), &pp[0], pp.size()) != EOK) {
-        HILOG_FATAL(LOG_CORE, "Send2Jdwp memcpy_s fail :%{public}s.", pp.c_str());
-        ret = false;
-    } else {
-        ret = SendBuf(static_cast<uint8_t*>(info), ppSize);
-    }
-    delete[] info;
-    return ret;
-#endif
-    return false;
-}
-
-void HdcJdwpSimulator::ReadFromJdwp()
-{
-    constexpr size_t size = 256;
-    constexpr long sec = 5;
-    constexpr long ms = 1000;
-    uint8_t buf[size] = { 0 };
-    constexpr int maxevents = 1;
-    struct epoll_event ev;
-    struct epoll_event evs[maxevents];
-    int efd = epoll_create(maxevents);
-    if (efd == -1) {
-        HILOG_FATAL(LOG_CORE, "Read epoll_create error:%{public}d", errno);
-        return;
-    }
-    ev.data.fd = cfd_;
-    ev.events = EPOLLIN ;
-    int rc = epoll_ctl(efd, EPOLL_CTL_ADD, cfd_, &ev);
-    if (rc == -1) {
-        HILOG_FATAL(LOG_CORE, "Read epoll_ctl add cfd:%{public}d error:%{public}d",
-            cfd_, errno);
-        close(efd);
-        return;
-    }
-    while (!disconnectFlag_) {
-        ssize_t cnt = 0;
-        ssize_t minlen = sizeof(int32_t);
-        rc = epoll_wait(efd, evs, maxevents, sec * ms);
-        if (rc < 0) {
-            if (errno == EINTR) {
-                continue;
-            }
-            HILOG_FATAL(LOG_CORE, "Read epoll_wait cfd:%{public}d error:%{public}d",
-                cfd_, errno);
-            break;
-        } else if (rc == 0) {
-            continue;
-        }
-        int rfd = evs[0].data.fd;
-        if (memset_s(buf, sizeof(buf), 0, sizeof(buf)) != EOK) {
-            continue;
-        }
-        struct iovec iov;
-        iov.iov_base = buf;
-        iov.iov_len = size - 1;
-        struct msghdr msg;
-        msg.msg_iov = &iov;
-        msg.msg_iovlen = 1;
-        int len = CMSG_SPACE(static_cast<unsigned int>(sizeof(int)));
-        char ctlBuf[len];
-        msg.msg_controllen = sizeof(ctlBuf);
-        msg.msg_control = ctlBuf;
-        cnt = recvmsg(rfd, &msg, 0);
-        if (cnt < 0) {
-            HILOG_FATAL(LOG_CORE, "Read recvmsg rfd:%{public}d errno:%{public}d", rfd, errno);
-            break;
-        } else if (cnt == 0) {
-            HILOG_WARN(LOG_CORE, "Read recvmsg socket peer closed rfd:%{public}d", rfd);
-            break;
-        } else if (cnt < minlen) {
-            HILOG_WARN(LOG_CORE, "Read recvmsg cnt:%{public}zd rfd:%{public}d", cnt, rfd);
-            continue;
-        }
-        int32_t fd = *reinterpret_cast<int32_t *>(buf);
-        std::string str(reinterpret_cast<char *>(buf + sizeof(int32_t)), cnt - sizeof(int32_t));
-        HILOG_INFO(LOG_CORE, "Read fd:%{public}d str:%{public}s", fd, str.c_str());
-        struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
-        if (cmsg == nullptr) {
-            HILOG_FATAL(LOG_CORE, "Read cmsg is nullptr");
-            continue;
-        }
-        if (cmsg->cmsg_level != SOL_SOCKET || cmsg->cmsg_type != SCM_RIGHTS ||
-            cmsg->cmsg_len != CMSG_LEN(sizeof(int))) {
-            HILOG_INFO(LOG_CORE, "Read level:%{public}d type:%{public}d len:%{public}d",
-                cmsg->cmsg_level, cmsg->cmsg_type, cmsg->cmsg_len);
-            continue;
-        }
-        int newfd = *(reinterpret_cast<int *>(CMSG_DATA(cmsg)));
-        HILOG_INFO(LOG_CORE, "Read fd:%{public}d newfd:%{public}d str:%{public}s",
-            fd, newfd, str.c_str());
-        if (cb_) {
-            cb_(newfd, str);
-        }
-    }
-    rc = epoll_ctl(efd, EPOLL_CTL_DEL, cfd_, nullptr);
-    if (rc == -1) {
-        HILOG_WARN(LOG_CORE, "Read epoll_ctl del cfd:%{public}d error:%{public}d", cfd_, errno);
-    }
-    close(cfd_);
-    cfd_ = -1;
-    close(efd);
-}
-
-bool HdcJdwpSimulator::Connect()
-{
-    while (!disconnectFlag_) {
-        bool b = Connect2Jdwp();
-        if (!b) {
-            HILOG_INFO(LOG_CORE, "Connect2Jdwp failed cfd:%{public}d", cfd_);
-            WaitForJdwp();
-            continue;
-        }
-        b = Send2Jdwp();
-        if (!b) {
-            HILOG_WARN(LOG_CORE, "Send2Jdwp failed cfd:%{public}d", cfd_);
-            continue;
-        }
-        ReadFromJdwp();
-    }
-    return true;
-}
-
-void HdcJdwpSimulator::WaitForJdwp()
-{
-    {
-        std::unique_lock<std::mutex> lock(mutex_);
-        cv_.wait(lock, [this]() -> bool { return this->notified_ || this->disconnectFlag_; });
-    }
-    notified_ = false;
-}
-
-void HdcJdwpSimulator::AddWatchHdcdJdwp()
-{
-    auto eventCallback = [](const char *key, const char *value, void *context) {
-        auto that = reinterpret_cast<HdcJdwpSimulator *>(context);
-        if (strncmp(key, PERSIST_HDC_JDWP, strlen(PERSIST_HDC_JDWP)) != 0) {
-            return;
-        }
-        if (strncmp(value, "1", strlen("1")) != 0) {
-            return;
-        }
-        that->notified_ = true;
-        that->cv_.notify_one();
-    };
-    int rc = WatchParameter(PERSIST_HDC_JDWP, eventCallback, this);
-    HILOG_INFO(LOG_CORE, "AddWatchHdcdJdwp rc:%{public}d", rc);
-}
-
-void HdcJdwpSimulator::DelWatchHdcdJdwp()
-{
-    int rc = RemoveParameterWatcher(PERSIST_HDC_JDWP, nullptr, nullptr);
-    HILOG_INFO(LOG_CORE, "DelWatchHdcdJdwp rc:%{public}d", rc);
-}
-} // namespace Hdc
diff --git a/hdc/src/register/hdc_jdwp.h b/hdc/src/register/hdc_jdwp.h
deleted file mode 100644
index 7343be6..0000000
--- a/hdc/src/register/hdc_jdwp.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2021-2022 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-
-#ifndef REGISTER_HDC_JDWP_H
-#define REGISTER_HDC_JDWP_H
-
-#include "define_register.h"
-
-namespace Hdc {
-const char PERSIST_HDC_JDWP[] = "persist.hdc.jdwp";
-class HdcJdwpSimulator;
-
-class HdcJdwpSimulator {
-public:
-    explicit HdcJdwpSimulator(std::string processName, std::string pkgName, bool isDebug, Callback cb);
-    ~HdcJdwpSimulator();
-    bool Connect();
-    void Disconnect();
-
-private:
-    struct JsMsgHeader {
-        uint32_t msgLen;
-        uint32_t pid;
-        uint8_t isDebug; // 1:debug 0:release
-    };
-
-    std::string processName_;
-    std::string pkgName_;
-    bool isDebug_;
-    Callback cb_;
-    int cfd_;
-    std::atomic<bool> disconnectFlag_;
-    std::atomic<bool> notified_;
-    std::mutex mutex_;
-    std::condition_variable cv_;
-
-    void AddWatchHdcdJdwp();
-    void DelWatchHdcdJdwp();
-    void WaitForJdwp();
-    bool SendBuf(const uint8_t *buf, const int bufLen);
-    bool Connect2Jdwp();
-    bool Send2Jdwp();
-    void ReadFromJdwp();
-};
-} // namespace Hdc
-#endif  // REGISTER_HDC_JDWP_H
diff --git a/hdc/src/test/jdwp/BUILD.gn b/hdc/src/test/jdwp/BUILD.gn
deleted file mode 100644
index 7f9ff43..0000000
--- a/hdc/src/test/jdwp/BUILD.gn
+++ /dev/null
@@ -1,35 +0,0 @@
-# Copyright (C) 2021 Huawei Device Co., Ltd.
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-import("//build/ohos.gni")
-
-#Purpose: For jdwp test
-ohos_executable("jdwp_test") {
-  cflags_cc = [ "-std=c++17" ]
-  defines = [ "JS_JDWP_CONNECT" ]
-  sources = [
-    "HdcJdwpSimulator.cpp",
-    "main.cpp",
-  ]
-  deps = [ "//third_party/libuv:uv" ]
-  external_deps = [
-    "c_utils:utils",
-    "hilog:libhilog",
-  ]
-  include_dirs = [
-    "//third_party/bounds_checking_function/include",
-    "//third_party/libuv",
-  ]
-  install_enable = true
-  subsystem_name = "developtools"
-  part_name = "hdc"
-}
diff --git a/hdc/src/test/jdwp/HdcJdwpSimulator.cpp b/hdc/src/test/jdwp/HdcJdwpSimulator.cpp
deleted file mode 100644
index 83f4734..0000000
--- a/hdc/src/test/jdwp/HdcJdwpSimulator.cpp
+++ /dev/null
@@ -1,296 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-#include "HdcJdwpSimulator.h"
-using namespace OHOS;
-using namespace OHOS::HiviewDFX;
-static constexpr HiLogLabel LABEL = {LOG_CORE, 0, "JDWP_TEST"};
-HdcJdwpSimulator::HdcJdwpSimulator(uv_loop_t *loopIn, string pkg)
-{
-    loop = loopIn;
-    exit = false;
-    pkgName = pkg;
-}
-
-HdcJdwpSimulator::~HdcJdwpSimulator() {}
-
-void HdcJdwpSimulator::FinishWriteCallback(uv_write_t *req, int status)
-{
-    constexpr int bufSize = 1024;
-    char buf[bufSize] = { 0 };
-    uv_err_name_r(status, buf, bufSize);
-    HiLog::Info(LABEL, "FinishWriteCallback:%{public}d error:%{public}s", status, buf);
-    delete[](static_cast<uint8_t *>(req->data));
-    delete req;
-}
-
-RetErrCode HdcJdwpSimulator::SendToStream(uv_stream_t *handleStream, const uint8_t *buf,
-                                          const int bufLen, const void *finishCallback)
-{
-    HiLog::Info(LABEL, "HdcJdwpSimulator::SendToStream: %{public}s, %{public}d", buf, bufLen);
-    RetErrCode ret = RetErrCode::ERR_GENERIC;
-    if (bufLen <= 0) {
-        HiLog::Error(LABEL, "HdcJdwpSimulator::SendToStream wrong bufLen.");
-        return RetErrCode::ERR_GENERIC;
-    }
-    uint8_t *pDynBuf = new uint8_t[bufLen];
-    if (!pDynBuf) {
-        HiLog::Error(LABEL, "HdcJdwpSimulator::SendToStream new pDynBuf fail.");
-        return RetErrCode::ERR_GENERIC;
-    }
-    if (memcpy_s(pDynBuf, bufLen, buf, bufLen)) {
-        delete[] pDynBuf;
-        HiLog::Error(LABEL, "HdcJdwpSimulator::SendToStream memcpy fail.");
-        return RetErrCode::ERR_BUF_ALLOC;
-    }
-
-    uv_write_t *reqWrite = new uv_write_t();
-    if (!reqWrite) {
-        HiLog::Error(LABEL, "HdcJdwpSimulator::SendToStream alloc reqWrite fail.");
-        delete[] pDynBuf;
-        return RetErrCode::ERR_GENERIC;
-    }
-    uv_buf_t bfr;
-    while (true) {
-        reqWrite->data = static_cast<void *>(pDynBuf);
-        bfr.base = reinterpret_cast<char *>(pDynBuf);
-        bfr.len = bufLen;
-        if (!uv_is_writable(handleStream)) {
-            HiLog::Info(LABEL, "SendToStream uv_is_unwritable!");
-            delete[] pDynBuf;
-            delete reqWrite;
-            break;
-        }
-        HiLog::Info(LABEL, "SendToStream buf:%{public}s", pDynBuf);
-        uv_write(reqWrite, handleStream, &bfr, 1, (uv_write_cb)finishCallback);
-        ret = RetErrCode::SUCCESS;
-        break;
-    }
-    return ret;
-}
-
-void HdcJdwpSimulator::alloc_buffer(uv_handle_t *handle, size_t suggested_size, uv_buf_t *buf)
-{
-    if (suggested_size <= 0) {
-        return;
-    }
-    buf->base = (char *)malloc(suggested_size);
-    buf->len = suggested_size;
-}
-
-#ifndef JS_JDWP_CONNECT
-// Process incoming data.  If no data is available, this will block until some
-// arrives.
-void HdcJdwpSimulator::ProcessIncoming(uv_stream_t *client, ssize_t nread, const uv_buf_t *buf)
-{
-    HiLog::Debug(LABEL, "ProcessIncoming :%{public}d", nread);
-    do {
-        if (nread > 0) {
-            std::unique_ptr<char[]> recv = std::make_unique<char[]>(nread + 1);
-            if (memset_s(recv.get(), nread, 0, nread) != EOK) {
-                HiLog::Error(LABEL, "ProcessIncoming memset_s fail.");
-                break;
-            }
-            if (memcpy_s(recv.get(), nread, buf->base, nread) != EOK) {
-                HiLog::Error(LABEL, "ProcessIncoming memcpy_s fail.");
-                break;
-            }
-            for (int i = 0; i < (nread + 1); i++) {
-                HiLog::Info(LABEL, "ProcessIncoming recv2[%{public}d] :%{public}c", i, recv[i]);
-            }
-
-            vector<uint8_t> reply;
-            reply.clear();
-            reply.insert(reply.end(), HANDSHAKE_MESSAGE.c_str(),
-                         HANDSHAKE_MESSAGE.c_str() + HANDSHAKE_MESSAGE.size());
-            reply.insert(reply.end(), buf->base, buf->base + nread);
-            HiLog::Info(LABEL, "ProcessIncoming--reply server");
-            uint8_t *buf = reply.data();
-
-            for (int i = 0; i < (HANDSHAKE_MESSAGE.size() + nread + 1); i++) {
-                HiLog::Info(LABEL, "ProcessIncoming reply%{public}d :%{public}c", i, reply[i]);
-            }
-            SendToStream(client, buf, HANDSHAKE_MESSAGE.size() + nread + 1,
-                         (void *)FinishWriteCallback);
-        } else {
-            if (nread != UV_EOF) {
-                constexpr int bufSize = 1024;
-                char buffer[bufSize] = { 0 };
-                uv_err_name_r(nread, buffer, bufSize);
-                HiLog::Debug(LABEL, "ProcessIncoming error %s\n", buffer);
-            }
-            uv_close((uv_handle_t *)client, NULL);
-        }
-    } while (false);
-    free(buf->base);
-}
-
-// Get new socket fd passed from jdwp control
-void HdcJdwpSimulator::ReceiveNewFd(uv_stream_t *q, ssize_t nread, const uv_buf_t *buf)
-{
-    HCtxJdwpSimulator ctxJdwp = static_cast<HCtxJdwpSimulator>(q->data);
-    HdcJdwpSimulator *thisClass = static_cast<HdcJdwpSimulator *>(ctxJdwp->thisClass);
-    int pidCurr = static_cast<int>(getpid());
-    HiLog::Debug(LABEL, "HdcJdwpSimulator::ReceiveNewFd pid: %{public}d, nread: %{public}d\n",
-                 pidCurr, nread);
-    if (nread < 0) {
-        if (nread != UV_EOF) {
-            constexpr int bufSize = 1024;
-            char buffer[bufSize] = { 0 };
-            uv_err_name_r(nread, buffer, bufSize);
-            HiLog::Error(LABEL, "Read error %s\n", buffer);
-        }
-        uv_close((uv_handle_t *)q, NULL);
-        return;
-    }
-
-    uv_pipe_t *pipe = reinterpret_cast<uv_pipe_t *>(q);
-    if (!uv_pipe_pending_count(pipe)) {
-        HiLog::Error(LABEL, "No pending count\n");
-        return;
-    }
-    uv_handle_type pending = uv_pipe_pending_type(pipe);
-    if (pending != UV_TCP) {
-        HiLog::Debug(LABEL, "None TCP type: %{public}d", pending);
-    }
-    uv_tcp_init(thisClass->loop, &ctxJdwp->newFd);
-    if (uv_accept(q, reinterpret_cast<uv_stream_t *>(&ctxJdwp->newFd)) == 0) {
-        uv_os_fd_t fd;
-        ctxJdwp->hasNewFd = true;
-        uv_fileno(reinterpret_cast<const uv_handle_t *>(&ctxJdwp->newFd), &fd);
-        HiLog::Debug(LABEL, "Jdwp forward pid %{public}d: new fd %{public}d\n", getpid(), fd);
-        uv_read_start(reinterpret_cast<uv_stream_t *>(&ctxJdwp->newFd), alloc_buffer,
-                      ProcessIncoming);
-    } else {
-        ctxJdwp->hasNewFd = false;
-        uv_close(reinterpret_cast<uv_handle_t *>(&ctxJdwp->newFd), NULL);
-    }
-}
-#endif // JS_JDWP_CONNECT
-
-void HdcJdwpSimulator::ConnectJdwp(uv_connect_t *connection, int status)
-{
-    constexpr int bufSize = 1024;
-    char buf[bufSize] = { 0 };
-    uv_err_name_r(status, buf, bufSize);
-    HiLog::Debug(LABEL, "ConnectJdwp:%{public}d error:%{public}s", status, buf);
-    uint32_t pidCurr = static_cast<uint32_t>(getpid());
-    HCtxJdwpSimulator ctxJdwp = static_cast<HCtxJdwpSimulator>(connection->data);
-    HdcJdwpSimulator *thisClass = static_cast<HdcJdwpSimulator *>(ctxJdwp->thisClass);
-    delete connection;
-
-#ifdef JS_JDWP_CONNECT
-    string pkgName = thisClass->pkgName;
-    uint32_t pkgSize = pkgName.size() + sizeof(JsMsgHeader); // JsMsgHeader pkgName;
-    uint8_t *info = new uint8_t[pkgSize]();
-    if (!info) {
-        HiLog::Error(LABEL, "ConnectJdwp new info fail.");
-        return;
-    }
-    do {
-        if (memset_s(info, pkgSize, 0, pkgSize) != EOK) {
-            HiLog::Error(LABEL, "ConnectJdwp memset_s fail.");
-            break;
-        }
-        JsMsgHeader *jsMsg = reinterpret_cast<JsMsgHeader *>(info);
-        jsMsg->pid = pidCurr;
-        jsMsg->msgLen = pkgSize;
-        HiLog::Info(LABEL,
-                    "ConnectJdwp send pid:%{public}d, pkgName:%{public}s, msgLen:%{public}d,",
-                    jsMsg->pid, pkgName.c_str(), jsMsg->msgLen);
-        bool retFail = false;
-        if (memcpy_s(info + sizeof(JsMsgHeader), pkgName.size(), &pkgName[0], pkgName.size()) !=
-            EOK) {
-            HiLog::Error(LABEL, "ConnectJdwp memcpy_s fail :%{public}s.", pkgName.c_str());
-            retFail = true;
-        }
-        if (!retFail) {
-            HiLog::Info(LABEL, "ConnectJdwp send JS msg:%{public}s", info);
-            thisClass->SendToStream(reinterpret_cast<uv_stream_t *>(&ctxJdwp->pipe), info, pkgSize,
-                                    (void *)FinishWriteCallback);
-        }
-    } while (false);
-    if (info) {
-        delete[] info;
-        info = nullptr;
-    }
-#else
-    int pidLength = 5;
-    char pid[pidLength] = {0};
-    if (to_string(pidCurr).length() >= pidLength || sprintf_s(pid, sizeof(pid), "%d", pidCurr) < 0) {
-        HiLog::Info(LABEL, "ConnectJdwp trans pid fail :%{public}d.", pidCurr);
-        return;
-    }
-    HiLog::Info(LABEL, "ConnectJdwp send pid:%{public}s", pid);
-    thisClass->SendToStream(reinterpret_cast<uv_stream_t *>(&ctxJdwp->pipe),
-                            reinterpret_cast<uint8_t *>(pid), sizeof(pidCurr),
-                            (void *)FinishWriteCallback);
-    HiLog::Info(LABEL, "ConnectJdwp reading.");
-    uv_read_start(reinterpret_cast<uv_stream_t *>(&ctxJdwp->pipe), thisClass->alloc_buffer,
-                  ReceiveNewFd);
-#endif // JS_JDWP_CONNECT
-}
-
-void *HdcJdwpSimulator::MallocContext()
-{
-    HCtxJdwpSimulator ctx = nullptr;
-    if ((ctx = new ContextJdwpSimulator()) == nullptr) {
-        return nullptr;
-    }
-    ctx->thisClass = this;
-    ctx->pipe.data = ctx;
-    ctx->hasNewFd = false;
-    return ctx;
-}
-
-void HdcJdwpSimulator::FreeContext()
-{
-    HiLog::Debug(LABEL, "HdcJdwpSimulator::FreeContext start");
-    if (!ctxPoint) {
-        return;
-    }
-    if (loop && !uv_is_closing(reinterpret_cast<uv_handle_t *>(&ctxPoint->pipe))) {
-        uv_close(reinterpret_cast<uv_handle_t *>(&ctxPoint->pipe), nullptr);
-    }
-    if (ctxPoint->hasNewFd && loop &&
-        !uv_is_closing(reinterpret_cast<uv_handle_t *>(&ctxPoint->newFd))) {
-        uv_close(reinterpret_cast<uv_handle_t *>(&ctxPoint->newFd), nullptr);
-    }
-    delete ctxPoint;
-    ctxPoint = nullptr;
-    HiLog::Debug(LABEL, "HdcJdwpSimulator::FreeContext end");
-}
-
-bool HdcJdwpSimulator::Connect()
-{
-    string jdwpCtrlName = "\0ohjpid-control";
-    uv_connect_t *connect = new uv_connect_t();
-    ctxPoint = static_cast<HCtxJdwpSimulator>(MallocContext());
-    if (!ctxPoint) {
-        HiLog::Info(LABEL, "MallocContext failed");
-        return false;
-    }
-    connect->data = ctxPoint;
-    uv_pipe_init(loop, static_cast<uv_pipe_t *>(&ctxPoint->pipe), 1);
-    HiLog::Info(LABEL, " HdcJdwpSimulator Connect begin");
-    uv_pipe_connect(connect, &ctxPoint->pipe, jdwpCtrlName.c_str(), ConnectJdwp);
-    return true;
-}
-
-void HdcJdwpSimulator::stop()
-{
-    HiLog::Debug(LABEL, "HdcJdwpSimulator::stop.");
-    FreeContext();
-}
diff --git a/hdc/src/test/jdwp/HdcJdwpSimulator.h b/hdc/src/test/jdwp/HdcJdwpSimulator.h
deleted file mode 100644
index 4a2d8ca..0000000
--- a/hdc/src/test/jdwp/HdcJdwpSimulator.h
+++ /dev/null
@@ -1,58 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-#ifndef HDC_JDWP_SIMULATOR
-#define HDC_JDWP_SIMULATOR
-#include "define.h"
-class HdcJdwpSimulator;
-
-class HdcJdwpSimulator {
-public:
-    explicit HdcJdwpSimulator(uv_loop_t *loopIn, string pkg);
-    ~HdcJdwpSimulator();
-    bool Connect();
-    void stop();
-    uv_loop_t *loop;
-
-protected:
-    struct ContextJdwpSimulator {
-        uv_pipe_t pipe;
-        uv_tcp_t newFd;
-        bool hasNewFd;
-        HdcJdwpSimulator *thisClass;
-    };
-    using HCtxJdwpSimulator = struct ContextJdwpSimulator *;
-
-private:
-    struct JsMsgHeader {
-        uint32_t msgLen;
-        uint32_t pid;
-    };
-    void *MallocContext();
-    void FreeContext();
-    static void ConnectJdwp(uv_connect_t *connection, int status);
-    static void FinishWriteCallback(uv_write_t *req, int status);
-#ifndef JS_JDWP_CONNECT
-    static void ReceiveNewFd(uv_stream_t *q, ssize_t nread, const uv_buf_t *buf);
-    static void ProcessIncoming(uv_stream_t *client, ssize_t nread, const uv_buf_t *buf);
-#endif // JS_JDWP_CONNECT
-    static void alloc_buffer(uv_handle_t *handle, size_t suggested_size, uv_buf_t *buf);
-    static RetErrCode SendToStream(uv_stream_t *handleStream, const uint8_t *buf, const int bufLen,
-                                   const void *finishCallback);
-    HCtxJdwpSimulator ctxPoint;
-    bool exit = false;
-    string pkgName;
-};
-#endif
diff --git a/hdc/src/test/jdwp/define.h b/hdc/src/test/jdwp/define.h
deleted file mode 100644
index cc38ee9..0000000
--- a/hdc/src/test/jdwp/define.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_TEST
-#define HDC_TEST
-#include <unistd.h>
-#include <cstdio>
-#include <cstdlib>
-#include <vector>
-#include <iostream>
-#include <string>
-#include <cstring>
-#include <cstdint>
-#include <cinttypes>
-#include <cstring>
-#include <uv.h>
-#include <securec.h>
-#include "hilog/log.h"
-using std::string;
-using std::vector;
-enum class RetErrCode {
-    SUCCESS = 0,
-    ERR_GENERIC = -1,
-    ERR_BUF_ALLOC = -2,
-};
-const string HANDSHAKE_MESSAGE = "OHOS HDC-HELLO";
-#endif // end HDC_TEST
\ No newline at end of file
diff --git a/hdc/src/test/jdwp/main.cpp b/hdc/src/test/jdwp/main.cpp
deleted file mode 100644
index 9dad8ea..0000000
--- a/hdc/src/test/jdwp/main.cpp
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- */
-// The process is used to test jdwp.
-// jpid List pids of processes hosting a JDWP transport
-#include "define.h"
-#include "HdcJdwpSimulator.h"
-using namespace OHOS::HiviewDFX;
-static constexpr HiLogLabel LABEL = {LOG_CORE, 0, "JDWP_TEST"};
-static uv_loop_t loopMain;
-static HdcJdwpSimulator *clsHdcJdwpSimulator = nullptr;
-
-static void PrintMessage(const char *fmt, ...)
-{
-    int ret = 0;
-    va_list ap;
-    va_start(ap, fmt);
-    vfprintf(stdout, fmt, ap);
-    ret = fprintf(stdout, "\n");
-    va_end(ap);
-}
-
-static void TryCloseHandle(const uv_handle_t *handle, bool alwaysCallback,
-                           uv_close_cb closeCallBack)
-{
-    bool hasCallClose = false;
-    if (handle->loop && !uv_is_closing(handle)) {
-        uv_close((uv_handle_t *)handle, closeCallBack);
-        hasCallClose = true;
-    }
-    if (!hasCallClose && alwaysCallback) {
-        closeCallBack((uv_handle_t *)handle);
-    }
-}
-
-static void TryCloseHandle(const uv_handle_t *handle, uv_close_cb closeCallBack)
-{
-    TryCloseHandle(handle, false, closeCallBack);
-}
-
-static void TryCloseHandle(const uv_handle_t *handle)
-{
-    TryCloseHandle(handle, nullptr);
-}
-
-static bool TryCloseLoop(uv_loop_t *ptrLoop, const char *callerName)
-{
-    uint8_t closeRetry = 0;
-    bool ret = false;
-    constexpr int maxRetry = 3;
-    constexpr int maxHandle = 2;
-    for (closeRetry = 0; closeRetry < maxRetry; ++closeRetry) {
-        if (uv_loop_close(ptrLoop) == UV_EBUSY) {
-            if (closeRetry > maxRetry) {
-                PrintMessage("%s close busy,try:%d", callerName, closeRetry);
-            }
-
-            if (ptrLoop->active_handles >= maxHandle) {
-                PrintMessage("TryCloseLoop issue");
-            }
-            auto clearLoopTask = [](uv_handle_t *handle, void *arg) -> void {
-                TryCloseHandle(handle);
-            };
-            uv_walk(ptrLoop, clearLoopTask, nullptr);
-            // If all processing ends, Then return0,this call will block
-            if (!ptrLoop->active_handles) {
-                ret = true;
-                break;
-            }
-            if (!uv_run(ptrLoop, UV_RUN_ONCE)) {
-                ret = true;
-                break;
-            }
-        } else {
-            ret = true;
-            break;
-        }
-    }
-    return ret;
-}
-
-static void FreeInstance()
-{
-    if (clsHdcJdwpSimulator) {
-        clsHdcJdwpSimulator->stop();
-        delete clsHdcJdwpSimulator;
-        clsHdcJdwpSimulator = nullptr;
-    }
-    uv_stop(&loopMain);
-    TryCloseLoop(&loopMain, "Hdcjdwp test exit");
-    HiLog::Info(LABEL, "jdwp_test_process exit.");
-    PrintMessage("jdwp_test_process exit.");
-}
-
-static void Stop(int signo)
-{
-    FreeInstance();
-    _exit(0);
-}
-
-int main(int argc, const char *argv[])
-{
-    uv_loop_init(&loopMain);
-
-    HiLog::Info(LABEL, "jdwp_test_process start.");
-    PrintMessage("jdwp_test_process start.");
-    if (signal(SIGINT, Stop) == SIG_ERR) {
-        PrintMessage("jdwp_test_process signal fail.");
-    }
-    clsHdcJdwpSimulator = new HdcJdwpSimulator(&loopMain, "com.example.myapplication");
-    if (!clsHdcJdwpSimulator->Connect()) {
-        PrintMessage("Connect fail.");
-        return -1;
-    }
-    uv_run(&loopMain, UV_RUN_DEFAULT);
-
-#ifdef JS_JDWP_CONNECT
-    PrintMessage("Enter 'exit' will stop the test.");
-    std::string line;
-    while (std::getline(std::cin, line)) {
-        if (!strcmp(line.c_str(), "exit")) {
-            PrintMessage("Exit current process.");
-            break;
-        }
-    }
-    FreeInstance();
-#endif // JS_JDWP_CONNECT
-    return 0;
-}
\ No newline at end of file
diff --git a/hdc/src/test/main.cpp b/hdc/src/test/main.cpp
deleted file mode 100644
index 513b927..0000000
--- a/hdc/src/test/main.cpp
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "ut_common.h"
-using namespace Hdc;
-
-namespace HdcTest {
-TEST(HdcBaseFunction, HandleNoneZeroInput)
-{
-    char bufString[256] = "";
-    uint16_t num;
-    int argc = 0;
-    GTEST_ASSERT_LE(1, Base::GetRuntimeMSec());
-    GTEST_ASSERT_LE(10, Base::GetRandomNum(10, 12));
-    GTEST_ASSERT_EQ(0, Base::ConnectKey2IPPort("127.0.0.1:8080", bufString, &num, sizeof(bufString)));
-
-    Base::SplitCommandToArgs("xx p1 p2 p3", &argc);
-    GTEST_ASSERT_EQ(4, argc);
-}
-
-TEST(HdcBaseCommand, HandleNoneZeroInput)
-{
-    Runtime *ftest = new Runtime();
-    GTEST_ASSERT_EQ(true, ftest->Initial(false));
-    GTEST_ASSERT_EQ(true, ftest->CheckEntry(ftest->UT_MOD_BASE));
-    delete ftest;
-}
-
-TEST(HdcShellMod, HandleNoneZeroInput)
-{
-    Runtime *ftest = new Runtime();
-    GTEST_ASSERT_EQ(true, ftest->Initial(true));
-    GTEST_ASSERT_EQ(true, ftest->CheckEntry(ftest->UT_MOD_SHELL));
-    delete ftest;
-}
-
-TEST(HdcFileCommand, HandleNoneZeroInput)
-{
-    Runtime *ftest = new Runtime();
-    GTEST_ASSERT_EQ(true, ftest->Initial(true));
-    GTEST_ASSERT_EQ(true, ftest->CheckEntry(ftest->UT_MOD_FILE));
-    delete ftest;
-}
-
-TEST(HdcForwardCommand, HandleNoneZeroInput)
-{
-    Runtime *ftest = new Runtime();
-    GTEST_ASSERT_EQ(true, ftest->Initial(true));
-    GTEST_ASSERT_EQ(true, ftest->CheckEntry(ftest->UT_MOD_FORWARD));
-    delete ftest;
-}
-
-TEST(AppCommand, HandleNoneZeroInput)
-{
-    Runtime *ftest = new Runtime();
-    GTEST_ASSERT_EQ(true, ftest->Initial(true));
-    GTEST_ASSERT_EQ(true, ftest->CheckEntry(ftest->UT_MOD_APP));
-    delete ftest;
-}
-}  // namespace HdcTest
-
-int main(int argc, const char *argv[])
-{
-    int ret = 0;
-    // many feature under Win32 UT is not supported, so we cannot support it when unit test
-#ifdef _WIN32
-    printf("Unit test not support win32 platform\r\n");
-    return 0;
-#else
-    testing::InitGoogleTest(&argc, (char **)argv);
-    ret = RUN_ALL_TESTS();
-    WRITE_LOG(LOG_INFO, "Test all finish");
-#endif
-    return ret;
-}
\ No newline at end of file
diff --git a/hdc/src/test/ut_command.cpp b/hdc/src/test/ut_command.cpp
deleted file mode 100644
index 9543dd5..0000000
--- a/hdc/src/test/ut_command.cpp
+++ /dev/null
@@ -1,167 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "ut_command.h"
-using namespace Hdc;
-
-namespace HdcTest {
-void *TestBackgroundServerForClient(void *param)
-{
-    HdcServer server(true);
-    server.Initial("0.0.0.0:8710");
-    server.WorkerPendding();
-    WRITE_LOG(LOG_DEBUG, "Test ServerForClient free");
-    return nullptr;
-}
-
-void TestRunClient(const string &debugServerPort, const string &debugConnectKey, const string &cmd)
-{
-    uv_loop_t loopMain;
-    uv_loop_init(&loopMain);
-    HdcClient client(false, debugServerPort, &loopMain);
-    client.Initial(debugConnectKey);
-    client.ExecuteCommand(cmd);
-    uv_loop_close(&loopMain);
-}
-
-void PreConnectDaemon(const string &debugServerPort, const string &debugConnectKey)
-{
-    string bufString = "tconn ";
-    bufString += debugConnectKey;
-    WRITE_LOG(LOG_DEBUG, "------------Connect command------------");
-    TestRunClient(debugServerPort, "", bufString.c_str());
-}
-
-int TestRuntimeCommandSimple(bool bTCPorUSB, int method, bool bNeedConnectDaemon)
-{
-    // These two parameters are tested, not much change, manually modify by myself
-    string debugServerPort;
-    string debugConnectKey;
-    debugServerPort = DEBUG_ADDRESS;
-    if (bTCPorUSB) {
-        debugConnectKey = DEBUG_TCP_CONNECT_KEY;
-    } else {
-        debugConnectKey = DEBUG_USB_CONNECT_KEY;
-    }
-    if (bNeedConnectDaemon) {  // just tcp
-        PreConnectDaemon(debugServerPort, debugConnectKey);
-    }
-    WRITE_LOG(LOG_DEBUG, "Test Jump TestRuntimeCommand");
-    TestRuntimeCommand(method, debugServerPort, debugConnectKey);
-    return 0;
-}
-
-int TestTaskCommand(int method, const string &debugServerPort, const string &debugConnectKey)
-{
-    WRITE_LOG(LOG_DEBUG, "------------Operate command------------");
-    string bufString;
-    switch (method) {
-        case UT_SHELL_BASIC:  // Basic order test
-            TestRunClient(debugServerPort, debugConnectKey, "shell id");
-            break;
-        case UT_SHELL_LIGHT:  // Small pressure test
-            TestRunClient(debugServerPort, debugConnectKey, "shell cat /etc/passwd");
-            break;
-        case UT_SHELL_HEAVY:  // High pressure test (Long Time)
-            TestRunClient(debugServerPort, debugConnectKey, "shell cat /data/local/tmp/root.txt");
-            break;
-        case UT_SHELL_INTERACTIVE:  // Interactive shell test
-            TestRunClient(debugServerPort, debugConnectKey, CMDSTR_SHELL.c_str());
-            break;
-        case UT_FILE_SEND: {  // send files
-            bufString = Base::StringFormat("file send %s/file.local %s/file.remote", UT_TMP_PATH.c_str(),
-                                           UT_TMP_PATH.c_str());
-            TestRunClient(debugServerPort, debugConnectKey, bufString);
-            break;
-        }
-        case UT_FILE_RECV:  // recv files
-            TestRunClient(debugServerPort, debugConnectKey,
-                          "file recv /mnt/hgfs/vtmp/f.txt /mnt/hgfs/vtmp/f2.txt -z 1");
-            break;
-        case UT_FORWARD_TCP2TCP:  // TCP forward
-            TestRunClient(debugServerPort, debugConnectKey, "fport tcp:8081 tcp:8082");
-            break;
-        case UT_FORWARD_TCP2FILE:  // localfilesystem forward
-            TestRunClient(debugServerPort, debugConnectKey, "fport tcp:8081 localfilesystem:mysocket");
-            break;
-        case UT_FORWARD_TCP2DEV:
-            TestRunClient(debugServerPort, debugConnectKey, "fport tcp:8081 dev:/dev/urandom");
-            break;
-        case UT_FORWARD_TCP2JDWP:  // jdwp forward
-            TestRunClient(debugServerPort, debugConnectKey, "fport tcp:8081 jdwp:1234");
-            break;
-        case UT_APP_INSTALL:  // Single and multiple and multiple paths support
-            bufString = Base::StringFormat("install %s/app.hap", UT_TMP_PATH.c_str());
-            TestRunClient(debugServerPort, debugConnectKey, bufString);
-            break;
-        case UT_TEST_TMP:
-#ifdef DEF_NULL
-            while (true) {
-                uv_sleep(GLOBAL_TIMEOUT);
-                TestRunClient(debugServerPort, debugConnectKey, "list targets");
-                TestRunClient(debugServerPort, debugConnectKey, "shell id");
-                TestRunClient(debugServerPort, debugConnectKey, "shell bm dump -a");
-            }
-            TestRunClient(debugServerPort, debugConnectKey, "install /d/helloworld.hap");
-            TestRunClient(debugServerPort, debugConnectKey, "target mount");
-            TestRunClient(debugServerPort, debugConnectKey, "shell pwd");
-            TestRunClient(debugServerPort, debugConnectKey, "target mount");
-            TestRunClient(debugServerPort, debugConnectKey, "shell pwd");
-            TestRunClient(debugServerPort, debugConnectKey, "install /d -rt");
-            TestRunClient(debugServerPort, debugConnectKey, "fport tcp:8081 tcp:8082");
-            TestRunClient(debugServerPort, debugConnectKey, "fport tcp:8081 dev:/dev/urandom");
-            TestRunClient(debugServerPort, debugConnectKey, "shell hilog");
-            TestRunClient(debugServerPort, debugConnectKey, "file send /mnt/hgfs/vtmp/f.txt /tmp/f2.txt");
-            TestRunClient(debugServerPort, debugConnectKey, "file recv /tmp/f2.txt /mnt/hgfs/vtmp/f2.txt");
-            TestRunClient(debugServerPort, debugConnectKey, "shell find /proc");
-            TestRunClient(debugServerPort, debugConnectKey, "file send \"/d/a b/1.txt\" \"/d/a b/2.txt\"");
-            TestRunClient(debugServerPort, debugConnectKey, "file recv \"/d/a b/1.txt\" \"/d/a b/2.txt\"");
-#endif
-            break;
-        default:
-            break;
-    }
-    WRITE_LOG(LOG_DEBUG, "!!!Client finish");
-    return 0;
-}
-
-int TestRuntimeCommand(const int method, const string &debugServerPort, const string &debugConnectKey)
-{
-    switch (method) {
-        case UT_HELP:
-            TestRunClient(debugServerPort, "", CMDSTR_SOFTWARE_HELP.c_str());
-            TestRunClient(debugServerPort, "", CMDSTR_SOFTWARE_VERSION.c_str());
-            break;
-        case UT_DISCOVER:
-            TestRunClient(debugServerPort, "", CMDSTR_TARGET_DISCOVER.c_str());
-            break;
-        case UT_LIST_TARGETS:
-            TestRunClient(debugServerPort, "", CMDSTR_LIST_TARGETS.c_str());
-            break;
-        case UT_CONNECT_ANY:
-            TestRunClient(debugServerPort, "", CMDSTR_CONNECT_ANY.c_str());
-            break;
-        case UT_KILL_SERVER:
-            TestRunClient(debugServerPort, "", CMDSTR_SERVICE_KILL.c_str());
-            break;
-        case UT_KILL_DAEMON:
-            TestRunClient(debugServerPort, debugConnectKey, "kill daemon");
-            break;
-        default:
-            TestTaskCommand(method, debugServerPort, debugConnectKey);
-            break;
-    }
-    return 0;
-}
-}  // namespace HdcTest
diff --git a/hdc/src/test/ut_command.h b/hdc/src/test/ut_command.h
deleted file mode 100644
index d8c7aa4..0000000
--- a/hdc/src/test/ut_command.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_UT_COMMAND_H
-#define HDC_UT_COMMAND_H
-#include "ut_common.h"
-
-namespace HdcTest {
-enum UtType {
-    UT_HELP,
-    UT_DISCOVER,
-    UT_LIST_TARGETS,
-    UT_CONNECT_ANY,
-    UT_KILL_SERVER,
-    UT_KILL_DAEMON,
-    UT_SHELL_BASIC,
-    UT_SHELL_LIGHT,
-    UT_SHELL_HEAVY,
-    UT_SHELL_INTERACTIVE,
-    UT_FILE_SEND,
-    UT_FILE_RECV,
-    UT_FORWARD_TCP2TCP,
-    UT_FORWARD_TCP2FILE,
-    UT_FORWARD_TCP2DEV,
-    UT_FORWARD_TCP2JDWP,
-    UT_APP_INSTALL,
-    UT_TEST_TMP,
-};
-
-const string DEBUG_ADDRESS = Hdc::DEFAULT_SERVER_ADDR;
-const string DEBUG_TCP_CONNECT_KEY = "127.0.0.1:10178";
-const string DEBUG_USB_CONNECT_KEY = "any";
-
-int TestRuntimeCommand(const int method, const string &debugServerPort, const string &debugConnectKey);
-int TestRuntimeCommandSimple(bool bTCPorUSB, int method, bool bNeedConnectDaemon);
-void TestRunClient(const string &debugServerPort, const string &debugConnectKey, const string &cmd);
-void PreConnectDaemon(const string &debugServerPort, const string &debugConnectKey);
-void *TestBackgroundServerForClient(void *param);
-void *DdmcallThreadEntry(void *param);
-int DdmCallCommandEntry(int argc, const char *argv[]);
-}  // namespace HdcTest
-#endif
\ No newline at end of file
diff --git a/hdc/src/test/ut_common.h b/hdc/src/test/ut_common.h
deleted file mode 100644
index 83eeefe..0000000
--- a/hdc/src/test/ut_common.h
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_UT_COMMON_H
-#define HDC_UT_COMMON_H
-#include "daemon_common.h"
-#include "host_common.h"
-#include "server.h"
-
-using Hdc::HdcClient;
-using Hdc::HdcServer;
-
-#ifndef _WIN32
-#include <gtest/gtest.h>
-#endif
-#include <openssl/md5.h>
-#include <stdio.h>
-#include <uv.h>
-
-#include "ut_command.h"
-#include "ut_mod.h"
-#include "ut_runtime.h"
-
-#endif  // end HDC_UT_COMMON_H
diff --git a/hdc/src/test/ut_mod.cpp b/hdc/src/test/ut_mod.cpp
deleted file mode 100644
index 054da32..0000000
--- a/hdc/src/test/ut_mod.cpp
+++ /dev/null
@@ -1,305 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "ut_mod.h"
-#include <openssl/evp.h>
-#include <openssl/md5.h>
-using namespace Hdc;
-
-namespace HdcTest {
-bool TestBaseCommand(void *runtimePtr)
-{
-    Runtime *rt = (Runtime *)runtimePtr;
-    uint8_t *bufPtr = nullptr;
-    int bytesIO = 0;
-    bool ret = false;
-    // test 'discover'
-    rt->InnerCall(UT_DISCOVER);
-    if ((bytesIO = Base::ReadBinFile((UT_TMP_PATH + "/base-discover.result").c_str(),
-                                     reinterpret_cast<void **>(&bufPtr), 0)) < 0) {
-        return false;
-    }
-    if (!strcmp("0", reinterpret_cast<char *>(bufPtr))) {
-        delete[] bufPtr;
-        bufPtr = nullptr;
-        return false;
-    }
-    delete[] bufPtr;
-    bufPtr = nullptr;
-    // test 'targets'
-    rt->InnerCall(UT_LIST_TARGETS);
-    constexpr int expert = 5;
-    if ((bytesIO = Base::ReadBinFile((UT_TMP_PATH + "/base-list.result").c_str(),
-                                     reinterpret_cast<void **>(&bufPtr), 0)) < expert) {
-        goto Finish;
-    }
-    if (strcmp(MESSAGE_SUCCESS.c_str(), reinterpret_cast<char *>(bufPtr))) {
-        goto Finish;
-    }
-    delete[] bufPtr;
-    bufPtr = nullptr;
-    // test 'any'
-    rt->InnerCall(UT_CONNECT_ANY);
-    if ((bytesIO = Base::ReadBinFile((UT_TMP_PATH + "/base-any.result").c_str(),
-                                     reinterpret_cast<void **>(&bufPtr), 0)) < 0) {
-        goto Finish;
-    }
-    if (strcmp(MESSAGE_SUCCESS.c_str(), reinterpret_cast<char *>(bufPtr))) {
-        goto Finish;
-    }
-    // all pass
-    ret = true;
-
-Finish:
-    if (bufPtr) {
-        delete[] bufPtr;
-        bufPtr = nullptr;
-    }
-    return ret;
-}
-
-bool TestShellExecute(void *runtimePtr)
-{
-    Runtime *rt = (Runtime *)runtimePtr;
-    uint8_t *bufPtr = nullptr;
-    int bytesIO = 0;
-    bool ret = false;
-    char bufString[BUF_SIZE_DEFAULT4] = "";
-    string resultFile = "execute.result";
-    while (true) {
-        // test1
-        rt->InnerCall(UT_SHELL_BASIC);
-        constexpr int expert = 10;
-        if ((bytesIO = Base::ReadBinFile((UT_TMP_PATH + "/" + resultFile).c_str(),
-                                         reinterpret_cast<void **>(&bufPtr), 0)) < expert) {
-            break;
-        }
-        Base::RunPipeComand(const_cast<const char *>("id"), bufString, sizeof(bufString), false);
-        if (strcmp(bufString, reinterpret_cast<char *>(bufPtr))) {
-            break;
-        }
-        delete[] bufPtr;
-        bufPtr = nullptr;
-
-        // test 2
-        rt->ResetUtTmpFile(resultFile);
-        rt->InnerCall(UT_SHELL_LIGHT);
-        if ((bytesIO = Base::ReadBinFile((UT_TMP_PATH + "/" + resultFile).c_str(),
-                                         reinterpret_cast<void **>(&bufPtr), 0)) < expert) {
-            break;
-        }
-        Base::RunPipeComand(const_cast<const char *>("cat /etc/passwd"), bufString, sizeof(bufString), false);
-        if (strcmp(bufString, reinterpret_cast<char *>(bufPtr))) {
-            break;
-        }
-        delete[] bufPtr;
-        bufPtr = nullptr;
-
-        // all pass
-        ret = true;
-        break;
-    }
-    if (bufPtr) {
-        delete[] bufPtr;
-    }
-    return ret;
-}
-
-vector<uint8_t> Md5Sum(uint8_t *buf, int size)
-{
-    vector<uint8_t> ret;
-    uint8_t md5Hash[MD5_DIGEST_LENGTH] = { 0 };
-    if (EVP_Digest(buf, size, md5Hash, NULL, EVP_md5(), NULL)) {
-        ret.insert(ret.begin(), md5Hash, md5Hash + sizeof(md5Hash));
-    }
-    return ret;
-}
-
-// file send like recv in our code, so just test send is enough
-bool TestFileCommand(void *runtimePtr)
-{
-    Runtime *rt = (Runtime *)runtimePtr;
-    bool ret = false;
-    char bufString[BUF_SIZE_DEFAULT] = "";
-    uint8_t *bufLocal = nullptr;
-    uint8_t *bufRemote = nullptr;
-    int sizeLocal = 0;
-    int sizeRemote = 0;
-    string localFile = Base::StringFormat("%s/file.local", UT_TMP_PATH.c_str());
-    string remoteFile = Base::StringFormat("%s/file.remote", UT_TMP_PATH.c_str());
-    do {
-        // to be use random buf, not bash result
-        string cmd = Base::StringFormat("find /usr > %s", localFile.c_str());
-        Base::RunPipeComand(cmd.c_str(), bufString, sizeof(bufString), false);
-        rt->InnerCall(UT_FILE_SEND);
-        if ((sizeLocal = Base::ReadBinFile(localFile.c_str(), reinterpret_cast<void **>(&bufLocal), 0)) < 0) {
-            break;
-        };
-        if ((sizeRemote = Base::ReadBinFile(remoteFile.c_str(), reinterpret_cast<void **>(&bufRemote), 0)) < 0) {
-            break;
-        };
-        auto localHash = Md5Sum(bufLocal, sizeLocal);
-        auto remoteHash = Md5Sum(bufRemote, sizeRemote);
-        if (memcmp(localHash.data(), remoteHash.data(), localHash.size())) {
-            break;
-        }
-        ret = true;
-    } while (false);
-
-    if (bufLocal) {
-        delete[] bufLocal;
-    }
-    if (bufRemote) {
-        delete[] bufRemote;
-    }
-    return ret;
-}
-
-void UtForwardWaiter(uv_loop_t *loop, uv_tcp_t *server)
-{
-    auto funcOnNewConn = [](uv_stream_t *server, int status) -> void {
-        auto funcOnRead = [](uv_stream_t *client, ssize_t nread, const uv_buf_t *buf) -> void {
-            if (nread > 0 && !strcmp(buf->base, MESSAGE_SUCCESS.c_str())) {
-                Base::WriteBinFile((UT_TMP_PATH + "/forward.result").c_str(),
-                                   reinterpret_cast<uint8_t *>(MESSAGE_SUCCESS.c_str()),
-                                   MESSAGE_SUCCESS.size(), true);
-            }
-            uv_close((uv_handle_t *)client, [](uv_handle_t *handle) { free(handle); });
-            free(buf->base);
-        };
-        if (status < 0) {
-            return;
-        }
-        uv_tcp_t *client = new uv_tcp_t();
-        uv_tcp_init(server->loop, client);
-        if (uv_accept(server, (uv_stream_t *)client) == 0) {
-            uv_read_start((uv_stream_t *)client,
-                          [](uv_handle_t *handle, size_t suggested_size, uv_buf_t *buf) {
-                              buf->base = new char[suggested_size]();
-                              buf->len = suggested_size;
-                          },
-                          funcOnRead);
-        } else {
-            uv_close((uv_handle_t *)client, [](uv_handle_t *handle) { free(handle); });
-        }
-    };
-    const int utForwardTargetPort = 8082;
-    struct sockaddr_in addr;
-    if (uv_tcp_init(loop, server) || uv_ip4_addr("127.0.0.1", utForwardTargetPort, &addr)) {
-        return;
-    }
-    if (uv_tcp_bind(server, (const struct sockaddr *)&addr, 0) || uv_listen((uv_stream_t *)server, 5, funcOnNewConn)) {
-        return;
-    }
-    WRITE_LOG(LOG_DEBUG, "UtForwardWaiter listen on port:%d", utForwardTargetPort);
-}
-
-bool UtForwardConnect(uv_loop_t *loop, uv_tcp_t *client, uv_tcp_t *server)
-{
-    auto funcConn = [](uv_connect_t *req, int status) -> void {
-        uv_tcp_t *server = (uv_tcp_t *)req->data;
-        delete req;
-        if (status < 0) {
-            return;
-        }
-        Base::SendToStream((uv_stream_t *)req->handle, (uint8_t *)MESSAGE_SUCCESS.c_str(), MESSAGE_SUCCESS.size());
-        Base::DelayDoSimple(req->handle->loop, 3000, [=](const uint8_t flag, string &msg, const void *p) {
-            uv_close((uv_handle_t *)server, nullptr);  // notify UtForwardWaiter stop
-        });
-    };
-
-    const int utForwardListenPort = 8081;
-    struct sockaddr_in addr;
-    bool ret = false;
-    uv_connect_t *connReq = new uv_connect_t();
-    connReq->data = server;
-    do {
-        if (uv_tcp_init(loop, client)) {
-            break;
-        }
-        uv_ip4_addr("127.0.0.1", utForwardListenPort, &addr);
-        if (uv_tcp_connect(connReq, client, (const struct sockaddr *)&addr, funcConn)) {
-            break;
-        }
-
-        ret = true;
-    } while (false);
-    return ret;
-}
-
-void TestForwardExternThread(void *arg)
-{
-    uv_loop_t loop;
-    uv_tcp_t server;
-    uv_tcp_t client;
-    const int clientForwardTimeout = 1000;
-    bool *clientOK = (bool *)arg;
-    auto funcDelayCallUtForwardConnect = [&](const uint8_t flag, string &msg, const void *p) -> void {
-        if (!*clientOK) {
-            // client create forward timeout
-            WRITE_LOG(LOG_WARN, "Client forward timeout");
-            uv_stop(&loop);
-        }
-        UtForwardConnect(&loop, &client, &server);
-    };
-
-    uv_loop_init(&loop);
-    UtForwardWaiter(&loop, &server);
-    Base::DelayDoSimple(&loop, clientForwardTimeout, funcDelayCallUtForwardConnect);
-    uv_run(&loop, UV_RUN_DEFAULT);
-    uv_loop_close(&loop);
-};
-
-bool TestForwardCommand(void *runtimePtr)
-{
-    Runtime *rt = (Runtime *)runtimePtr;
-    uv_thread_t td;
-    char buf[BUF_SIZE_TINY] = "";
-    bool clientOK = false;
-    int sizeResult = 0;
-    uv_thread_create(&td, TestForwardExternThread, &clientOK);
-    rt->InnerCall(UT_FORWARD_TCP2TCP);
-    clientOK = true;
-    uv_thread_join(&td);
-    // all done, we will check result ok
-    string localFile = Base::StringFormat("%s/forward.result", UT_TMP_PATH.c_str());
-    if ((sizeResult = Base::ReadBinFile(localFile.c_str(), reinterpret_cast<void **>(buf), sizeof(buf))) < 0) {
-        return false;
-    };
-    if (strcmp(buf, MESSAGE_SUCCESS.c_str())) {
-        return false;
-    }
-    return true;
-}
-
-bool TestAppCommand(void *runtimePtr)
-{
-    Runtime *rt = (Runtime *)runtimePtr;
-    char bufString[BUF_SIZE_DEFAULT] = "";
-    string localFile = Base::StringFormat("%s/app.hap", UT_TMP_PATH.c_str());
-    string cmd = Base::StringFormat("id --help > %s", localFile.c_str());  // I know it is a invalid hap file
-    Base::RunPipeComand(cmd.c_str(), bufString, sizeof(bufString), false);
-    rt->InnerCall(UT_APP_INSTALL);
-
-    constexpr int expert = 5;
-    if (Base::ReadBinFile((UT_TMP_PATH + "/appinstall.result").c_str(), reinterpret_cast<void **>(&bufString),
-                          sizeof(bufString)) < expert) {
-        return false;
-    }
-    if (strcmp(MESSAGE_SUCCESS.c_str(), reinterpret_cast<char *>(bufString))) {
-        return false;
-    }
-    return true;
-}
-}  // namespace HdcTest
\ No newline at end of file
diff --git a/hdc/src/test/ut_mod.h b/hdc/src/test/ut_mod.h
deleted file mode 100644
index 4681c71..0000000
--- a/hdc/src/test/ut_mod.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_UT_MOD_H
-#define HDC_UT_MOD_H
-#include "ut_common.h"
-
-namespace HdcTest {
-bool TestBaseCommand(void *runtimePtr);
-bool TestShellExecute(void *runtimePtr);
-bool TestFileCommand(void *runtimePtr);
-bool TestForwardCommand(void *runtimePtr);
-bool TestAppCommand(void *runtimePtr);
-
-}  // namespace HdcTest
-#endif  // HDC_FUNC_TEST_H
\ No newline at end of file
diff --git a/hdc/src/test/ut_runtime.cpp b/hdc/src/test/ut_runtime.cpp
deleted file mode 100644
index 170cf43..0000000
--- a/hdc/src/test/ut_runtime.cpp
+++ /dev/null
@@ -1,228 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#include "ut_runtime.h"
-using namespace Hdc;
-
-namespace HdcTest {
-Runtime::Runtime()
-{
-    uv_loop_init(&loopMain);
-    bCheckResult = false;
-    checkFinish = false;
-    hashInitialize = false;
-    // UintTest Running log level LOG_INFO/LOG_ALL
-    Base::SetLogLevel(Hdc::LOG_INFO);
-    // three nodes all run host, at least 5+(reserve:2)=7 threads for use
-    // client 1 + (server+daemon)= SIZE_THREAD_POOL*2+1
-    string threadNum = std::to_string(SIZE_THREAD_POOL * 2);
-    uv_os_setenv("UV_THREADPOOL_SIZE", threadNum.c_str());
-    ResetUtTmpFolder();
-
-    serverRunning = false;
-    daemonRunning = false;
-};
-
-Runtime::~Runtime()
-{
-    constexpr int sleepTime = 500;
-    if (hashInitialize) {
-        Base::TryCloseLoop(&loopMain, "Runtime childUV");
-        uv_loop_close(&loopMain);
-    }
-    while (serverRunning || daemonRunning) {
-        uv_sleep(sleepTime);
-    }
-};
-
-int Runtime::InnerCall(int method)
-{
-    return TestRuntimeCommand(method, DEBUG_ADDRESS.c_str(), DEBUG_TCP_CONNECT_KEY.c_str());
-}
-
-void Runtime::CheckStopServer(uv_idle_t *arg)
-{
-    Runtime *thisClass = (Runtime *)arg->data;
-    thisClass->serverRunning = true;
-    if (!thisClass->checkFinish) {
-        return;
-    }
-    WRITE_LOG(LOG_DEBUG, "Try stop test server");
-    thisClass->server->PostStopInstanceMessage();
-    Base::TryCloseHandle((uv_handle_t *)&thisClass->checkServerStop);
-}
-
-void Runtime::StartServer(uv_work_t *arg)
-{
-    constexpr int sleepTime = 1000;
-    Runtime *thisClass = static_cast<Runtime *>(arg->data);
-    uv_sleep(sleepTime);
-    HdcServer server(true);
-    server.Initial(DEFAULT_SERVER_ADDR.c_str());
-    thisClass->server = &server;
-
-    uv_idle_t *idt = &thisClass->checkServerStop;
-    idt->data = thisClass;
-    uv_idle_init(&server.loopMain, idt);
-    uv_idle_start(idt, CheckStopServer);
-
-    server.WorkerPendding();
-    WRITE_LOG(LOG_DEBUG, "TestServerForClient free");
-}
-
-void Runtime::CheckStopDaemon(uv_idle_t *arg)
-{
-    Runtime *thisClass = (Runtime *)arg->data;
-    thisClass->daemonRunning = true;
-    if (!thisClass->checkFinish) {
-        return;
-    }
-    WRITE_LOG(LOG_DEBUG, "Try stop test daemon");
-    thisClass->daemon->PostStopInstanceMessage();
-    Base::TryCloseHandle((uv_handle_t *)&thisClass->checkDaemonStop);
-}
-
-void Runtime::StartDaemon(uv_work_t *arg)
-{
-    Runtime *thisClass = static_cast<Runtime *>(arg->data);
-    HdcDaemon daemon(false);
-    daemon.InitMod(true, false);
-    thisClass->daemon = &daemon;
-
-    uv_idle_t *idt = &thisClass->checkDaemonStop;
-    idt->data = thisClass;
-    uv_idle_init(&daemon.loopMain, idt);
-    uv_idle_start(idt, CheckStopDaemon);
-
-    daemon.WorkerPendding();
-    WRITE_LOG(LOG_DEBUG, "TestDaemon free");
-}
-
-int Runtime::CheckServerDaemonReady()
-{
-    constexpr auto waitCount = 10;
-    if (++waitServerDaemonReadyCount > waitCount) {
-        return ERR_UT_MODULE_WAITMAX;
-    }
-    if (!serverRunning || !daemonRunning) {
-        return ERR_UT_MODULE_NOTREADY;
-    }
-    if (bConnectToDaemon) {
-        PreConnectDaemon(DEBUG_ADDRESS.c_str(), DEBUG_TCP_CONNECT_KEY.c_str());
-    }
-    hashInitialize = true;
-    return RET_SUCCESS;
-}
-
-void Runtime::DoCheck(uv_timer_t *handle)
-{
-    Runtime *thisClass = (Runtime *)handle->data;
-    do {
-        int checkRet = thisClass->CheckServerDaemonReady();
-        if (checkRet == ERR_UT_MODULE_WAITMAX) {
-            break;
-        } else if (checkRet == ERR_UT_MODULE_NOTREADY) {
-            return;
-        }
-        // every case can be add more test...
-        switch (thisClass->checkType) {
-            case UT_MOD_SHELL:
-                thisClass->bCheckResult = TestShellExecute(thisClass);
-                break;
-            case UT_MOD_BASE:
-                thisClass->bCheckResult = TestBaseCommand(thisClass);
-                break;
-            case UT_MOD_FILE:
-                thisClass->bCheckResult = TestFileCommand(thisClass);
-                break;
-            case UT_MOD_FORWARD:
-                thisClass->bCheckResult = TestForwardCommand(thisClass);
-                break;
-            case UT_MOD_APP:
-                thisClass->bCheckResult = TestAppCommand(thisClass);
-                break;
-            default:
-                break;
-        }
-    } while (false);
-    uv_close((uv_handle_t *)handle, Base::CloseIdleCallback);
-    thisClass->checkFinish = true;
-}
-
-bool Runtime::Initial(bool bConnectToDaemonIn)
-{
-    bConnectToDaemon = bConnectToDaemonIn;
-    constexpr int sleepTime = 300;
-    auto funcServerFinish = [](uv_work_t *req, int status) -> void {
-        auto thisClass = (Runtime *)req->data;
-        thisClass->serverRunning = false;
-        WRITE_LOG(LOG_DEBUG, "Ut runtime frame server thread finish");
-        delete req;
-    };
-    auto funcDaemonFinish = [](uv_work_t *req, int status) -> void {
-        auto thisClass = (Runtime *)req->data;
-        thisClass->daemonRunning = false;
-        WRITE_LOG(LOG_DEBUG, "Ut runtime frame daemon thread finish");
-        delete req;
-    };
-
-    Base::StartWorkThread(&loopMain, StartServer, funcServerFinish, this);
-    Base::StartWorkThread(&loopMain, StartDaemon, funcDaemonFinish, this);
-    Base::TimerUvTask(&loopMain, this, DoCheck, sleepTime);
-    return true;
-}
-
-bool Runtime::CheckEntry(UtModType type)
-{
-    checkFinish = false;
-    checkType = type;
-
-    WorkerPendding();
-    return bCheckResult;
-}
-
-bool Runtime::ResetUtTmpFolder()
-{
-#ifdef DEF_NULL
-    struct stat statbuf;
-    if (!stat(UT_TMP_PATH.c_str(), &statbuf))
-        unlink(UT_TMP_PATH.c_str());  // exist
-#endif
-    string sCmd = "rm -rf " + UT_TMP_PATH;
-    struct stat statbuf;
-    if (!stat(UT_TMP_PATH.c_str(), &statbuf)) {
-        system(sCmd.c_str());
-    }
-    constexpr uint32_t perm = 0666;
-    mkdir(UT_TMP_PATH.c_str(), perm);
-    return true;
-}
-
-bool Runtime::ResetUtTmpFile(string file)
-{
-    string utFile = Base::StringFormat("%s/%s", UT_TMP_PATH.c_str(), file.c_str());
-    string sCmd = "rm -f " + utFile;
-    struct stat statbuf;
-    if (!stat(utFile.c_str(), &statbuf)) {
-        system(sCmd.c_str());
-    }
-    return true;
-}
-
-void Runtime::WorkerPendding()
-{
-    uv_run(&loopMain, UV_RUN_DEFAULT);
-    WRITE_LOG(LOG_DEBUG, "TesPendding free");
-}
-}  // namespace HdcTest
diff --git a/hdc/src/test/ut_runtime.h b/hdc/src/test/ut_runtime.h
deleted file mode 100644
index 744ab3f..0000000
--- a/hdc/src/test/ut_runtime.h
+++ /dev/null
@@ -1,67 +0,0 @@
-/*
- * Copyright (C) 2021 Huawei Device Co., Ltd.
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-#ifndef HDC_UT_RUNTIME_H
-#define HDC_UT_RUNTIME_H
-#include "ut_common.h"
-
-namespace HdcTest {
-class Runtime {
-public:
-    enum UtModType {
-        UT_MOD_BASE,
-        UT_MOD_SHELL,
-        UT_MOD_SHELL_INTERACTIVE,
-        UT_MOD_FILE,
-        UT_MOD_FORWARD,
-        UT_MOD_APP,
-    };
-    Runtime();
-    ~Runtime();
-    bool Initial(bool bConnectToDaemonIn);
-    bool CheckEntry(UtModType type);
-
-    bool ResetUtTmpFolder();
-    bool ResetUtTmpFile(string file);
-    int InnerCall(int method);
-    uv_loop_t *GetRuntimeLoop()
-    {
-        return &loopMain;
-    };
-
-private:
-    static void DoCheck(uv_timer_t *handle);
-    static void StartServer(uv_work_t *arg);
-    static void StartDaemon(uv_work_t *arg);
-    static void CheckStopServer(uv_idle_t *arg);
-    static void CheckStopDaemon(uv_idle_t *arg);
-    void WorkerPendding();
-    int CheckServerDaemonReady();
-
-    bool serverRunning;
-    bool daemonRunning;
-    bool bCheckResult;
-    bool checkFinish;
-    bool hashInitialize;
-    UtModType checkType;
-    uv_loop_t loopMain;
-    uv_idle_t checkServerStop;
-    uv_idle_t checkDaemonStop;
-    Hdc::HdcServer *server;
-    void *daemon;  // Hdc::HdcDaemon *
-    uint8_t waitServerDaemonReadyCount = 0;
-    bool bConnectToDaemon = false;
-};
-}  // namespace HdcTest
-#endif  // HDC_FUNC_TEST_H
\ No newline at end of file
